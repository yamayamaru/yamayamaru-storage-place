*****************************************************************************
目次                                        拡張ライブラリI V2.1 リファレンス
*****************************************************************************

第1章  拡張ライブラリI V2.1

1 拡張ライブラリI V2.1について
1.1 概要
1.2 開発環境
1.3 ファイル構成
1.4 注意事項
2 開発環境の構築
2.1 インストールによる開発環境の構築
2.2 High C(R)Compilerの環境設定
3 機能/ヘッダ･ライブラリ対応一覧

第2章  かな漢字変換ライブラリ

1 かな漢字変換ライブラリについて
1.1 概要
1.2 基本動作フロー
1.3 ヘッダファイルKKSTR2.Hについて
1.4 各関数からのエラー一覧
2 かな漢字変換ライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第3章  ソフトウェアキーボードライブラリ

1 ソフトウェアキーボードライブラリについて
1.1 概要
1.2 基本動作フロー
1.3 ヘッダファイルについて
1.4 ソフトウェアキーボードエラー情報
2 ソフトウェアキーボードライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第4章  サイドワークライブラリ

1 サイドワーク機構の概要
2 サイドワークの運用
2.1 サイドワーク定義ファイル
2.2 サイドワークスタートコマンド
2.3 サイドワークの取り外し/組み込み
3 サイドワークのメカニズム
3.1 サイドワークドライバ
3.2 メモリ管理
3.3 プロセス管理
4 データ通信
4.1 フロントエンド処理機能
5 サイドワークプログラミング
5.1 開発環境
5.2 プログラミング指針
5.3 プログラミング規約
5.4 サイドワークライブラリの関数一覧
5.5 各関数の解説
5.6 サンプルプログラム
5.7 サイドワークプログラムのデバッグ方法
6 アプリケーションとサイドワーク
6.1 アプリケーションプログラムからのサイドワーク起動
6.2 関数一覧
6.3 各関数の解説

第5章  オーバレイライブラリ

1 オーバレイライブラリについて
1.1 概要
1.2 動作モードについて
1.3 基本動作フロー
1.4 注意事項
2 DTAについて
2.1 概要
2.2 プロセス間のDTA関係
3 オーバレイライブラリ
3.1 関数一覧
3.2 各関数の解説
3.3 サンプルプログラム

第6章  TIFFライブラリ

1 TIFFライブラリについて
1.1 概要
1.2 使用方法
1.3 エラーについて
2 TIFFライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第7章  ベクトルフォントライブラリ

1 ベクトルフォントライブラリについて
1.1 概要
1.2 使用方法
1.3 注意事項
2 ベクトルフォントライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第8章  Native RS-232Cライブラリ

1 Native RS-232Cライブラリについて
1.1 概要
1.2 基本動作フロー
2 Native RS-232Cライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第9章  ダイナミックリンクサポートライブラリ

1 ダイナミックリンクサポートライブラリについて
1.1 ダイナミックリンクとは
1.2 ダイナミックリンクの特徴
1.3 ダイナミックリンク実現方式の概要
2 ダイナミックリンクを利用した開発
2.1 ダイナミックリンクを利用するアプリケーションの作成
2.2 ダイナミックリンクライブラリの作成
2.3 ダイナミックリンクを利用するアプリケーションの開発手順
2.4 ダイナミックリンクライブラリの開発手順
2.5 リソース定義ファイル
2.6 ダイナミックリンクライブラリのディレクトリ
2.7 ダイナミックリンクライブラリの属性
2.8 リソース変換ツール
2.9 複数のリソースの扱い
2.10 開発手順例
3 ダイナミックリンクのメカニズム
3.1 ダイナミックリンクのしかけ
3.2 メモリ管理
3.3 ダイナミックリンクライブラリのローディング
3.4 ダイナミックリンクライブラリモジュールの構造
3.5 ダイナミックリンクの注意事項
4 ダイナミックリンクサポートライブラリ
4.1 関数一覧
4.2 各関数の解説
4.3 サンプルプログラム
4.4 デバッグ

第10章  ポケットライブラリ

1 ポケットライブラリについて
1.1 概要
1.2 ユーザビュー
1.3 ポケット領域とサイズ
1.4 ポケットデータ
1.5 アプリケーションインタフェース
2 ポケットライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第11章  サウンドメッセージライブラリ

1 サウンドメッセージライブラリについて
1.1 概要
1.2 サウンドメッセージ機構全体像
1.3 サウンドメッセージデータID
1.4 注意事項
2 サウンドメッセージライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第12章  プリンタドライバライブラリ

1 プリンタドライバライブラリについて
1.1 概要
2 スクリプト情報の構成
2.1 構成
2.2 書式
2.3 検索キーの書式
3 プリンタ用API 
3.1 ヘッダファイル
3.2 入力データの形式
3.3 プリンタインタフェース関数一覧
3.4 各関数の解説
3.5 サンプルプログラム
4 スクリプト情報アクセス機能
4.1 概要
4.2 ヘッダファイル
4.3 LPTインタフェース関数一覧
4.4 各関数の解説
5 IPU用API部
5.1 概要
5.2 ヘッダファイル
5.3 IPUインタフェース関数一覧
5.4 各関数の解説
5.5 サンプルプログラム

第13章  拡張フォント管理ライブラリ

1 拡張フォント管理ライブラリについて
1.1 概要
1.2 注意事項
1.3 著作権に関する注意
1.4 基本操作フロー
1.5 アプリケーション開発時の注意事項
1.6 イメージ描画方法
1.7 プロポーショナル文字の制御
1.8 アウトラインデータの利用方法について
1.9 キャッシュ機能について
1.10 構造体
1.11 構造体の共通項目詳細説明
2 拡張フォント管理ライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第14章  アイテム登録ライブラリ

1 アイテム登録ライブラリについて
1.1 アイテム登録ライブラリ
1.2 アイテム構造について
1.3 アイテムを追加する
1.4 注意事項
2 アイテム登録ライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第15章  フルカラーライブラリ

1 フルカラーライブラリについて
1.1 概要
2 動作環境
2.1 構成
2.2 注意事項
3 プログラミング
3.1 画面モードと仮想画面
3.2 画面の重ね合わせ
3.3 表示制御
3.4 ピクセルビット構成
3.5 TOWNSグラフィックBIOS(EGB)との関連
3.6 ビデオキャプチャ
3.7 Towns Shell上のアプリケーションでの使用
4 フルカラーライブラリ
4.1 関数一覧
4.2 各関数の解説
4.3 サンプルプログラム

第16章  タブレットライブラリ

1 タブレットライブラリについて
1.1 概要
1.2 注意事項
2 タブレットライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第17章  ビデオ出力ライブラリ

1 ビデオ出力ライブラリについて
1.1 概要
1.2 注意事項
2 ビデオ出力ライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第18章  アイコンライブラリ

1 アイコンライブラリについて
1.1 概要
1.2 注意事項
2 アイコンライブラリ
2.1 関数一覧
2.2 各関数の解説
2.3 サンプルプログラム

第19章  FMC関数ダイナミックリンクライブラリ

1 FMC関数ダイナミックリンクライブラリについて
1.1 概要
1.2 使用上の注意
1.3 リンク時の注意点
2 FMC関数ダイナミックリンクライブラリ

第20章  CD-ROM関数ダイナミックリンクライブラリ

1 CD-ROM関数ダイナミックリンクライブラリについて
1.1 概要
1.2 使用上の注意
1.3 リンク時の注意事項
2 CD-ROM関数ダイナミックリンクライブラリ

付録  Towns標準TIFFライブラリ

1 標準TIFFの方針
2 Towns標準TIFFフォーマット
2.1 ヘッダ
2.2 IFD(イメージファイルディレクトリ)
2.3 IFDのフィールドエントリの詳細
2.4 タグ
2.5 CLUTフォーマット
2.6 画像データ本体
3 タグの組み合わせ
4 TIFFデータの作成
5 TIFFローダ/セーバの条件
6 V1.1版からV2.1版の変更点
7 Towns標準TIFFヘッダ例

索引

*****************************************************************************
索引                                        拡張ライブラリI V2.1 リファレンス
*****************************************************************************

●関数名

.BPR_char2dot (単位系の変換(桁数/ANK文字→ドット数))
.BPR_dot2char (単位系の変換(ドット数→桁数))
.BPR_dot2inch (単位系の変換(ドット数→インチ))
.BPR_dot2line (単位系の変換(ドット数→行数))
.BPR_dot2mm (単位系の変換(ドット数→ミリメートル))
.BPR_End (印刷の終了)
.BPR_GetSize (作業領域サイズの取得)
.BPR_inch2dot (単位系の変換(インチ→ドット数))
.BPR_line2dot (単位系の変換(行数/ANK文字→ドット数))
.BPR_mm2dot (単位系の変換(ミリメートル→ドット数))
.BPR_Print (印刷の実行)
.BPR_Select (プリンタの選択)
.BPR_SetFunc (印刷中止判別関数の登録)
.BPR_Start (印刷の開始)
.EGB_getScrnInfo (画面モードに関する情報の取得)
.FGS_clearScreen (全画面の消去)
.FGS_close (終了)
.FGS_copy (ドットデータの複写)
.FGS_digitize (ディジタイズ開始･終了の設定)
.FGS_digitizeMode (ディジタイズ取り込みモードの設定)
.FGS_digitizeStart  (ディジタイズ転送開始位置の設定)
.FGS_digitizeZoom (ディジタイズ拡大率の設定)
.FGS_digitizeArea (ディジタイズ取り込み範囲の設定)
.FGS_digitizeQuality (ディジタイズ画質の調整)
.FGS_digitizeFlip (ディジタイズ反転の設定)
.FGS_displayPage (表示ページの指定)
.FGS_displayStart (表示開始位置の設定)
.FGS_fillRaster (ドットデータの書き込み3)
.FGS_getActivePage (使用可能画面の取得)
.FGS_getBlock (ドットデータの読み込み1)
.FGS_getDisplayPage (表示ページの読み取り)
.FGS_getDisplayStart (表示開始位置の読み取り)
.FGS_getInformation (ハードウェア情報の取得)
.FGS_getPack (パック状態の読み取り)
.FGS_getPalette (パレットの読み取り)
.FGS_getResolution (仮想画面の読み取り)
.FGS_getResolutionPage (仮想画面の読み取り)
.FGS_getWritePage (書き込みページの読み取り)
.FGS_init (初期化)
.FGS_init2 (初期化)
.FGS_openCheck (動作状態の読み取り)
.FGS_openCheck2 (動作状態の読み取り)
.FGS_palette (パレットレジスタの設定)
.FGS_partGetBlock (ドットデータの読み込み2)
.FGS_partPutBlock (ドットデータの書き込み2)
.FGS_putBlock (ドットデータの書き込み1)
.FGS_putRaster (ドットデータの書き込み4)
.FGS_resolution (仮想画面の設定)
.FGS_setPack (パック状態の設定)
.FGS_setys (重ね合わせ信号の設定)
.FGS_viewport (ビューポートの設定)
.FGS_writePage (書き込みページの指定)
.FTM_Close (拡張フォント管理終了)
.FTM_CloseCache (キャッシュ管理の終了)
.FTM_FreeDLL (呼び出しDLLの解放)
.FTM_GetFontImage (フォントイメージの取得)
.FTM_GetFontInfo (フォント情報の取得)
.FTM_GetFontInfo2 (フォント情報の取得2)
.FTM_GetFontNo (フォントNoの取得)
.FTM_GetFontOutline (アウトラインデータの取得)
.FTM_GetFontSize (フォントサイズの取得)
.FTM_GetFontTableSize (フォント一覧サイズの取得)
.FTM_GetFontTableSize2 (フォント一覧サイズの取得2)
.FTM_GetFontTable (フォント一覧の取得)
.FTM_GetFontTable2 (フォント一覧の取得2)
.FTM_GetLogicWorkSize (論理フォント用ワークサイズ取得)
.FTM_GetWorkSize (拡張フォント管理ワークサイズ取得)
.FTM_InitCache (キャッシュ領域の初期化)
.FTM_Open (拡張フォント管理初期化)
.FTM_OpenCache (キャッシュ管理の起動)
.FTM_ResetLogicFont (論理フォントの解除)
.FTM_SetAtr (修飾機能設定)
.FTM_SetAtrBorder (縁取り修飾機能の設定)
.FTM_SetAtrField (領域･クリップ修飾機能の設定)
.FTM_SetAtrOutline (輪郭修飾機能の設定)
.FTM_SetAtrPers (透視変換修飾機能の設定)
.FTM_SetAtrRotation (回転修飾機能の設定)
.FTM_SetAtrShadow (影付修飾機能の設定)
.FTM_SetAtrSlope (斜体修飾機能の設定)
.FTM_SetAtrSolid (立体文字修飾機能の設定)
.FTM_SetLogicFont (論理フォントの設定)
.GB_etStartPath (起動パス名の取得)
.ICON_CheckFirstIcnID (最初のアイコン番号の取得)
.ICON_CheckNextIcnID (次のアイコン番号の取得)
.ICON_close (アイコンライブラリの終了)
.ICON_Func (アイコンパターンの取得(非GUI))
.ICON_GetIcnEntry (アイコン登録数の取得)
.ICON_GUIFunc (アイコンパターンの取得(GUI併用))
.ICON_open (アイコンライブラリの初期化)
.ICON_SetIcnName (アイコンファイル名の設定)
.ICON_SetMinCode (最小アイコン番号の設定)
.IPU_BjEnd (印刷の終了)
.IPU_BjGetSize (作業領域サイズの取得)
.IPU_BjPrint (印刷の実行)
.IPU_BjSelect (プリンタの選択)
.IPU_BjStart (印刷の開始)
.IPU_char2dot (単位系の変換(桁数/ANK文字→ドット数))
.IPU_dot2char (単位系の変換(ドット数→桁数/ANK文字))
.IPU_dot2inch (単位系の変換(ドット数→インチ))
.IPU_dot2line (単位系の変換(ドット数→行数/ANK文字))
.IPU_dot2mm (単位系の変換(ドット数→ミリメートル))
.IPU_inch2dot (単位系の変換(インチ→ドット数) )
.IPU_line2dot (単位系の変換(行数/ANK文字→ドット数))
.IPU_mm2dot (単位系の変換(ミリメートル→ドット数))
.ITM_AddAplItem (アプリケーションアイテムの追加)
.ITM_AddGrpItem (グループアイテムの追加)
.ITM_AddSubDirItem (サブディレクトリアイテムの追加)
.ITM_ChgAplData (アプリケーションアイテムデータの変更)
.ITM_ChgGrpData (グループアイテムデータの変更)
.ITM_ChgSubDirData (サブディレクトリアイテムデータの変更)
.ITM_CreateItemFile (アイテムファイルの作成)
.ITM_DelItem (アイテムの削除)
.ITM_GetAplData (ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑの情報の取得)
.ITM_GetAplFPos (ｷｰﾜｰﾄﾞからｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得)
.ITM_GetBaseFPos (指定されたｱｲﾃﾑの親ｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得)
.ITM_GetGrpData (ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからｸﾞﾙｰﾌﾟｱｲﾃﾑの情報の取得)
.ITM_GetGrpFPos (ｷｰﾜｰﾄﾞからｸﾞﾙｰﾌﾟｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得)
.ITM_GetHeadData (ヘッダ情報の取得)
.ITM_GetHeadFPos (ヘッダ情報のファイルポジションの取得)
.ITM_GetItmType (アイテムの種別の取得)
.ITM_GetPhysclNextFPos (指定されたｱｲﾃﾑの次のｱｲﾃﾑﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得)
.ITM_GetStair (指定されたアイテムの階層レベルの取得)
.ITM_GetSubDirData (ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからｻﾌﾞﾃﾞｨﾚｸﾄﾘｱｲﾃﾑの情報の取得)
.ITM_GetSubDirFPos (ｷｰﾜｰﾄﾞからｻﾌﾞﾃﾞｨﾚｸﾄﾘｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得)
.ITM_GetV11Data (ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからV1.1ｱｲﾃﾑの情報の取得)
.ITM_GetV11FPos (ｷｰﾜｰﾄﾞからV1.1ｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得)
.KAN_disp (システム行の表示)
.KAN_finish (かな漢字変換ライブラリの終了)
.KAN_getMode (かな漢字変換の入力状態の読み取り)
.KAN_getWorkSize (ワークサイズの取得)
.KAN_inpchk (未確定文字列表示状態の読み取り)
.KAN_prepare (かな漢字変換ライブラリの初期化)
.KAN_setClrTbl (色情報の設定)
.KAN_setMode (かな漢字変換の入力状態の設定)
.KAN_setWorkAdd (ワークアドレスの設定)
.LPT_GetKey (定義情報の取り出し)
.LPT_Init (アクセス開始宣言)
.LPT_Select (プリンタの指定)
.pcl_check_error (詳細エラーコードの取得)
.pcl_check_exe (必要なメモリ量の獲得)
.pcl_detch_proc (実行ハンドルのプログラム環境の削除)
.pcl_exec_proc (すでにﾛｰﾄﾞされている実行ﾌｧｲﾙへ制御を渡す)
.pcl_exit (自プログラムの終了)
.pcl_get_dta (DTAアドレスの取得)
.pcl_init_loader (PCLライブラリの初期化)
.pcl_load_exec (実行ファイルの実行)
.pcl_load_file (実行ファイルのロード(ハンドルの取得))
.pcl_reset_error (詳細エラーコードのリセット)
.RSB_Break (ブレーク信号の送信)
.RSB_Chk (シリアルポートの検出)
.RSB_Close (回線クローズ)
.RSB_Clsxoff (XOFF受信のクリア)
.RSB_Ctrl (シリアルポートの制御)
.RSB_Dtr (拡張DTR信号の保持設定)
.RSB_End (Native RS-232Cの終了)
.RSB_Gettxlen (送信バッファ内の有効データ数の読み取り)
.RSB_Hdchk (FIFO機能の有無の検出)
.RSB_Init2 (Native RS-232Cの初期化(ポート指定))
.RSB_Initbuf (受信バッファの初期化)
.RSB_Init (Native RS-232Cの初期化)
.RSB_Open (回線オープン)
.RSB_Rdint (拡張割り込みの読み取り)
.RSB_Rdpara (通信パラメータの読み取り)
.RSB_Read (受信バッファ内の有効データ数の読み取り)
.RSB_Receive  (データの受信)
.RSB_Send (データの送信)
.RSB_Setint (拡張割り込みの設定)
.RSB_Setpara (通信パラメータの設定)
.RSB_Status (ステータス情報の読み取り)
.SCB_close (ポケットのクローズ)
.SCB_empty (ポケットデータの削除)
.SCB_isFormatAvailable (ポケットデータの有無の検査)
.SCB_open (ポケットのオープン)
.SCB_read (ポケットからのデータの読み出し)
.SCB_seek (ポケットデータポインタの移動)
.SCB_write (ポケットへのデータの書き込み)
.sdk_chain (連続実行プログラム番号の登録)
.sdk_delEntrance (ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ起動時のﾕｰｻﾞ割り込みﾙｰﾁﾝの抹消)
.sdk_delExit (ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ終了時のﾕｰｻﾞ割り込みﾙｰﾁﾝの抹消)
.sdk_getNumProg (サイドワークプログラム登録数の取得)
.sdk_getProgNameLen (サイドワークプログラム識別名の長さの取得)
.sdk_getProgName (サイドワークプログラム識別名の取得)
.sdk_invoke (ｱﾌﾟﾘｹｰｼｮﾝからのｻｲﾄﾞﾜｰｸﾌﾟﾛｸﾞﾗﾑ起動)
.sdk_isAtWork (起動環境の取得)
.sdk_loadScrn (画面データの復元)
.sdk_saveScrn (画面データの退避)
.sdk_setEntrance (ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ起動時のﾕｰｻﾞ割り込みﾙｰﾁﾝの登録)
.sdk_setExit (ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ終了時のﾕｰｻﾞ割り込みﾙｰﾁﾝの登録)
.sdk_setKBuf (キーボードバッファへの文字列転送)
.sdk_start (サイドワークプログラムのスタート)
.sdk_terminate (サイドワークプログラムの終了)
.SKB_disp (表示の制御)
.SKB_end (ソフトウェアキーボードの終了)
.SKB_getDisp (表示状態取得)
.SKB_getDispPos (表示位置の取得)
.SKB_getDragFunc (ドラッグルーチンの取得)
.SKB_getEGBwork (ソフトウェアキーボード用EGBワーク領域の取得)
.SKB_getRewriteFunc (窓のリライト関数の取得)
.SKB_getSave (画面退避領域の取得)
.SKB_getSize (画面退避領域サイズの取得)
.SKB_getSKBdrag (ドラッグ禁止状態の取得)
.SKB_getWindow (窓の表示開始位置の取得)
.SKB_setDispPos (表示位置の設定)
.SKB_setDragFunc (ドラッグルーチンの設定)
.SKB_setEGBwork (ソフトウェアキーボード用EGBワーク領域の設定)
.SKB_setRewriteFunc (窓のリライト関数の設定)
.SKB_setSave (画面退避領域の設定)
.SKB_setSKBdrag (ドラッグ禁止状態の設定)
.SKB_start (ソフトウェアキーボードの初期化)
.SMSG_chk (サウンドメッセージの存在確認)
.SMSG_close (サウンドメッセージの終了)
.SMSG_getInfo (サウンドメッセージデータの情報取得)
.SMSG_getMode (メッセージドライバ再生モードの取得)
.SMSG_open (サウンドメッセージの初期化)
.SMSG_play (サウンドメッセージの再生)
.SMSG_setMode (メッセージドライバ再生モードの設定)
.SMSG_stop (サウンドメッセージの強制停止)
.TAB_checkDriver (ドライバ接続状態の読み取り)
.TAB_connectStatus (タブレットドライバのポート接続状態の取得)
.TAB_getPress (筆圧の読み取り)
.TAB_getPulse (読み取りドット数/画素比の読み取り)
.TAB_getRdstart (読み取り開始位置の読み取り)
.TAB_rdpos (タブレット座標の読み取り)
.TAB_rdposDirect (タブレット座標の直接読み取り)
.TAB_setPress (筆圧の設定)
.TAB_setPulse (読み取りドット数/画素比の設定)
.TAB_setRdstart (読み取り開始位置の設定)
.TIFF_checkMode (TIFF形式の解析と必須情報の取り出し)
.TIFF_compress (TIFF圧縮開始)
.TIFF_decompress (TIFF伸長処理)
.TIFF_getHead (TIFFヘッダの確認)
.TIFF_getPal (TIFFパレット(CLUT)データの取り出し)
.TIFF_getTag (タグデータのチェック)
.TIFF_initCompress (TIFF圧縮前処理)
.TIFF_loadImage (TIFFデータの展開)
.TIFF_saveImage (TIFFデータの作成)
.TIFF_setCompressFunc (TIFF圧縮用関数の登録)
.TIFF_setDecompFunc (TIFF伸長用関数の登録)
.TIFF_setHead (TOWNS標準TIFFのヘッダ作成)
.TIFF_setLoadBuffer (ロードバッファの設定)
.TIFF_setLoadFunc (データバッファ操作関数の登録)
.TIFF_setReadFunc (データ読み込み関数の設定)
.TIFF_setSaveFunc (バッファ操作関数の登録)
.TIFF_tagValue (タグデータ値の取り出し)
.TIFF_termCompress (TIFF圧縮後処理)
.VFT_get_filecount (ベクトル文字パターンカード ファイル数取得)
.VFT_get_fileinfo (ベクトリ文字パターンカード ファイル情報取得)
.VFT_vecth (ベクトル文字フォント(高速版))
.VTBIOS_getStatus (ビデオ出力起動状態の取得)
.VTBIOS_videoOFF (ビデオ出力OFF)
.VTBIOS_videoON (ビデオ出力ON)
._XLD_callFree (メモリ開放関数の呼び出し)
._XLD_callMalloc (メモリ割り当て関数の呼び出し)
._XLD_clearError (実行時エラー情報の初期化)
._XLD_getError (実行時エラー情報の取得)
._XLD_getErrorFunc (ライブラリロード時エラーハンドラの取得)
._XLD_getLinkPath (ダイナミックリンクパスの取得)
._XLD_getLinkPath2 (ダイナミックリンクパスの取得2)
._XLD_getLibHeader (DLLヘッダ情報の取得)
._XLD_init (ダイナミックリンク機能の初期設定)
._XLD_isLinked (ライブラリのロード状態の検査)
._XLD_load (ライブラリのロード)
._XLD_lockLib (ライブラリのロック設定)
._XLD_setError (実行時エラー情報の設定)
._XLD_setErrorFunc (ライブラリロード時エラーハンドラの登録)
._XLD_setLinkPath (ダイナミックリンクパスの指定)
._XLD_setMemFunc (メモリ割り当て/開放関数の登録)
._XLD_unlink (ライブラリの開放)
._XLD_unlockLib (ライブラリのロック解除)

●機能名

DLLヘッダ情報の取得(_XLD_getLibHeader)
DTAアドレスの取得(pcl_get_dta)
FIFO機能の有無の検出(RSB_Hdchk)
Native RS-232Cの終了(RSB_End)
Native RS-232Cの初期化(RSB_Init)
Native RS-232Cの初期化(ポート指定)(RSB_Init2)
PCLライブラリの初期化(pcl_init_loader)
TIFF圧縮後処理(TIFF_termCompress)
TIFF圧縮開始(TIFF_compress)
TIFF圧縮前処理(TIFF_initCompress)
TIFF圧縮用関数の登録(TIFF_setCompressFunc)
TIFF形式の解析と必須情報の取り出し(TIFF_checkMode)
TIFF伸長処理(TIFF_decompress)
TIFF伸長用関数の登録(TIFF_setDecompFunc)
TIFFデータの作成(TIFF_saveImage)
TIFFデータの展開(TIFF_loadImage)
TIFFパレット(CLUT)データの取り出し(TIFF_getPal)
TIFFヘッダの確認(TIFF_getHead)
TOWNS標準TIFFのヘッダ作成(TIFF_setHead)
XOFF受信のクリア(RSB_Clsxoff)
アイコン登録数の取得(ICON_GetIcnEntry)
アイコンパターンの取得(GUI併用)(ICON_GUIFunc)
アイコンパターンの取得(非GUI)(ICON_Func)
アイコンファイル名の設定(ICON_SetIcnName)
アイコンライブラリの終了(ICON_close)
アイコンライブラリの初期化(ICON_open)
アイテムの削除(ITM_DelItem)
アイテムの種別の取得(ITM_GetItmType)
アイテムファイルの作成(ITM_CreateItemFile)
アウトラインデータの取得(FTM_GetFontOutline)
アクセス開始宣言(LPT_Init)
アプリケーションアイテムデータの変更(ITM_ChgAplData)
アプリケーションアイテムの追加(ITM_AddAplitem)
ｱﾌﾟﾘｹｰｼｮﾝからのｻｲﾄﾞﾜｰｸﾌﾟﾛｸﾞﾗﾑ起動(sdk_invoke)
色情報の設定(KAN_setClrTbl)
印刷中止判別関数の登録(BPR_SetFunc)
印刷の開始(BPR_Start)
印刷の開始(IPU_BjStart)
印刷の実行(BPR_Print)
印刷の実行(IPU_BjPrint)
印刷の終了(BPR_End)
印刷の終了(IPU_BjEnd)
回線オープン(RSB_Open)
回線クローズ(RSB_Close)
回転修飾機能の設定(FTM_SetAtrRotation)
書き込みページの指定(FGS_writePage)
書き込みページの読み取り(FGS_getWritePage)
拡張DTR信号の保持設定(RSB_Dtr)
拡張フォント管理終了(FTM_Close)
拡張フォント管理初期化(FTM_Open)
拡張フォント管理ワークサイズ取得(FTM_GetWorkSize)
拡張割り込みの設定(RSB_Setint)
拡張割り込みの読み取り(RSB_Rdint)
影付修飾機能の設定(FTM_SetAtrShadow)
重ね合わせ信号の設定(FGS_setys)
仮想画面の設定(FGS_resolution)
仮想画面の読み取り(FGS_getResolution)
仮想画面の読み取り(FGS_getResolutionPage)
かな漢字変換の入力状態の設定(KAN_setMode)
かな漢字変換の入力状態の読み取り(KAN_getMode)
かな漢字変換ライブラリの終了(KAN_finish)
かな漢字変換ライブラリの初期化(KAN_prepare)
画面退避領域サイズの取得(SKB_getSize)
画面退避領域の取得(SKB_getSave)
画面退避領域の設定(SKB_setSave)
画面データの退避(sdk_saveScrn)
画面データの復元(sdk_loadScrn)
画面モードに関する情報の取得(EGB_getScrnInfo)
キーボードバッファへの文字列転送(sdk_setKBuf)
ｷｰﾜｰﾄﾞからV1.1ｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得(ITM_GetV11FPos)
ｷｰﾜｰﾄﾞからｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得(ITM_GetAplFPos)
ｷｰﾜｰﾄﾞからｸﾞﾙｰﾌﾟｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得(ITM_GetGrpFPos)
ｷｰﾜｰﾄﾞからｻﾌﾞﾃﾞｨﾚｸﾄﾘｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得(ITM_GetSubDirFPos)
起動環境の取得(sdk_isAtWork)
起動パス名の取得(GB_getStartPath)
キャッシュ管理の起動(FTM_OpenCache)
キャッシュ管理の終了(FTM_CloseCache)
キャッシュ領域の初期化(FTM_InitCache)
グループアイテムデータの変更(ITM_ChgGrpData)
グループアイテムの追加(ITM_AddGrpItem)
最小アイコン番号の設定(ICON_SetMinCode)
最初のアイコン番号の取得(ICON_CheckFirstIcnID)
サイドワークプログラム識別名の取得(sdk_getProgName)
サイドワークプログラム識別名の長さの取得(sdk_getProgNameLen)
サイドワークプログラム登録数の取得(sdk_getNumProg)
サイドワークプログラムの終了(sdk_terminate)
サイドワークプログラムのスタート(sdk_start)
ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ起動時のﾕｰｻﾞ割り込みﾙｰﾁﾝの登録(sdk_setEntrance)
ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ起動時のﾕｰｻﾞ割り込みﾙｰﾁﾝの抹消(sdk_delEntrance)
ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ終了時のﾕｰｻﾞ割り込みﾙｰﾁﾝの登録(sdk_setExit)
ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ終了時のﾕｰｻﾞ割り込みﾙｰﾁﾝの抹消(sdk_delExit)
サウンドメッセージデータの情報取得(SMSG_getInfo)
サウンドメッセージの強制停止(SMSG_stop)
サウンドメッセージの再生(SMSG_play)
サウンドメッセージの終了(SMSG_close)
サウンドメッセージの初期化(SMSG_open)
サウンドメッセージの存在確認(SMSG_chk)
作業領域サイズの取得(BPR_GetSize)
作業領域サイズの取得(IPU_BjGetSize)
サブディレクトリアイテムデータの変更(ITM_ChgSubDirData)
サブディレクトリアイテムの追加(ITM_AddSubDirItem)
指定されたｱｲﾃﾑの親ｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得(ITM_GetBaseFPos)
指定されたアイテムの階層レベルの取得(ITM_GetStair)
指定されたｱｲﾃﾑの次のｱｲﾃﾑﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得(ITM_GetPhysclNextFPos)
システム行の表示(KAN_disp)
実行ハンドルのプログラム環境の削除(pcl_detch_proc)
実行ファイルのロード(ハンドルの取得)(pcl_load_file)
実行ファイルの実行(pcl_load_exec)
実行時エラー情報の取得(_XLD_getError)
実行時エラー情報の初期化(_XLD_clearError)
実行時エラー情報の設定(_XLD_setError)
自プログラムの終了(pcl_exit)
斜体修飾機能の設定(FTM_SetAtrSlope)
修飾機能設定(FTM_SetAtr)
終了(FGS_close)
受信バッファ内の有効データ数の読み取り(RSB_Read)
受信バッファの初期化(RSB_Initbuf)
使用可能画面の取得(FGS_getActivePage)
詳細エラーコードの取得(pcl_check_error)
詳細エラーコードのリセット(pcl_reset_error)
初期化(FGS_init)
初期化(FGS_init2)
シリアルポートの検出(RSB_Chk)
シリアルポートの制御(RSB_Ctrl)
ステータス情報の読み取り(RSB_Status)
すでにﾛｰﾄﾞされている実行ﾌｧｲﾙへ制御を渡す(pcl_exec_proc)
全画面の消去(FGS_clearScreen)
送信バッファ内の有効データ数の読み取り(RSB_Gettxlen)
ソフトウェアキーボードの終了(SKB_end)
ソフトウェアキーボードの初期化(SKB_start)
ソフトウェアキーボード用EGBワーク領域の取得(SKB_getEGBwork)
ソフトウェアキーボード用EGBワーク領域の設定(SKB_setEGBwork)
ダイナミックリンク機能の初期設定(_XLD_init)
ダイナミックリンクパスの指定(_XLD_getLinkPath)
ダイナミックリンクパスの取得(_XLD_getLinkPath)
ダイナミックリンクパスの取得2(_XLD_setLinkPath2)
タグデータ値の取り出し(TIFF_tagValue)
タグデータのチェック(TIFF_getTag)
タブレット座標の直接読み取り(TAB_rdposDirect)
タブレット座標の読み取り(TAB_rdpos)
タブレットドライバのポート接続状態の取得(TAB_connectStatus)
単位系の変換(インチ→ドット数)(BPR_inch2dot)
単位系の変換(インチ→ドット数)(IPU_inch2dot)
単位系の変換(行数/ANK文字→ドット数)(BPR_line2dot)
単位系の変換(行数/ANK文字→ドット数)(IPU_line2dot)
単位系の変換(桁数/ANK文字→ドット数)(BPR_char2dot)
単位系の変換(桁数/ANK文字→ドット数)(IPU_char2dot)
単位系の変換(ドット数→インチ)(BPR_dot2inch)
単位系の変換(ドット数→インチ)(IPU_dot2inch)
単位系の変換(ドット数→行数)(BPR_dot2line)
単位系の変換(ドット数→行数/ANK文字)(IPU_dot2line)
単位系の変換(ドット数→桁数)(BPR_dot2char)
単位系の変換(ドット数→桁数/ANK文字)(IPU_dot2char)
単位系の変換(ドット数→ミリメートル)(BPR_dot2mm)
単位系の変換(ドット数→ミリメートル)(IPU_dot2mm)
単位系の変換(ミリメートル→ドット数)(BPR_mm2dot)
単位系の変換(ミリメートル→ドット数)(IPU_mm2dot)
通信パラメータの設定(RSB_Setpara)
通信パラメータの読み取り(RSB_Rdpara)
次のアイコン番号の取得(ICON_CheckNextIcnID)
定義情報の取り出し(LPT_GetKey)
ディジタイズ開始･終了の設定(FGS_digitize)
ディジタイズ拡大率の設定(FGS_digitizeZoom)
ディジタイズ画質の調整(FGS_digitizeQuality)
ディジタイズ転送開始位置の設定(FGS_digitizeStart)
ディジタイズ取り込みモードの設定(FGS_digitizeMode)
ディジタイズ取り込み範囲の設定(FGS_digitizeArea)
ディジタイズ反転の設定(FGS_digitizeFlip)
データの受信(RSB_Receive)
データの送信(RSB_Send)
データバッファ操作関数の登録(TIFF_setLoadFunc)
データ読み込み関数の登録(TIFF_setReadFunc)
動作状態の読み取り(FGS_openCheck)
動作状態の読み取り(FGS_openCheck2)
透視変換修飾機能の設定(FTM_SetAtrPers)
ドットデータの書き込み1(FGS_putBlock)
ドットデータの書き込み2(FGS_partPutBlock)
ドットデータの書き込み3(FGS_fillRaster)
ドットデータの書き込み4(FGS_putRaster)
ドットデータの読み込み1(FGS_getBlock)
ドットデータの読み込み2(FGS_partGetBlock)
ドットデータの複写(FGS_copy)
ドライバ接続状態の読み取り(TAB_checkDriver)
ドラッグルーチンの取得(SKB_getDragFunc)
ドラッグルーチンの設定(SKB_setDragFunc)
ドラッグ禁止状態の取得(SKB_getSKBdrag)
ドラッグ禁止状態の設定(SKB_setSKBdrag)
ハードウェア情報の取得(FGS_getInformation)
パック状態の設定(FGS_setPack)
パック状態の読み取り(FGS_getPack)
バッファ操作関数の登録(TIFF_setSaveFunc)
パレットの読み取り(FGS_getPalette)
パレットレジスタの設定(FGS_palette)
筆圧の設定(TAB_setPress)
筆圧の読み取り(TAB_getPress)
必要なメモリ量の獲得(pcl_check_exe)
ビデオ出力OFF(VTBIOS_videoOFF)
ビデオ出力ON(VTBIOS_ideoON)
ビデオ出力起動状態の取得(VTBIOS_getStatus)
ビューポートの設定(FGS_viewport)
表示位置の設定(SKB_setDispPos)
表示位置の取得(SKB_getDispPos)
表示開始位置の設定(FGS_displayStart)
表示開始位置の読み取り(FGS_getDisplayStart)
表示状態取得(SKB_getDisp)
表示の制御(SKB_disp)
表示ページの指定(FGS_displayPage)
表示ページの読み取り(FGS_getDisplayPage)
ﾌｧｲﾙﾎﾞｼﾞｼｮﾝからV1.1ｱｲﾃﾑの情報の取得(ITM_GetV11Data)
ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑの情報の取得(ITM_GetAplData)
ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからｸﾞﾙｰﾌﾟｱｲﾃﾑの情報の取得(ITM_GetGrpData)
ﾌｧｲﾙﾎﾞｼﾞｼｮﾝからｻﾌﾞﾃﾞｨﾚｸﾄﾘｱｲﾃﾑの情報の取得(ITM_GetSubDirData)
フォント一覧サイズの取得(FTM_GetFontTableSize)
フォント一覧サイズの取得2(FTM_GetFontTableSize2)
フォント一覧の取得(FTM_GetFontTable)
フォント一覧の取得2(FTM_GetFontTable2)
フォントイメージの取得(FTM_GetFontImage)
フォントサイズの取得(FTM_GetFontSize)
フォント情報の取得(FTM_GetFontInfo)
フォント情報の取得2(FTM_GetFontInfo2)
フォントNoの取得(FTM_GetFontNo)
縁取り修飾機能の設定(FTM_SetAtrBorder)
プリンタの指定(LPT_Select)
プリンタの選択(BPR_Select)
プリンタの選択(IPU_BjSelect)
ブレーク信号の送信(RSB_Break)
ベクトル文字パターンカード ファイル情報取得(VFT_get_fileinfo)
ベクトル文字パターンカード ファイル数取得(VFT_get_filecount)
ベクトル文字フォント(高速版)(VFT_vecth)
ヘッダ情報の取得(ITM_GetHeadData)
ヘッダ情報のファイルポジションの取得(ITM_GetHeadFPos)
ポケットからのデータの読み出し(SCB_read)
ポケットデータの削除(SCB_empty)
ポケットデータの有無の検査(SCB_isFormatAvailable)
ポケットデータポインタの移動(SCB_seek)
ポケットのオープン(SCB_open)
ポケットのクローズ(SCB_close)
ポケットへのデータの書き込み(SCB_write)
窓の表示開始位置の取得(SKB_getWindow)
窓のリライト関数の取得(SKB_getRewriteFunc)
窓のリライト関数の設定(SKB_setRewriteFunc)
未確定文字列表示状態の読み取り(KAN_inpchk)
メッセージドライバ再生モードの取得(SMSG_getMode)
メッセージドライバ再生モードの設定(SMSG_setMode)
メモリ開放関数の呼び出し(_XLD_callFree)
メモリ割り当て/開放関数の登録(_XLD_setMemFunc)
メモリ割り当て関数の呼び出し(_XLD_callMalloc)
呼び出しDLLの解放(FTM_FreeDLL)
読み取り開始位置の設定(TAB_setRdstart)
読み取り開始位置の読み取り(TAB_getRdstart)
読み取りドット数/画素比の設定(TAB_setPulse)
読み取りドット数/画素比の読み取り(TAB_getPulse)
ライブラリの開放(_XLD_unlink)
ライブラリのロード(_XLD_load)
ライブラリのロード状態の検査(_XLD_isLinked)
ライブラリのロック解除(_XLD_unlockLib)
ライブラリのロック設定(_XLD_lockLib)
ライブラリロード時エラーハンドラの取得(_XLD_getErrorFunc)
ライブラリロード時エラーハンドラの登録(_XLD_getErrorFunc)
立体文字修飾機能の設定(FTM_SetAtrSolid)
領域･クリップ修飾機能の設定(FTM_SetAtrField)
輪郭修飾機能の設定(FTM_SetAtrOutline)
連続実行プログラム番号の登録(sdk_chain)
ロードバッファの設定(TIFF_setLoadBuffer)
ワークアドレスの設定(KAN_setWorkAdd)
ワークサイズの取得(KAN_getWorkSize)
論理フォントの解除(FTM_ResetLogicFont)
論理フォントの設定(FTM_SetLogicFont)
論理フォント用ワークサイズ取得(FTM_GetLogicWorkSize)

*****************************************************************************
第1章  拡張ライブラリI V2.1
*****************************************************************************

1 拡張ライブラリI V2.1について

1.1 概要

  ｢FM TOWNS 拡張ライブラリI V2.1｣は、FM TOWNS上で動作するアプリケーションの
開発を支援するために開発されたライブラリで、下図のライブラリから構成されてい
ます。｢High C(R) Compiler V1.7｣とともにご使用いただくことにより、Townsシステ
ムソフトウェア V2.1の機能を使用したアプリケーションを容易に開発することができ
ます。

拡張ライブラリ I V2.1

        ├─かな漢字変換ライブラリ
        ├─ソフトウェアキーボードライブラリ
        ├─サイドワークライブラリ
        ├─オーバレイライブラリ
        ├─TIFFライブラリ
        ├─ベクトルフォントライブラリ
        ├─Native RS-232Cライブラリ
        ├─ダイナミックリンクサポートライブラリ
        ├─ポケットライブラリ
        ├─サウンドメッセージライブラリ
        ├─プリンタドライバライブラリ
        ├─フルカラーライブラリ
        ├─タブレットライブラリ
        ├─ビデオ出力ライブラリ
        ├─アイコンライブラリ
        ├─FMC関数ダイナミックリンクライブラリ
        └─CD-ROM関数ダイナミックリンクライブラリ

1.2 開発環境

  FM TOWNSで｢FM TOWNS 拡張ライブラリ I V2.1｣を使用してアプリケーションプログ
ラムを開発するには、次のハードウェアとソフトウェアが必要です。

 (1)ハードウェア環境

    必須ハードウェア

     FM TOWNS本体
     ･RAM 2MB以上
     ･マウス
     ･キーボード
     ･ディスプレイ
     ･ハードディスク(20MB以上、必須)

    対応オプション
┌────────────────┬──────┬──────────┐
│          製  品  名            │  型    番  │   対応ライブラリ   │
├────────────────┼──────┼──────────┤
│ビデオカード                    │FMT-411     │ビデオ出力ライブラリ│
├────────────────┼──────┼──────────┤
│ビデオカードII                  │FMT-412/412A│ビデオ出力ライブラリ│
├────────────────┼──────┼──────────┤
│ビデオカードIII                 │FMT-418     │ビデオ出力ライブラリ│
├────────────────┼──────┼──────────┤
│ビデオプロセッサカード*1        │FMT-414     │ビデオ出力ライブラリ│
├────────────────┼──────┼──────────┤
│ビデオプロセッサカードII*1      │FMT-415     │ビデオ出力ライブラリ│
├────────────────┼──────┼──────────┤
│TOWNSタブレット                 │FMT-TB111   │タブレットライブラリ│
├────────────────┼──────┼──────────┤
│フルカラーカード                │FMT-461     │フルカラーライブラリ│
├────────────────┼──────┼──────────┤
│フルカラービデオキャプチャカード│FMT-462     │フルカラーライブラリ│
└────────────────┴──────┴──────────┘
  *1:ビデオカード互換モードのみ対応

 (2)ソフトウェア環境

    必須ソフトウェア
     ･Towns システムソフトウェア V2.1 L31 以上
     ･High C(R) Compiler V1.7 L12以上

    対応オプション
     ･ベクトル文字パターン(明朝体･ゴシック体)
     ･ベクトル文字パターンII*1

    *1:プロポーショナル文字は、拡張フォント管理ライブラリでのみ使用可能です。

1.3 ファイル構成

  ｢FM TOWNS 拡張ライブラリ I V2.1｣は、以下のファイルより構成されています。

    \ASM      オーバレイライブラリ用DTA定義体ファイル*1
    \INCLUDE  ヘッダファイル
    \LIB      ライブラリファイル
    \EXE      ダイナミックリンクリソース変換ツール
    \SDL      リソースライブラリ

\SMP─┬\KKSMP      かな漢字変換ライブラリサンプルプログラム
      ├\SKBSMP     ソフトウェアキーボードライブラリサンプルプログラム
      ├\SDKSMP     サイドワークライブラリサンプルプログラム
      ├\OVLSMP     オーバレイライブラリサンプルプログラム
      ├\TIFSMP     TIFFライブラリサンプルプログラム
      ├\VFTSMP     ベクトルフォントライブラリサンプルプログラム
      ├\NRSSMP     Native RS-232Cライブラリサンプルプログラム
      ├\DLLSMP     ダイナミックリンクサポートライブラリサンプルプログラム
      ├\SCBSMP     ポケットライブラリサンプルプログラム
      ├\SMGSMP     サウンドメッセージライブラリサンプルプログラム
      ├\PRNSMP     プリンタドライバライブラリサンプルプログラム
      ├\FTMSMP     拡張フォント管理ライブラリサンプルプログラム
      ├\ITMSMP     アイテム登録ライブラリサンプルプログラム
      ├\FGSSMP     フルカラーライブラリサンプルプログラム
      ├\TABSMP     タブレットライブラリサンプルプログラム
      ├\VTBSMP     ビデオ出力ライブラリサンプルプログラム
      └\ICNSMP     アイコンライブラリサンプルプログラム

  FMC関数ダイナミックリンクライブラリおよびCD-ROM関数ダイナミックリンクライブ
ラリのサンプルについては｢Cライブラリ V2.1 リファンス｣をご覧ください。

  *1 オーバレイライブラリ用DTA定義体は、『386|ASM』で記述されています。
     この定義体を変更して使用する場合には｢386|ASM TOOL KIT V2.2(L11以降)｣
     が必要となります。

1.4 注意事項

  ｢FM TOWNS 拡張ライブラリI V2.1｣を使用して作成したアプリケーションプログラム
を動作させる場合、以下の事項に注意してください。

 1)アプリケーションプログラムの動作モードについて
   サイドワークライブラリを使用したアプリケーションプログラムは、コマンドモー
   ドでは正常に動作しません。必ず"\SIDEWORK\SIDEWORK.SYS"への登録を行い、プル
   ダウンから起動してください。
   添付の各サンプルプログラムが動作可能なモードは、下記に示すとおりです。

┌─────────────┬──────────────────────┐
│        サンプル          │        サンプルプログラムの動作モード      │
├─────────────┼──────────────────────┤
│  かな漢字変換ﾗｲﾌﾞﾗﾘ      │TownsMENUおよびコマンドモード               │
│  ｿﾌﾄｳｪｱｷｰﾎﾞｰﾄﾞﾗｲﾌﾞﾗﾘ     │TownsMENUおよびコマンドモード               │
│  ｻｲﾄﾞﾜｰｸﾗｲﾌﾞﾗﾘ           │\SIDEWORK\SIDEWORK.SYSに登録し､ﾌﾟﾙﾀﾞｳﾝで起動│
│  ｵｰﾊﾞﾚｲﾗｲﾌﾞﾗﾘ            │コマンドモード                              │
│  TIFFﾗｲﾌﾞﾗﾘ              │コマンドモード(パラメータの指定が必須)      │
│  ﾍﾞｸﾄﾙ展開ﾗｲﾌﾞﾗﾘ         │TownsMENUおよびコマンドモード               │
│                          │(ﾍﾞｸﾄﾙ文字ﾊﾟﾀｰﾝまたはﾍﾞｸﾄﾙ文字ﾊﾟﾀｰﾝII必須)  │
│  Native RS-232Cﾗｲﾌﾞﾗﾘ    │コマンドモード(端末が必須)                  │
│  ﾀﾞｲﾅﾐｯｸﾘﾝｸｻﾎﾟｰﾄﾗｲﾌﾞﾗﾘ   │TownsMENUおよびコマンドモード               │
│  ﾎﾟｹｯﾄﾗｲﾌﾞﾗﾘ             │TownsMENU                                   │
│  ｻｳﾝﾄﾞﾒｯｾｰｼﾞﾗｲﾌﾞﾗﾘ       │TownsMENUおよびコマンドモード(ﾊﾟﾗﾒｰﾀの指定  │
│                          │                                     が必須)│
│  ﾌﾟﾘﾝﾀﾄﾞﾗｲﾊﾞﾗｲﾌﾞﾗﾘ       │コマンドモード(プリンタ必須)                │
│  拡張ﾌｫﾝﾄ管理ﾗｲﾌﾞﾗﾘ      │TownsMENU                                   │
│  ｱｲﾃﾑ登録ﾗｲﾌﾞﾗﾘ          │コマンドモード                              │
│  ﾌﾙｶﾗｰﾗｲﾌﾞﾗﾘ             │コマンドモード(ﾌﾙｶﾗｰﾋﾞﾃﾞｵｷｬﾌﾟﾁｬｶｰﾄﾞ必須)    │
│  ﾀﾌﾞﾚｯﾄﾗｲﾌﾞﾗﾘ            │TownsMENU(タブレット必須)                   │
│  ﾋﾞﾃﾞｵ出力ﾗｲﾌﾞﾗﾘ         │TownsMENU(ビデオカード必須)                 │
│  ｱｲｺﾝﾗｲﾌﾞﾗﾘ              │TownsMENU                                   │
└─────────────┴──────────────────────┘

 2)サンプルプログラムの作成環境について
   フロッピィディスク内のディレクトリ"\SMP"に格納されているサンプルプログラム
   のコンパイル･リンク環境(MAKEファイル)では、ネイティブ版のコンパイラ･リンカ
   (hcd386p.expおよび386linkp.exp)を使用しています。
   リアル版のコンパイラ･リンカ(hcd386.exeおよび386link.exe)をご利用の場合は、
   コメントとして記述されていますので、変更してご利用ください。

2 開発環境の構築

2.1 インストールによる開発環境の構築

  TownsMENUを使用して、ライブラリ、ヘッダファイル、リソースライブラリ、サンプ
ルプログラム、ダイナミックリンクリソース変換ツール、およびオーバレイライブラ
リ用DTA定義体用に合計6個のディレクトリを作成し、各ファイルをコピーしてくださ
い。提供ディスク内の各ディレクトリをHigh C(R) Compiler のインストールされてい
るディレクトリ(デフォルトは"\HC386")のサブディレクトリとすることをお勧めしま
す。

2.2 High C(R)Compilerの環境設定

  アプリケーション開発を行う前に、｢FM TOWNS 拡張ライブラリI V2.1｣で提供される
環境を下記の要領で｢High C(R) Compiler｣の環境に追加し、統合された開発環境を構
築してください。

 1)ヘッダファイルのサーチ
   ｢FM TOWNS 拡張ライブラリ I V2.1｣で提供されるヘッダファイルをHigh C(R) Comp
   ilerのヘッダファイルとして有効にするために、ヘッダファイルのサーチの設定を
   行ってください。設定方法には、以下に示すものがあります。

     −コンパイラプラグマ(ipathプラグマ)
     −コンパイラスイッチ(-ipathスイッチ)
     −config.exe(コンパイラのデフォルト値変更)プログラムによる指定
     −環境変数の定義(ipath変数)

 2)漢字サポート
   config.exe(コンパイラのデフォルト値変更)プログラムにより漢字サポートの指定
   を行ってください。

3 機能/ヘッダ･ライブラリ対応一覧

  図EXL121R-001

*1 リンクする順序に規則があります。
    詳しくは｢第5章  オーバレイライブラリ 1.4 注意事項｣を参照してください。

*2 ダイナミックリンク対応のライブラリです。ライブラリ本体をリンクする必要はあ
   りません。リソースライブラリをリンクしてください。
   なお、リンクに際しては各ライブラリの注意事項に従ってください。
   また、ライブラリ本体はTownsシステムソフトウェアV2.1の"\DLL"内に格納されて
   います。アプリケーション運用の際には、システム起動ドライブの"\DLL"に格納す
   るか、アプリケーション内の_XLD_setLinkPath関数で設定されたディレクトリ内に
   格納してください。
    (_XLD_setLinkPath関数はダイナミックリンクサポートライブラリの関数です)

*3 リソースライブラリはリソースオブジェクト(rco形式)をライブラリ化したもので
   す。(ただし、t_os.sdlはt_os.libに含まれているライブラリのうち、ダイナミッ
   クリンク対応のライブラリのライブラリ部分のみをリソースライブラリとおきかえ
   たものです。ダイナミックリンクされていないライブラリについては、ライブラリ
   本体がそのまま含まれています。)
   ダイナミックリンク機能に対応したライブラリを使用する場合には、リンク時に下
   記のスイッチを追加してください。

     -lib XXXXXXXX.SDL   (リソースライブラリ名)

   さらに、これまでダイナミックリンクに対応していないライブラリを使用していた
   場合には、リンク時のスイッチから下記のスイッチを削除してください。

     -lib XXXXXXXX       (ライブラリ名)

   拡張フォント管理ライブラリのリンク方法については、｢第13章  拡張ベクトルフ
   ォントライブラリ 1.5 アプリケーション開発時の注意事項｣をご参照ください。
   また、ダイナミックリンク機能に対応したライブラリを使用するためには、ダイナ
   ミックリンクサポートライブラリを使用し、ダイナミックリンク機能の初期化等の
   処理を行っておく必要があります。詳しくは｢第9章  ダイナミックリンクサポート
   ライブラリ 2.ダイナミックリンクを利用した開発｣をご覧ください。

*4 ダイナミックリンクサポートライブラリの関数を使用するダイナミックリンクライ
   ブラリ作成時にリンクしてください。

*5 FMC関数ダイナミックリンクライブラリ、CD-ROM関数ダイナミックリンクライブラ
   リのヘッダ、およびダイナミックリンクに対応していない通常のライブラリは、
   ｢High C(R) Compiler V1.7｣で提供されています。

*6 使用方法については、拡張ライブラリIIのGUIライブラリ V2.1 リファレンスをご
   覧ください。

*****************************************************************************
第2章  かな漢字変換ライブラリ
*****************************************************************************

1 かな漢字変換ライブラリについて

1.1 概要

  本ライブラリは、Townsシステムソフトウェア V2.1上で動作するかな漢字変換をサ
ポートするためのライブラリです。本ライブラリをアプリケーションに組み込むこと
により、簡単にかな漢字混じりの文字データを取得することが可能となります。

1.2 基本動作フロー

  図EXL121R-002

- 注意 -
同一プログラム中でかな漢字変換の禁止(ANKのみの入力)や実行を繰り返す場合は、
1〜4を繰り返すのではなく、1、4をアプリの先頭と終了時点で発行し、2〜3を繰り返
してください。ただし、GUIを使用する場合は、使用方法が異なりますので拡張ライブ
ラリII｢GUIライブラリ V2.1 ユーザーズガイド｣のマニュアルを参照してください。

  図EXL121R-003

  未確定文字列が表示中の場合は、キー入力ルーチンから抜け出さないような処理に
してください。
  かな漢字変換部分とユーザプログラムとのタイミングは以下のようになります。

  エンドユーザ          かな漢字        システム        アプリケーション内部
┌───────┐      ┌────┐
│ｷｰﾎﾞｰﾄﾞを押す │──→│未確定  │
└───────┘ 1    │        │
      │                │バッファ│
      │                └────┘              ┌───KYB_read関数
      │                                     2    │
      │                            ←──────┘
      │                未確定表示  ──────────→入力文字なし
      │                                ┌────────KAN_inpchk関数
      │                                │   3
      │ 4                              └───────→未確定文字列
      │                                                  表示中となる
      │              ┌────┐
      └──────→│確定    │
                      │        │
                      │バッファ│           5    ┌───KYB_read関数
                      └────┘  ←──────┘
                                    ──────────→入力文字あり
                                        ┌────────KAN_inpchk関数
                                        │   6
                                        └───────→未確定非表示
                                                          ┌────┐
                                                         7│文字表示│
                                                          └────┘

 1)キーボードを押すと、かな漢字の未確定バッファに文字データが溜まります。
 2)その状態で、KYB_read関数が発行されると、かな漢字ライブラリが未確定文字を
   画面上に表示します。
 3)KAN_inpchk関数を実行すると、未確定文字列表示中となります。
   このときには画面の書き換えなどをアプリケーションが行ってはいけません。
   (すなわち、キー入力ループを抜けてはいけません)
 4)キーボードを押したことにより文字が確定されると、かな漢字は未確定文字列を
   消去し、確定バッファに文字データを入れます。
 5)その状態でKYB_read関数を実行すると｢入力文字あり｣となり、先の確定文字データ
   がアプリケーションに渡されます。
 6)KAN_inpchk関数を実行すると、未確定文字列非表示中となります。
 7)ここで、初めてアプリケーションが画面上に文字を表示することができます。

- 注意1 -
本ライブラリ動作時には、本ライブラリの他に、High CのCライブラリ中のグラフィッ
クライブラリ、FMC関数ライブラリが必須です。また、マウスを使用する場合はさらに
、マウスライブラリが、ソフトウェアキーボードを使用する場合には、ソフトウェア
キーボードライブラリが必要です。

- 注意2 -
キーデータ取得は、FMC関数ライブラリの文字の読み込み : KYB_read関数を利用しま
す。(詳細は、High C(R) Compiler V1.7添付の｢CライブラリV2.1 リファレンス｣のFMC
関数ライブラリの章を参照してください)

- 注意3 -
本ライブラリに渡すEGBのワークアドレスは、初期化したワークアドレスでなければな
りません。また、画面モードが変更になった場合は、一度本ライブラリを終了し、
再び本ライブラリの初期化をしてください。

- 例 -
16色モード、マウスを使用するアプリケーションの初期化の場合

#include <egb.h>
#include <mos.h>
#include <kkstr2.h> 

  char  gwork[EgbWorkSize]; 
  char  mwork[MosWorkSize]; 

 int initSystem() 
{
    KANJ  prm;
    extern  void setstring();   /*  文字列取得ルーチン         */ 
    extern  void setpos();      /*  表示開始位置設定ルーチン   */ 
        : 
        : 
    /* EGB, MOS の初期化  */
    EGB_init( gwork, EgbWorkSize ); 
    EGB_resolutin( gwork, 0, 3 ); 
    EGB_resolutin( gwork, 1, 3 ); 
    MOS_start( mwork, MosWorkSize );
    MOS_resolutin( 0, 3 );

    prm.scrn    = KAN_SCRN16;     /*  16色モード                   */ 
    prm.egb     = gwork;          /*  EGB のワークアドレスの設定   */ 
    prm.maxX    = 639;            /*  画面の最大Ｘ座標             */ 
    prm.maxY    = 479;            /*  画面の最大Ｙ座標             */ 
    prm.wPage   = 0;              /*  書き込みページ               */ 
    prm.mosAp   = KAN_MOSON;      /*  マウスを利用する             */ 
    prm.gets    = GETSTR;         /*  文字取得ルーチン             */ 
    prm.setPos  = GETPOS;         /*  表示開始位置指定ルーチン     */ 

    KAN_prepare( &prm);           /*  かな漢ライブラリの初期化     */ 
         :
         :
}

- 例 -
ankと漢字入力を切り換えて利用する場合

#include <fmcfrb.h>          /*  FMC関数ライブラリのヘッダ  */
#include <kkstr2.h>          /*  かな漢字ライブラリのヘッダ */

/***********************************************/
/*  キーデータを1行分入力するルーチンです      */
/*                                             */
/*    入力  :  int  flag     0 : ankのみ       */
/*                           1 : 漢字混じり    */
/*    出力  :  char *buff   入力されたデータ   */
/***********************************************/
void  lineinput( int flag, char *buff)
{
      int  cnt; 
      int  code, encode;        /* KYB_read 用ワークデータ          */

     /* 漢字混じりデータ取得か ? */ 
     if( flag == 1) 
     KAN_disp( KAN_DISPON);     /* システム行の表示･かな漢入力許可  */

   cnt = 0;                     /*  設定した文字数                  */
   do {
      code = KYB_read( 1, &encode);
        if( code != 0x0d) {    /* ﾘﾀｰﾝｷー以外ならﾃﾞｰﾀを格納します   */
           buff[cnt] = code;
           cont++;
        }
        /* 未確定文字が表示中ならば処理を継続します                 */
        if( KAN_inpchk() == KAN_MISET)
           continue;
      }while( code != 0x0d)    /* ﾘﾀｰﾝｷーが入力されるまで繰り返します */
      buff[cnt] = '\0'; 

     if( flag == 1) 
       KAN_disp( KAN_DISPOFF); /*  システム行の消去                 */ 
}

1.3 ヘッダファイルKKSTR2.Hについて

struct  {
   int  scrn;                       /*  画面モード                       */
                                    /*   KAN_SCRN16  :  16色モード       */
                                    /*   KAN_SCRN256 : 256色モード       */
                                    /*   KAN_SCRN32K : 32K色モード       */
   char *egbw;                      /*  EGB ワークアドレス               */
   void (*gets)(char *);            /*  文字取得ルーチン関数の登録       */
                                    /*    0:取得ルーチンを登録します     */
                                    /*  ≠0:取得ルーチンを登録しません   */
   void (*getPos)( int *, int * );  /*  かな漢文字列表示開始位置の取得   */
                                    /*  関数のアドレス                   */
   int  wPage;                      /*  かな漢が描画するページ           */
   int  mosAp;                      /*  マウスの制御指示                 */
                                    /*   KAN_MOSON :マウスを制御しません */
                                    /*   KAN_MOSOFF:マウスを制御します   */
   int  maxX;                       /*  画面の最大X座標                  */
   int  maxY;                       /*  画面の最大Y座標                  */
  }KANJ; 

各関数に渡すパラメータの定義
┌──────┬────────┬──────┬─────────────┐
│   関数名   │  設定する場所  │   定  義   │        内  容            │
├──────┼────────┼──────┼─────────────┤
│KAN_prepare │  KANJ.scrn     │KAN_SCRN16  │16色モード                │
│            │                ├──────┼─────────────┤
│            │                │KAN_SCRN256 │256色モード               │
│            │                ├──────┼─────────────┤
│            │                │KAN_SCRN32K │32K色モード               │
│            ├────────┼──────┼─────────────┤
│            │  KANJ.mosAp    │KAN_MOSON   │ﾏｳｽを使用する             │
│            │                │            │                          │
│            │                │            │┌MOS BIOSを初期化する  ┐│
│            │                │            ││                      ││
│            │                │            │└必要有り              ┘│
│            │                ├──────┼─────────────┤
│            │                │KAN_MOSOFF  │ﾏｳｽを使用しない           │
│            │                │            │                          │
│            │                │            │┌MOS BIOSを初期化する  ┐│
│            │                │            ││                      ││
│            │                │            │└必要なし              ┘│
├──────┼────────┼──────┼─────────────┤
│KAN_disp    │  引数          │KAN_DISPOFF │ｼｽﾃﾑ行の消去･かな漢中止   │
│            │                ├──────┼─────────────┤
│            │                │KAN_DISPON  │ｼｽﾃﾑ行の表示･かな漢開始   │
├──────┼────────┼──────┼─────────────┤
│KAN_inpchk  │  戻り値        │KAN_MISET   │未確定文字列表示中        │
│            │                ├──────┼─────────────┤
│            │                │KAN_MIUNSET │未確定文字列は表示されてい│
│            │                │            │                          │
│            │                │            │ない                      │
└──────┴────────┴──────┴─────────────┘

- 注意 -
KAN_prepare関数での初期化時、getsおよびgetposに関数を登録しない場合は、必ず0
を設定してください。

1.4 各関数からのエラー一覧

┌──────┬─────────────────────────────┐
│戻  り  値  │              原  因  と  対  応  方  法                  │
├──────┼─────────────────────────────┤
│KAN_NOERR   │正常終了                                                  │
├──────┼─────────────────────────────┤
│KAN_NOINIT  │初期化せずに各関数を呼び出した                            │
│            ├─────────────────────────────┤
│            │KAN_prepare関数を呼び出してから各関数を呼び出す           │
├──────┼─────────────────────────────┤
│KAN_MEMSET  │KAN_setWorkAdd関数を呼び出す前に、KAN_disp関数を呼んだため│
│            │に、KAN_disp関数の内部でワークが取得された                │
│            ├─────────────────────────────┤
│            │KAN_disp関数を呼び出す前に、KAN_setWorkadd関数を呼び出し、│
│            │ワークアドレスを設定する                                  │
├──────┼─────────────────────────────┤
│KAN_NOMEM   │KAN_disp関数を呼び出したときに、ワークメモリを獲得できなか│
│            │った                                                      │
│            ├─────────────────────────────┤
│            │アプリのメモリ使用量を少なくする                          │
├──────┼─────────────────────────────┤
│KAN_INITERR │終了を呼び出さずに初期化が呼び出された                    │
│            ├─────────────────────────────┤
│            │KAN_prepare関数を2度呼び出さないようにプログラムを修正す  │
│            │るKAN_finish関数を一度呼んでから呼び出す                  │
├──────┼─────────────────────────────┤
│KAN_ENDERR  │KAN_disp(KAN_DISPOFF)関数を呼ばずに終了を呼び出した       │
│            ├─────────────────────────────┤
│            │KAN_disp(KAN_DISPOFF)関数を呼び出してから、終了を呼び出す │
└──────┴─────────────────────────────┘

2 かな漢字変換ライブラリ

2.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│KAN_prepare               │かな漢字変換ライブラリの初期化            │
├─────────────┼─────────────────────┤
│KAN_finish                │かな漢字変換ライブラリの終了              │
├─────────────┼─────────────────────┤
│KAN_disp                  │システム行の表示                          │
├─────────────┼─────────────────────┤
│KAN_setWorkAdd            │ワークアドレスの設定                      │
├─────────────┼─────────────────────┤
│KAN_getWorkSize           │ワークサイズの取得                        │
├─────────────┼─────────────────────┤
│KAN_setClrTbl             │色情報の設定                              │
├─────────────┼─────────────────────┤
│KAN_inpchk                │未確定文字列表示状態の読み取り            │
├─────────────┼─────────────────────┤
│KAN_setMode               │かな漢字変換の入力状態の設定              │
├─────────────┼─────────────────────┤
│KAN_getMode               │かな漢字変換の入力状態の読み取り          │
└─────────────┴─────────────────────┘

2.2 各関数の解説

-----------------------------------------------------------------------------
.KAN_disp
システム行の表示
-----------------------------------------------------------------------------

- 定義 -
#include <kkstr2.h> 
int   KAN_disp(int flag); 
int   flag;   /*  システム行を表示/消去      */
              /*  KAN_DISPOFF :消去          */
              /*  KAN_DISPON  :表示          */

- 戻り値 -
ret = KAN_NOERR  :正常終了
      KAN_NOINIT :初期化されていない
      KAN_NOMEM  :メモリ不足

- 例 -
#include <kkstr2.h> 
        …
int  sw, ret; 
sw = KAN_DISPON; 

ret  =  KAN_disp(sw);      /*   システム行の表示とかな漢実行  */

- 内容 -
システム行の表示/消去を行います。
本関数が呼び出されると、かな漢字変換ライブラリは自分自身がワークとして利用す
る管理域の確保を行います(malloc関数を呼び出します)。
アプリケーションがメモリを自分で管理したい場合は、本関数を呼び出す前に、
KAN_setWorkAdd関数でワークアドレスを設定しておいてください。

-----------------------------------------------------------------------------
.KAN_finish
かな漢字変換ライブラリの終了
-----------------------------------------------------------------------------

- 定義 -
#include <kkstr2.h> 
int   KAN_finish(void); 

- 戻り値 -
ret = KAN_NOERR  :正常終了
      KAN_NOINIT :初期化されていない

- 内容 -
かな漢字変換機能を停止させます。かな漢字変換機能の停止後に、キーデータの取得
を行っても画面に未確定文字列などが表示されることはありません。

-----------------------------------------------------------------------------
.KAN_getMode 
かな漢字変換の入力状態の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <kkstr2.h> 
int KAN_getMode(int *mode); 
int *mode;                /*    現在の入力状態       */ 

- 戻り値 -
ret = KAN_NOERR  :正常終了
      KAN_NOINIT :初期化されていない

- 例 -
ライブラリが設定する値の意味
     31      18  17  16  15      11  10   9   8   7   6   5   4   3      0
  ┌─┬〜┬─┬─┬─┬─┬〜┬─┬─┬─┬─┬─┬─┬─┬─┬─┬〜┬─┐
mode: │  │  │＊│＊│  │  │  │＊│＊│＊│＊│＊│＊│＊│  │  │  │
  └┬┴〜┴┬┴┬┴┬┴┬┴〜┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴〜┴┬┘
    └─┬─┘  │  │  └─┬─┘  │  │  │  │  │  │  │  └─┬─┘
        │      │  │      │      │  │  │  │  │  │  │      └ 0
        │      │  │      │      │  │  │  │  │  │  └カナ入力モード
        │      │  │      │      │  │  │  │  │  └──ローマ字入力
        │      │  │      │      │  │  │  │  └半角入力
        │      │  │      │      │  │  │  └──全角入力
        │      │  │      │      │  │  └英数入力
        │      │  │      │      │  └──カタカナ入力
        │      │  │      │      └────ひらがな入力
        │      │  │      └  0
        │      │  └─入力モード固定
        │      └─英字入力モード
        └  0

各ビットの意味は、以下の表のとおりです。

┌───┬──────────────────────────┐
│ﾋﾞｯﾄNO│                   内容                             │
├───┼──────────────────────────┤
│ 5，4 │ローマ字入力の切り換え                              │
│      │   0 1  カナ入力(ローマ字変換なし)モード            │
│      │   1 0  ローマ字入力                                │
├───┼──────────────────────────┤
│ 7，6 │全角/半角の入力モード切り換え                       │
│      │   0 1  半角入力モード                              │
│      │   1 0  全角入力モード                              │
├───┼──────────────────────────┤
│10,9,8│かな/カナ/英数入力の切り換え                        │
│      │   0 0 1  英数入力モード                            │
│      │   0 1 0  カタカナ入力モード                        │
│      │   1 0 0  ひらがな入力モード                        │
├───┼──────────────────────────┤
│16    │入力モードの固定切り換え                            │
│      │    0  入力モードが変更可能状態                     │
│      │    1  入力モードが固定状態                         │
├───┼──────────────────────────┤
│17    │英字入力モードの切り換え                            │
│      │    0  英小入力                                     │
│      │    1  英大入力                                     │
│      │  ※このビットは英数入力時のみ有効となる            │
└───┴──────────────────────────┘

- 内容 -
かな漢字変換の入力モードを読み取ります。

-----------------------------------------------------------------------------
.KAN_getWorkSize 
ワークサイズの取得
-----------------------------------------------------------------------------

- 定義 -
#include <kkstr2.h> 
int   KAN_getWorkSize(void);

- 戻り値 -
ret = 確保すべきワークサイズ

- 例 -
#include <kkstr2.h> 
      …
int  ret; 

ret = KAN_getWorkSize();      /*  ﾗｲﾌﾞﾗﾘが使用するﾜｰｸｻｲｽﾞ  */ 

- 内容 -
初期化で設定した画面モードのときにライブラリが使用するメモリ量を計算し、計算
結果を返します。
アプリケーションは戻り値分のメモリをmalloc関数などで確保してください。

-----------------------------------------------------------------------------
.KAN_inpchk
未確定文字列表示状態の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <kkstr2.h> 
int   KAN_inpchk(void); 

- 戻り値 -
ret = KAN_MISET   :未確定文字列が表示れさている
      KAN_MIUNSET :未確定文字列は表示されていない
      KAN_NOINIT  :初期化されていない

- 内容 -
未確定文字列が表示中か否かを返します。KYB_read関数でキーデータに0xff(キーデー
タなし)が戻ってきた場合、本関数を呼び出して未確定文字が表示中かどうかを判断し
てください。未確定文字が表示中の場合は、KYB_read関数を再度発行してください。

- 注意 -
未確定文字列が表示中の場合は、画面を書き換えないでください。

-----------------------------------------------------------------------------
.KAN_prepare
かな漢字変換ライブラリの初期化
-----------------------------------------------------------------------------

- 定義 -
#include <kkstr2.h> 
int   KAN_prepare(KANJ *kana);
KANJ  *kana;         /*   表示ルーチンのアドレス  */

- 戻り値 -
ret = KAN_NOERR   :正常終了
      KAN_INITERR :すでに初期化済

- 例 -
画面モード3でかな漢を初期化する場合

#include <kkstr2.h> 
        …
char  gwork[EgbWorkSize]; 
char  mwork[MosWorkSize]; 

int init()
{
    KANJ    prm;
    extern  void setstring(); 
    extern  void setpos();

    EGB_init(gwork, EgbWorkSize); 
    EGB_resolution(gwork, 0, 3);
    MOS_start(mwork, MosWorkSize);
    MOS_resolution(0, 3); 

    prm.scrn    = KAN_SCRN16;    /*   16色モード                 */ 
    prm.egb     = gwork;         /*   EGBのワークアドレスの設定  */ 
    prm.wPage   = 0;             /*   書き込みページ             */ 
    prm.mosAp   = KAN_MOSON;     /*   マウスを利用します         */ 
    prm.maxX    = 639;           /*   画面の最大Ｘ座標           */ 
    prm.maxY    = 479;           /*   画面の最大Ｙ座標           */ 
    prm.gets    = setstring;     /*   文字取得ルーチン           */ 
    prm.setPos  = setpos;        /*   表示開始位置指定ルーチン   */ 

    KAN_prepare(&setprm);        /*   かな漢字変換ﾗｲﾌﾞﾗﾘ初期化   */

}

- 内容 -
初期化を行います。本ライブラリに渡すEGBのワークアドレスは、EGBを初期化したあ
とのものを設定してください。また、本関数を呼び出す前に、次の2つの関数アドレス
を設定してください。
 ･文字列取得関数(設定しない場合は、単語登録ができません)
 ･文字表示開始位置取得関数(登録しない場合は、未確定文字列は常に画面の左上から
  表示されます)これらの関数を登録しない場合は、かならず0を設定してください。

- 注意 -
構造体に設定する2つの関数は、それぞれ以下の仕様を満たす必要があります。


■void(*gets)(char *moji)  文字列取得関数

- 戻り値 -
char *moji; 

- 例 -
#include <kkstr2.h> 
        …
char  str[] =  "単語登録するための文字列";

int  Function() 
{
     KANJ  prm; 
     extern void setstring(); 
        …
     prm.gets = setstring;
        …
     KAN_prepare(&prm);
}

void setstring(char *moji)
{
    int len;

    /*  設定する文字列の長さを求めます            */
    len = strlen(str);

    strcpy(moji, str);               /* 文字列を設定します     */ 
    memset(&moji[len], 80 - len, '\0'); 
                                     /* 不足分を'\0'で埋めます */ 
}

- 内容 -
本関数は、単語登録などでかな漢字変換ライブラリに文字列を渡す必要がある場合に
呼び出されます。現在のカーソル位置から、半角80文字分の文字データを、*mojiに
設定してライブラリに通知してください。
文字列の最後に、全角の1バイト目が存在した場合は、2バイト目のデータをその次の
データとしてライブラリに通知してください。(この場合のみ、文字列の長さが半角
81文字分となります)また、文字列データが半角80文字に満たない場合は、'\0'を不足
分設定してください。


■void(*getPos)(int *x,int *y)    表示開始位置取得関数

- 戻り値 -
int *x;    /*  未確定文字列表示開始点  Ｘ座標 */ 
int *y;    /*  未確定文字列表示開始点  Ｙ座標 */ 

- 例 -
#include <kkstr2.h> 
        …
int  Function() 
{
     KANJ  prm; 
     extern void setpos();
        …
     prm.setPos = setpos; 
        …
     KAN_prepare(&prm);
}

void setpos(int *x, int *y) 
{
/*  未確定文字列の表示開始位置を(100, 100)にします      */
*x = 100; 
*y = 100; 
}

図EXL121R-004

- 内容 -
本関数は、かな漢字変換ライブラリが未確定文字列を表示する場合に呼び出されます
。未確定文字列の描画開始点は、X座標･Y座標を通知してください。

-----------------------------------------------------------------------------
.KAN_setClrTbl
色情報の設定
-----------------------------------------------------------------------------

- 定義 -
#include <kkstr2.h> 
int   KAN_setClrTbl(int *tbl);
int   *tbl;                /*  16 色分の配列            */

- 戻り値 -
ret = KAN_NOERR  :正常終了
      KAN_NOINIT :初期化されていない

- 例 -
以下に16色モードの場合の色識別情報の設定例を示します。
(この例では黒の色識別番号を変更しています)

#include <kkstr2.h> 
…
int ret, col[16]; 
col[ 0] = 0x08;             /*  黒を色識別番号の8に設定        */ 
col[ 1] = 0x01;             /*  暗い青を色識別番号の1に設定    */ 
col[ 2] = 0x02;             /*  暗い赤を色識別番号の2に設定    */ 
col[ 3] = 0x03;             /*  暗い紫を色識別番号の3に設定    */ 
col[ 4] = 0x04;             /*  暗い緑を色識別番号の4に設定    */ 
col[ 5] = 0x05;             /*  暗い水色を色識別番号の5に設定  */ 
col[ 6] = 0x06;             /*  暗い黄を色識別番号の6に設定    */ 
col[ 7] = 0x07;             /*  暗い白を色識別番号の7に設定    */ 
col[ 8] = 0x00;             /*  明るい黒を色識別番号の0に設定  */ 
col[ 9] = 0x09;             /*  青を色識別番号の9に設定        */ 
col[10] = 0x0a;             /*  赤を色識別番号の10に設定       */ 
col[11] = 0x0b;             /*  紫を色識別番号の11に設定       */ 
col[12] = 0x0c;             /*  緑を色識別番号の12に設定       */ 
col[13] = 0x0d;             /*  水色を色識別番号の13に設定     */ 
col[14] = 0x0e;             /*  黄色を色識別番号の14に設定     */ 
col[15] = 0x0f;             /*  白を色識別番号の15に設定       */ 

ret = KAN_setClrTbl(col);   /*  色識別番号の設定               */ 

- 内容 -
かな漢字変換ライブラリが画面に文字列(未確定文字･システム行)を表示する場合、
使用可能な色の数は16色です。このため、本関数は各画面モードに対応した16色分の
色識別情報を用意しています。画面表示に使用可能な色と画面モードごとの色識別情
報は次ページの表を参照してください。

┌──────────┬──────────────────────┐
│    画面表示に      │          色識別番号のデフォルト値          │
│    使用可能な色    ├──────┬───────┬───────┤
│                    │  16色画面  │   256色画面  │   32K色画面  │
├──────────┼──────┼───────┼───────┤
│    黒*             │       0    │       0x00   │      0x0000  │
│    青  (暗色)      │       1    │       0x02   │      0x0010  │
│    赤  (暗色)      │       2    │       0x10   │      0x0200  │
│    紫  (暗色)      │       3    │       0x12   │      0x0210  │
│    緑  (暗色)      │       4    │       0x80   │      0x4000  │
│    水色(暗色)      │       5    │       0x82   │      0x4010  │
│    黄  (暗色)      │       6    │       0x90   │      0x4200  │
│    白  (暗色)      │       7    │       0x92   │      0x4210  │
│    黒  (明色)      │       8    │       0x49   │      0x2108  │
│    青              │       9    │       0x03   │      0x001f  │
│    赤              │      10    │       0x1c   │      0x03e0  │
│    紫              │      11    │       0x1f   │      0x03ff  │
│    緑*             │      12    │       0xe0   │      0x7c00  │
│    水色*           │      13    │       0xe3   │      0x7c1f  │
│    黄色*           │      14    │       0xfc   │      0x7fe0  │
│    白*             │      15    │       0xff   │      0x7fff  │
└──────────┴──────┴───────┴───────┘
  *は、Townsシステムソフトウェア V2.1のかな漢字変換機能(OAK)が使用している
   色です。

- 注意 -
白黒を入力中の表示色として使用しています。他の色は入力状態に応じて使用されま
す。16色2画面モードを使用しているアプリケーションまたは、色識別情報を自分で
管理しているアプリケーションでは、かな漢字変換機能の使用する色識別番号との衝
突を避けるため、初期化後本関数を使用して、かな漢字変換機能の使用する色を別の
色識別番号に設定してください。

-----------------------------------------------------------------------------
.KAN_setMode 
かな漢字変換の入力状態の設定
-----------------------------------------------------------------------------

- 定義 -
#include <kkstr2.h> 
int KAN_setMode(int mode);
int mode;               /*      設定するモード       */ 


- 戻り値 -
ret = KAN_NOERR  :正常終了
      KAN_NOINIT :初期化されていない
      KAN_PRMERR :ﾊﾟﾗﾒｰﾀの指定に誤りがある
      KAN_NOTSPT :指定したﾓｰﾄﾞは、ｻﾎﾟｰﾄされていない

- 例 -
関数に渡すパラメータは、以下のようになっています。

    31      18  17  16  15      11  10   9   8   7   6   5   4   3      0
  ┌─┬〜┬─┬─┬─┬─┬〜┬─┬─┬─┬─┬─┬─┬─┬─┬─┬〜┬─┐
mode: │  │  │＊│＊│  │  │  │＊│＊│＊│＊│＊│＊│＊│  │  │  │
  └┬┴〜┴┬┴┬┴┬┴┬┴〜┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴〜┴┬┘
    └─┬─┘  │  │  └─┬─┘  │  │  │  │  │  │  │  └┬──┘
        │      │  │      │      │  │  │  │  │  │  │    └リザーブ
        │      │  │      │      │  │  │  │  │  │  └カナ入力モード
        │      │  │      │      │  │  │  │  │  └──ローマ字入力
        │      │  │      │      │  │  │  │  └半角入力
        │      │  │      │      │  │  │  └──全角入力
        │      │  │      │      │  │  └英数入力
        │      │  │      │      │  └──カタカナ入力
        │      │  │      │      └────ひらがな入力
        │      │  │      └リザーブ
        │      │  └─入力モード固定
        │      └─英字入力モード
        └リザーブ

リザーブは、常に0を設定します。各ビットの意味は、以下の表のとおりです。

┌───┬──────────────────────────┐
│ﾋﾞｯﾄNO│                 内        容                       │
├───┼──────────────────────────┤
│ 5，4 │ローマ字入力の切り換え                              │
│      │   0 0  入力モードの変更なし                        │
│      │   0 1  カナ入力(ローマ字変換なし)モード            │
│      │   1 0  ローマ字入力                                │
│      │   1 1  エラー                                      │
├───┼──────────────────────────┤
│ 7，6 │全角/半角の入力モード切り換え                       │
│      │   0 0  入力モードの変更なし                        │
│      │   0 1  半角入力モード                              │
│      │   1 0  全角入力モード                              │
│      │   1 1  エラー                                      │
├───┼──────────────────────────┤
│10,9,8│かな/カナ/英数入力の切り換え                        │
│      │   0 0 0  入力モードの変更なし                      │
│      │   0 0 1  英数入力モード                            │
│      │   0 1 0  カタカナ入力モード                        │
│      │   1 0 0  ひらがな入力モード                        │
│      │  ※  他の組み合わせのビットはすべてエラー          │
├───┼──────────────────────────┤
│16    │入力モードの固定切り換え                            │
│      │    0  入力モードを固定しない                       │
│      │    1  入力モードを固定する                         │
├───┼──────────────────────────┤
│17    │英字入力モードの切り換え                            │
│      │    0  英小入力                                     │
│      │    1  英大入力                                     │
│      │  ※このビットは英数入力時のみ有効となる            │
└───┴──────────────────────────┘

入力モードを設定する場合に渡す具体的な例
┌───────┬───────┬───────┐
│  現在の状態  │設定するモード│ﾗｲﾌﾞﾗﾘに渡す値│
├───────┼───────┼───────┤
│  辞    英小  │  辞    英大  │  0x00020000  │
├───────┼───────┼───────┤
│  辞    英小  │  辞全Ｒかな  │  0x000004a0  │
├───────┼───────┼───────┤
│  辞全  かな  │  辞    英大  │  0x00020140  │
└───────┴───────┴───────┘

入力モード設定のために定数をヘッダ(kkstr2.h)に定義
┌─────────┬─────────────────┬─────┐
│定義名            │            内      容            │    値    │
├─────────┼─────────────────┼─────┤
│KAN_ROUMAZIOFF    │カナ入力(ローマ字変換なし)モード  │0x00000010│
│                  │                                  │          │
│KAN_ROUMAZI       │ローマ字入力                      │0x00000020│
│                  │                                  │          │
│KAN_HANKAKU       │半角入力モード                    │0x00000040│
│                  │                                  │          │
│KAN_ZENKAKU       │全角入力モード                    │0x00000080│
│                  │                                  │          │
│KAN_EISUU         │英数入力モード                    │0x00000100│
│                  │                                  │          │
│KAN_KATAKANA      │カタカナ入力モード                │0x00000200│
│                  │                                  │          │
│KAN_HIRAGANA      │ひらがな入力モード                │0x00000400│
│                  │                                  │          │
│KAN_MODELOCKOFF   │入力モードを固定しない            │0x00000000│
│                  │                                  │          │
│KAN_MODELOCK      │入力モードを固定する              │0x00010000│
│                  │                                  │          │
│KAN_EISYOU        │英小入力                          │0x00000000│
│                  │                                  │          │
│KAN_EIDAI         │英大入力                          │0x00020000│
└─────────┴─────────────────┴─────┘

定義されている値を利用した場合の例(OAKのシステム行の状態を例にとった場合)
┌───────┬───────┬────────────────────┐
│  現在の状態  │設定するモード│            ライブラリに渡す値          │
├───────┼───────┼────────────────────┤
│  辞    英小  │  辞    英大  │ KAN_EIDAI                              │
├───────┼───────┼────────────────────┤
│  辞    英小  │  辞全Ｒかな  │ KAN_HIRAGANA |KAN_ROUMAZI |KAN_ZENKAKU │
├───────┼───────┼────────────────────┤
│  辞全  かな  │  辞    英大  │ KAN_EISUU |KAN_HANKAKU |KAN_EIDAI      │
└───────┴───────┴────────────────────┘

- 内容 -
かな漢字変換の入力モードをアプリケーションがコントロールする場合に、この関数
を呼び出します。

-----------------------------------------------------------------------------
.KAN_setWorkAdd
ワークアドレスの設定
-----------------------------------------------------------------------------

- 定義 -
#include <kkstr2.h> 
int   KAN_setWorkAdd(short sel, char *add); 
short sel;          /*  管理領域のセレクタ      */
char  *add;         /*  管理領域のアドレス      */

- 戻り値 -
ret = KAN_NOERR  :正常終了
      KAN_NOINIT :初期化されていない

- 例 -
#include <kkstr2.h> 
        …
int    ret; 
short  sel; 
char   *add;

sel = getds();        /*  現在のdsセレクタ値を読み取るgetds() は  */
                      /*  msdos.cfで定義されています              */
add = malloc(KAN_getWorkSize());   /* ワークエリアの確保          */

ret = KAN_setWorkAdd(sel, add);    /* ワークアドレスの設定        */

- 内容 -
ワークアドレスを設定します。本関数は、ライブラリの使うワークエリアをアプリケ
ーションが設定したいときに使います。
アドレスに、NULLを指定した場合は、前回設定したワークアドレスが取消されます。
(アドレスにNULLを指定して、KAN_disp関数を呼び出すと、KAN_disp関数内部でメモリ
確保が行われます。)

2.3 サンプルプログラム

┌────────────────────────────────────┐
│かな漢字変換ライブラリサンプルプログラム                                │
│■  機能  ■                                                            │
│  未確定文字を表示し、変換キーでかな漢字変換を行います。                │
│  ･画面モード:16色、640*480ドット、2画面                                │
│  ･EGB用ワークエリア:アプリケーション自身で管理                         │
│  ･ソフトウェアキーボード:使用しない                                    │
│(かな漢字変換機能とソフトウェアキーボードを組み合わせて使用するアプリケ │
│ ーションのサンプルは、｢第3章  ソフトウェアキーボードライブラリ｣を参照  │
│ してください。)                                                        │
└────────────────────────────────────┘

  /************************************************************************/
  /*  Towns ｼｽﾃﾑｿﾌﾄｳｪｱ V2.1 かな漢字変換ライブラリ サンプルプログラム     */
  /*                                                                      */
  /************************************************************************/

  /*  インクルードファイル一覧                        */

  /*  High C Compiler で用意されているファイル        */
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <msdos.cf>  /* getdsが定義されています     */

  /*  拡張ライブラリで用意されているファイル          */
  #include <egb.h>
  #include <mos.h>
  #include <fmcfrb.h>
  #include <kkstr2.h>

  /*  各種データの定義                                */

  /*  プログラム中のエラー定義 */
  #define NOERR   0            /*  正常終了                                */
  #define EGBERR  -1           /*  EGBライブラリからエラーが戻ってきました */
  #define MOSERR  -2           /*  MOSライブラリからエラーが戻ってきました */
  #define KANERR  -3           /*  かな漢ﾗｲﾌﾞﾗﾘからエラーが戻ってきました  */
                               /*  グローバル変数                          */
  char    gwork[EgbWorkSize];  /*  EGBのワークアドレス                     */
  char    mwork[MosWorkSize];  /*  MOSのワークアドレス                     */
  char    *kwork;              /*  かな漢ライブラリに渡すﾜｰｸのｱﾄﾞﾚｽ        */

  char    tanmoji[]="単語登録のための文字列";

  /*  プログラム中に利用する関数の宣言    */
  extern  int initSystem( void );
  extern  int termSystem( void );
  extern  int kanainit( void );

  /************************************************************************/
  /*  メイン                                                              */
  /*                                                                      */
  /*  【概略】 各ライブラリを初期化し､キーボードからリターンキーが        */
  /*           押されるまでプログラムを実行します                         */
  /*                                                                      */
  /************************************************************************/
  void main()
  {
      unsigned int    code, encode;

      if( initSystem() == NOERR) {

          KAN_disp( KAN_DISPON);      /*  ｼｽﾃﾑ行の表示とかな漢の開始   */ 

          for(;;){
              code = KYB_read( 1, &encode);
                                      /*  未確定文字列表示中ならば   */
                                      /*  終了処理をしません         */
              if( KAN_inpchk() == KAN_MIUNSET)
                  if( code == 0x0d)
                      break;
          }

          KAN_disp( KAN_DISPOFF);     /*  ｼｽﾃﾑ行の消去とかな漢の中断   */ 
      }

      termSystem();
  }

  /********************************************************************/
  /*  各ライブラリの初期化処理                                        */
  /*      int initSystem( void );                                     */
  /*                                                                  */
  /*  【入力】なし                                                    */
  /*                                                                  */
  /*  【出力】retun値     NOERR  : 正常終了                           */
  /*                      EGBERR : EGBの初期化中にエラーが発生        */
  /*                      MOSERR : MOSの初期化中にエラーが発生        */
  /*                      KANERR : かな漢の初期化中にエラーが発生     */
  /*                                                                  */
  /*  【機能】EGB, MOS, かな漢の各ライブラリを初期化します            */
  /*                                                                  */
  /********************************************************************/
  int initSystem( void )
  {
      int     ret;
      char    para[128];
      char    msg1[] = "キーボードから入力された未確定文字列を表示します";
      char    msg2[] = "変換キーでかな漢字変換します";

      char    msg3[] = "リターンキーを押すと終了します";

      /*  EGB関係の初期化             */
      EGB_init(gwork, EgbWorkSize);  /* 初期化                           */
      EGB_resolution(gwork, 0, 3);   /* page 0の設定(640*480 16色モード) */
      EGB_resolution(gwork, 1, 3);   /* page 1の設定(640*480 16色モード) */
      EGB_displayPage(gwork, 0, 1);  /* 画面の表示                       */
      EGB_color( gwork, 1, 1);       /* 背景色の設定                     */
      EGB_clearScreen( gwork);       /* 画面の消去(画面背景が青色になる) */

      /*  このプログラムの説明を画面に表示します  */
      WORD( para + 0) = 0;        /*  表示開始位置 X座標                 */
      WORD( para + 2) = 400;      /*  表示開始位置 Y座標                 */
                                  /*  文字列の長さを求めて長さを設定     */
      WORD( para + 4) = strlen( msg1);
      strcpy( &para[6], msg1);    /*  文字列を設定                       */
      EGB_sjisString( gwork, &para[0]);

      WORD( para + 0) = 0;        /*  表示開始位置 X座標                 */
      WORD( para + 2) = 417;      /*  表示開始位置 Y座標                 */
                                  /*  文字列の長さを求めて長さを設定     */
      WORD( para + 4) = strlen( msg2);
      strcpy( &para[6], msg2);    /*  文字列を設定                       */
      EGB_sjisString( gwork, &para[0]);

      WORD( para + 0) = 0;        /*  表示開始位置 X座標                 */
      WORD( para + 2) = 434;      /*  表示開始位置 Y座標                 */
                                  /*  文字列の長さを求めて長さを設定     */
      WORD( para + 4) = strlen( msg3);
      strcpy( &para[6], msg3);    /*  文字列を設定                       */
      EGB_sjisString( gwork, &para[0]);

      /*  MOS関係の初期化             */
      MOS_start( mwork, MosWorkSize);    /* 初期化                       */
      MOS_resolution( 0, 3);             /* 解像度の設定                 */
      MOS_disp(1);                       /* マウスの表示                 */

      /*  かな漢ライブラリの初期化    */
      ret = kanainit();

      return ret;
  }

  /********************************************************************/
  /*  かな漢ライブラリの初期化                                        */
  /*      int kanainit( void );                                       */
  /*                                                                  */
  /*  【入力】なし                                                    */
  /*                                                                  */
  /*  【出力】return値    NOERR  : 正常終了                           */
  /*                      KANERR : かな漢ﾗｲﾌﾞﾗﾘでｴﾗｰが発生            */
  /*                                                                  */
  /*  【概略】かな漢ﾗｲﾌﾞﾗﾘの初期化処理を行います                      */
  /*          ﾗｲﾌﾞﾗﾘの初期化中にｴﾗｰが発生した場合は､呼び出し元にｴﾗｰを */
  /*          通知します                                              */
  /*                                                                  */
  /********************************************************************/
  int kanainit( void )
  {

      KANJ    prm;
      int     col[16];
      extern  void GetString( char *);        /*  .getsに登録する関数    */
      extern  void GetDspPos( int *, int *);  /*  .getPosに登録する関数  */

      prm.scrn   = KAN_SCRN16;    /*  画面ﾓｰﾄﾞは16色モード               */
      prm.egbw   = gwork;         /*  EGBのﾜｰｸｱﾄﾞﾚｽを設定します          */
      prm.wPage  = 0;             /*  表示ページを0にします              */
      prm.mosAp  = KAN_MOSON;     /*  マウスの制御をします               */
      prm.gets   = GetString;     /*  文字取得ﾙｰﾁﾝの設定                 */
      prm.getPos = GetDspPos;     /*  未確定文字列表示位置取得関数の設定 */
      prm.maxX   = 639;           /*  画面の最大X座標                    */
      prm.maxY   = 479;           /*  画面の最大Y座標                    */

      if( KAN_prepare( &prm) != KAN_NOERR)
          return KANERR;

      /*  以降の処理は一般のアプリでは必要がない部分です          */
      /*  以降の処理を組み込むアプリは、                          */
      /*  1. 自分自身でメモリの管理をしている場合                 */
      /*          ( KAN_getWorkSize, KAN_setWorkAdd)              */
      /*  2. 色識別番号の設定を行い、表示色を変更したい場合       */
      /*          ( KAN_setClrTbl)                                */

      /*  必要なワークサイズを求めてワークアドレスを設定します    */
      kwork = malloc( KAN_getWorkSize());
      if( KAN_setWorkAdd( getds(), kwork) != KAN_NOERR)
          return KANERR;

      /*  色情報の設定                                             */
      col[ 0] = 0x08;        /*  黒の色識別番号を8にします         */
      col[ 1] = 0x01;        /*  青(暗色)の色識別番号を1にします   */
      col[ 2] = 0x02;        /*  赤(暗色)の色識別番号を2にします   */
      col[ 3] = 0x03;        /*  紫(暗色)の色識別番号を3にします   */
      col[ 4] = 0x04;        /*  緑(暗色)の色識別番号を4にします   */
      col[ 5] = 0x05;        /*  水色(暗色)色識別番号を5にします   */
      col[ 6] = 0x06;        /*  黄色(暗色)色識別番号を6にします   */
      col[ 7] = 0x07;        /*  白(暗色)の色識別番号を7にします   */
      col[ 8] = 0x00;        /*  黒(明色)の色識別番号を0にします   */
      col[ 9] = 0x09;        /*  青の色識別番号を9にします         */
      col[10] = 0x0a;        /*  赤の色識別番号を10にします        */
      col[11] = 0x0b;        /*  紫の色識別番号を11にします        */
      col[12] = 0x0c;        /*  緑の色識別番号を12にします        */
      col[13] = 0x0d;        /*  水色色識別番号を13にします        */
      col[14] = 0x0e;        /*  黄色色識別番号を14にします        */
      col[15] = 0x0f;        /*  白の色識別番号を15にします        */

      if( KAN_setClrTbl( col) != KAN_NOERR)
          return KANERR;

      return NOERR;
  }

  /********************************************************************/
  /*  各ライブラリの終了処理                                          */
  /*      int termSystem( void );                                     */
  /*                                                                  */
  /*  【入力】なし                                                    */
  /*                                                                  */
  /*  【出力】retun値     NOERR  : 正常終了                           */
  /*                      MOSERR : MOSのﾗｲﾌﾞﾗﾘでエラーが発生          */
  /*                      KANERR : かな漢のﾗｲﾌﾞﾗﾘでエラーが発生       */
  /*                                                                  */
  /*  【機能】 MOS、かな漢の各ライブラリを終了宣言します              */
  /*                                                                  */
  /********************************************************************/
  int termSystem( void )
  {
      int     ret;

      /*  確保したメモリの解放                */
      if( kwork != 0)
          free( kwork);

      /*  かな漢ライブラリの終了              */
      if( KAN_finish() != KAN_NOERR)
          ret = KANERR;

      /*  マウスの終了                        */
      MOS_end();

      return ret;
  }

  /****************************************************************/
  /*  文字列取得ルーチン                                          */
  /*      void GetString( char *code);                            */
  /*                                                              */
  /*  【入力】なし                                                */
  /*                                                              */
  /*  【出力】char *code;     ﾗｲﾌﾞﾗﾘに渡す文字列                  */
  /*                                                              */
  /*  【機能】かな漢ﾗｲﾌﾞﾗﾘ初期化の構造体 .getsに設定し､           */
  /*          単語登録などの文字列が必要な場合に呼び出されます    */
  /*                                                              */
  /****************************************************************/
  void GetString( char *code)
  {
      int     len;

      /*   文字列の長さ分だけｺﾋﾟｰし､残りは'\0'で埋めます      */
      strcpy( code, tanmoji);
      len = strlen( tanmoji);
      memset( &code[len], '\0', 80 - len);
  }

  /****************************************************************/
  /*  未確定文字列表示開始位置の取得ルーチン                      */
  /*      void GetDspPos( int *x, int *y);                        */
  /*                                                              */
  /*  【入力】なし                                                */
  /*                                                              */
  /*  【出力】char *x;        未確定文字列表示開始位置 X座標      */
  /*          int  *y;        未確定文字列表示開始位置 Y座標      */
  /*                                                              */
  /*  【機能】かな漢ﾗｲﾌﾞﾗﾘ初期化の構造体 .getPosに設定し､         */
  /*          未確定文字列の表示開始位置を返します                */
  /*                                                              */
  /****************************************************************/
  void GetDspPos( int *x, int *y)
  {
      /*  未確定文字列の表示開始位置として(100, 100)を返します        */
      *x = 100;
      *y = 100;
  }

*****************************************************************************
第3章  ソフトウェアキーボードライブラリ
*****************************************************************************

1 ソフトウェアキーボードライブラリについて

1.1 概要

  ソフトウェアキーボードはTownsシステムソフトウェア V2.1 を使用するユーザが、
ファイル名などの簡単なテキストを、キーボードを用いずマウスオペレーションのみ
で入力可能とするように、キーボードの機能の一部をソフトウェアでエミュレーショ
ンするものです。
  希望のキーの表示された位置にマウスカーソルを合わせて左クリックすることによ
り、キー入力を行えます。この入力は実際にキーボードが押されて文字が入力された
のと同じ状態です。アプリケーションからはソフトウェアキーボードから入力された
のか、実際のキーボードから入力されたのかを区別することはできません。

    パターン数    :2パターン(英字キー、かなキー)
    入力可能キー数:104キー(英字パターン)
                    93キー(かなパターン)

  ソフトウェアキーボードと組み合わせて使用できるかな漢字変換システムはOAK4の
みを前提とし、他社製のかな漢字変換システム(VJE、ATOKなど)は対象としていません
。また、ソフトウェアキーボードには以下のキーがありません。

    ･PF1〜PF20(プログラマブルファンクションキー)
    ･SHIFT、CTRLキー(シフト機能キー)
    ･ESCキー(拡張用キー)
    ･BREAK、COPYキー(特殊機能用キー)
    ･その他OS/2、通信対応キー
    ･実行キー

1.2 基本動作フロー

  図EXL121R-005

  ソフトウェアキーボードで最低限必要なのは、2〜5の処理です。さらに必要に応じ
て、アプリケーションの画面状態に応じた表示を行うために画面モードなどの情報を
取得したり、表示する位置を設定したりする処理を加えてください。ただし、GUIを使
用する場合は使用方法が異なりますので、拡張ライブラリII｢GUIライブラリ V2.1ユー
ザーズガイド｣を参照してください。

 (1)ソフトウェアキーボードを利用する前に必要な処理
    基本動作フローの2〜3がソフトウェアキーボードを利用する前に必要な処理です
    。

   ･ソフトウェアキーボードを初期化する前には必ずEGBとマウスが初期化されている
    状態にしてください。
    ソフトウェアキーボードはEGBとマウスが動作していないと動作できません。
   ･SKB_start関数を発行し、ソフトウェアキーボードの登録処理を行います。
   ･必要ならばSKB_setDispPos関数を使用してソフトウェアキーボードの表示位置を
    指定してください。初期状態では、画面の左上に設定されています。
   ･SKB_disp関数を発行し、ソフトウェアキーボードを表示します。

- 注意 -
SKB_start関数で設定するEGBワーク領域はソフトウェアキーボード専用としてくださ
い。ソフトウェアキーボードライブラリは必要に応じてEGBの機能を独自に設定するた
め、アプリケーションと共用するとアプリケーションの動作に影響を及ぼします。
また、SKB_start関数ではパターン画面退避領域をmalloc関数で確保しますが、アプリ
ケーション側で退避領域を確保することも可能です。
退避領域の大きさはSKB_getSize関数にて取得し、十分な領域を確保してください。
基本動作フロー3の処理が終了した時点でキー入力が可能になります。

- 例 -
#include   <EGB.H>
#include   <MOS.H>
#include   <SKB.H>

    char  EGBwork[EgbWorkSize]; 
    char  MOSwork[MosWorkSize]; 
    char  SKB_EGBwork[EgbWorkSize]; 
    int   scrn_mode, char_color, back_color;
    int   bar_color, base_color;
    SKB_POINT ppt;

    int function()
    {
                …
                …
            scrn_mode = 0;     /* 16色モード */ 
            EGB_init( EGBwork );
            EGB_resolution( EGBwork, 0, 3 );
            EGB_resolution( EGBwork, 1, 3 );
            EGB_displayPage( EGBwork, 0, 3 ); 
            EGB_writePage( EGBwork, 0 );
            MOS_start( MOSwork, MOSWorkSize );
            memcpy( SKB_EGBwork, EGBwork, EgbWorkSize );

            char_color = 15;   /*  ソフトウェアキーボードの色設定  */
            back_color =  8; 
            bar_color =  9; 
            base_color =  7; 
            SKB_start( SKB_EGBwork, scrn_mode, char_color,
            back_color, bar_color, base_color );
            ppt.X = 100;         /*  初期位置設定  */
            ppt.Y = 50; 

            SKB_setDispPos( ppt );
            SKB_disp( SKB_display );             /*  SKBへ表示     */ 
                  …
                  …
            return(0);
}

(2)ソフトウェアキーボード実行中に必要な処理
   基本動作フローの4がソフトウェアキーボード実行中に必要な処理です。

  ･ソフトウェアキーボード実行中、入力された文字を取得するためにキーボードバッ
   ファの内容を常にチェックし、パターン上の窓に入力された文字を表示してくださ
   い。窓の表示位置はSKB_getWindow関数で読み取ってください。また、入力文字の
   取得にはKYB_read関数(アセンブラインタフェースはINT 90H Func 09h)を、必ず入
   力待ちなしの状態で使用してください。
  ･ソフトウェアキーボード実行中でも、マウスオペレーションはアプリケーションに
   通知されます。多重処理を望まない場合はアプリケーション側のマウスに関する処
   理をマスクしてください。
  ･かな漢字変換を行う場合(OAK4)、かな漢字変換中は、ソフトウェアキーボードのド
   ラッグ処理、およびパターン更新を禁止状態に設定してください。
   (SKB_setSKBdrag関数、SKB_getSKBdrag関数)また、かな漢字の変換途中の文字を画
   面に表示する場合および変換途中の状態取得は、かな漢字変換ライブラリを参照し
   てください。
  ･ドラッグ処理を行うルーチンは、本ライブラリ側に標準で用意されていますが、ア
   プリケーション側で用意したルーチンに変更することもできます。
   (SKB_getDragFunc関数、SKB_setDragFunc関数)
  ･SKB_getSave関数、SKB_setSave関数を使用して画面退避領域を変更することができ
   ます。

- 注意 -
[無変換][変換]キーは取得することができません。
ソフトウェアキーボードのパターンはメモリモジュールとしてファイルに格納されて
います。ファイルの内容を変更しないでください。

(3)ソフトウェアキーボード終了時に必要な処理
   基本動作フローの 5がソフトウェアキーボード終了時に必要な処理です。

  ･SKB_end関数を発行し、ソフトウェアキーボードを終了します。

- 注意 -
ソフトウェアキーボードの処理が終了するまでEGBとマウスを終了しないでください。

1.3 ヘッダファイルについて

  ソフトウェアキーボードを使用する場合には、C言語のプリプロセッサ疑似命令
"#include"を用いてヘッダファイル"SKB.H"をソースファイルに取り込んでください。

SKB_drag_before               /*  画面更新前                        */
SKB_drag_after                /*  画面更新後                        */
SKB_display                   /*  ソフトウェアキーボード表示        */
SKB_erase                     /*  ソフトウェアキーボード消去        */
SKB_display_mode_16           /*  16色モード                        */
SKB_display_mode_256          /*  256色モード                       */
SKB_display_mode_32k          /*  32K色モード                       */
SKB_drag_liberty              /*  ドラッグ可                        */
SKB_drag_inhibit              /*  ドラッグ禁止                      */
typedef struct  {
                   short X;               /*  Ｘ軸座標         */ 
                   short Y;               /*  Ｙ軸座標         */ 
                  }SKB_POINT ；           /*  座標構造体       */ 

typedef struct  {
                   short X1;              /*  Ｘ軸座標(左上) */ 
                   short Y1;              /*  Ｙ軸座標(左上) */ 
                   short X2;              /*  Ｘ軸座標(右下) */ 
                   short Y2;              /*  Ｙ軸座標(右下) */ 
                  }SKB_BOX ；             /*  矩形座標構造体 */ 

1.4 ソフトウェアキーボードエラー情報

┌────────────┬───────────────────────┐
│            戻り値      │                内      容                    │
├──────────┬─┼───────────────────────┤
│SKB_no_error        │0 │正常終了                                      │
├──────────┼─┼───────────────────────┤
│SKB_not_start       │1 │ソフトウェアキーボードが動作していない        │
├──────────┼─┼───────────────────────┤
│SKB_not_display     │2 │ソフトウェアキーボードが表示されていない      │
├──────────┼─┼───────────────────────┤
│SKB_already_start   │3 │ソフトウェアキーボードはすでに動作している    │
├──────────┼─┼───────────────────────┤
│SKB_already_display │4 │ソフトウェアキーボードはすでに表示されている  │
├──────────┼─┼───────────────────────┤
│SKB_abort_malloc    │5 │画面退避領域の確保に失敗した                  │
├──────────┼─┼───────────────────────┤
│SKB_undefine_patten │6 │ソフトウェアキーボードのパターンがロードされて│
│                    │  │いない                                        │
├──────────┼─┼───────────────────────┤
│SKB_null_selector   │7 │NULLセレクタを指定している、または、セレクタの│
│                    │  │値が異常                                      │
├──────────┼─┼───────────────────────┤
│SKB_abnormal_end    │-1│上記以外の異常終了                            │
└──────────┴─┴───────────────────────┘

2 ソフトウェアキーボードライブラリ

2.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│SKB_start                 │ソフトウェアキーボードの初期化            │
├─────────────┼─────────────────────┤
│SKB_end                   │ソフトウェアキーボードの終了              │
├─────────────┼─────────────────────┤
│SKB_getSave               │画面退避領域の取得                        │
├─────────────┼─────────────────────┤
│SKB_setSave               │画面退避領域の設定                        │
├─────────────┼─────────────────────┤
│SKB_getDragFunc           │ドラッグルーチンの取得                    │
├─────────────┼─────────────────────┤
│SKB_setDragFunc           │ドラッグルーチンの設定                    │
├─────────────┼─────────────────────┤
│SKB_getDispPos            │表示位置の取得                            │
├─────────────┼─────────────────────┤
│SKB_setDispPos            │表示位置の設定                            │
├─────────────┼─────────────────────┤
│SKB_getDisp               │表示状態取得                              │
├─────────────┼─────────────────────┤
│SKB_disp                  │表示の制御                                │
├─────────────┼─────────────────────┤
│SKB_getWindow             │窓の表示開始位置の取得                    │
├─────────────┼─────────────────────┤
│SKB_getSize               │画面退避領域サイズの取得                  │
├─────────────┼─────────────────────┤
│SKB_getEGBwork            │ｿﾌﾄｳｪｱｷｰﾎﾞｰﾄﾞ用EGBﾜｰｸ領域の取得           │
├─────────────┼─────────────────────┤
│SKB_setEGBwork            │ｿﾌﾄｳｪｱｷｰﾎﾞｰﾄﾞ用EGBﾜｰｸ領域の設定           │
├─────────────┼─────────────────────┤
│SKB_getSKBdrag            │ドラッグ禁止状態の取得                    │
├─────────────┼─────────────────────┤
│SKB_setSKBdrag            │ドラッグ禁止状態の設定                    │
├─────────────┼─────────────────────┤
│SKB_getRewriteFunc        │窓のリライト関数の取得                    │
├─────────────┼─────────────────────┤
│SKB_setRewriteFunc        │窓のリライト関数の設定                    │
└─────────────┴─────────────────────┘

2.2 各関数の解説

-----------------------------------------------------------------------------
.SKB_disp
表示の制御
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_disp(int flag); 
int     flag;     /*  ソフトウェアキーボードの表示状態設定値 */ 
                  /*    SKB_erase  :消去                     */ 
                  /*    SKB_display:表示                     */ 

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
int     flag; 

flag = SKB_display;

ret = SKB_disp(flag); 

- 内容 -
ソフトウェアキーボードの表示･消去を行います。

-----------------------------------------------------------------------------
.SKB_end 
ソフトウェアキーボードの終了
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_end(void);

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
ret = SKB_end();

- 内容 -
ソフトウェアキーボードを終了します。初期化時にmalloc関数によって確保された画
面退避領域は開放されます。本関数を実行すると、再度初期化を実行するまで、ソフ
トウェアキーボードの処理は一切実行できません。

- 注意 -
本関数は必ずマウス終了前に実行してください。

-----------------------------------------------------------------------------
.SKB_getDisp 
表示状態取得
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_getDisp(int *flag); 
int     *flag;         /* ソフトウェアキーボードの表示状態 */ 
                       /*   SKB_erase  :非表示中           */ 
                       /*   SKB_display:表示中             */ 

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
int     flag; 

ret = SKB_getDisp(&flag); 

- 内容 -
ソフトウェアキーボードの表示状態を取得します。

-----------------------------------------------------------------------------
.SKB_getDispPos
表示位置の取得
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_getDispPos(SKB_POINT *ppt);
SKB_POINT *ppt;               /*  表示位置                 */ 

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>
int     ret;
SKB_POINT ppt;

ret = SKB_getDispPos(&ppt); 

- 内容 -
ソフトウェアキーボードの表示位置を取得します。

-----------------------------------------------------------------------------
.SKB_getDragFunc 
ドラッグルーチンの取得
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_getDragFunc(int (**func)());
int  (**func)(SKB_BOX *skbpos, SKB_POINT *mospos, int mosbutton);
      /*  ドラッグ処理時に呼び出されるルーチンのオフセットアドレス  */

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>
int    (*addr)(SKB_BOX*、SKB_POINT*、int); 
int     ret;

ret = SKB_getDragFunc(&addr); 

- 内容 -
ドラッグが実行されたときに呼び出される関数のオフセットアドレスを取得します。
関数のセレクタ値はカレントのコードセグメントの値です。
ドラッグ関数についてはSKB_setDragFunc関数を参照してください。

-----------------------------------------------------------------------------
.SKB_getEGBwork
ソフトウェアキーボード用EGBﾜｰｸ領域の取得
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_getEGBwork(int *SKB_EGBwork); 
int     *SKB_EGBwork;
    /*  ソフトウェアキーボード専用EGBワーク領域へのポインタ */ 

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int  ret; 
int  SKB_EGBwork;

ret = SKB_getEGBwork(&SKB_EGBwork); 

- 内容 -
ソフトウェアキーボードが専用で使用しているEGBワーク領域へのポインタを取得しま
す。

-----------------------------------------------------------------------------
.SKB_getRewriteFunc
窓のリライト関数の取得
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_getRewriteFunc(int (**adr)( )); 
int(**adr)(int)     /*  リライト関数先頭アドレス                */
                    /*    NULL     :未登録                      */
                    /*    NULL以外 :リライト関数先頭アドレス    */

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
int     (*SKB_Rewrite)(int);

ret = SKB_getRewriteFunc(&SKB_Rewrite); 

- 内容 -
ソフトウェアキーボードがパターンを書き直したために、画面の退避/復元が必要にな
ったときに呼ばれる関数の先頭アドレスを取得します。
関数が未登録の場合はNULLポインタを返します。

-----------------------------------------------------------------------------
.SKB_getSave 
画面退避領域の取得
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_getSave(int *offset_addr, int *selector); 
int     *offset_addr;  /*   画面退避先のオフセットアドレス */ 
int     *selector;     /*   画面退避先のセレクタ           */ 

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>
int     ret;
int     offset_addr, selector;
ret = SKB_getSave(&offset_addr, &selector); 

- 内容 -
現在設定されている画面退避領域のアドレスを取得します。
設定されていない場合はオフセットアドレスにNULLが戻ります。(セレクタ値は不定)

- 注意 -
SKB_start関数時に画面モードを指定して確保した画面退避領域は、free関数で開放し
ないでください。

-----------------------------------------------------------------------------
.SKB_getSize 
画面退避領域サイズの取得
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_getSize(int *SKB_size, int scrn_mode);
int     *SKB_size;  /*  画面退避に必要なサイズ(byte)         */ 
int     scrn_mode;  /*  画面モード                           */ 
                    /*    SKB_display_mode_16 :16色モード    */ 
                    /*    SKB_display_mode_256:256色モード   */ 
                    /*    SKB_display_mode_32K:32K色モード   */ 

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
int     SKB_size; 
int     scrn_mode;

ret = SKB_getSize(&Size_size, scrn_mode);

- 内容 -
ソフトウェアキーボードの画面退避に必要な領域のサイズを取得します。

- 注意 -
EGBで画面退避領域サイズに使用する場合は、画面退避領域には取得したサイズ+4を
確保してください。

-----------------------------------------------------------------------------
.SKB_getSKBdrag
ドラッグ禁止状態の取得
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_getSKBdrag(int *flag);
int     *flag    /* ドラッグ禁止状態フラグ                    */
                 /*   SKB_drag_liberty:ﾄﾞﾗｯｸﾞ･ﾊﾟﾀｰﾝ変更許可   */
                 /*   SKB_drag_inhibit:ﾄﾞﾗｯｸﾞ･ﾊﾟﾀｰﾝ変更禁止   */

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
int     flag; 

ret = SKB_getSKBdrag(&flag);

- 内容 -
ドラッグ処理および画面パターン変更処理の禁止状態を取得します。

-----------------------------------------------------------------------------
.SKB_getWindow 
窓の表示開始位置の取得
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_getWindow(SKB_POINT *ppt1, SKB_POINT *ppt2);
SKB_POINT ppt1                      /*  窓の左上の座標  */
SKB_POINT ppt2                      /*  窓の右下の座標  */

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
SKB_POINT ppt1; 
SKB_POINT ppt2; 

ret = SKB_getWindow(&ppt1, &ppt2);

- 内容 -
ソフトウェアキーボードの窓の座標を取得します。

-----------------------------------------------------------------------------
.SKB_setDispPos
表示位置の設定
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_setDispPos(SKB_POINT ppt);
SKB_POINT ppt;               /*   表示位置(左上の座標)   */ 

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
SKB_POINT ppt;

ppt.X = 100;
ppt.Y = 100;

ret = SKB_setDispPos(ppt);

- 内容 -
ソフトウェアキーボードの表示位置を設定します。ソフトウェアキーボード表示中は
実行できません。

-----------------------------------------------------------------------------
.SKB_setDragFunc 
ドラッグルーチンの設定
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_setDragFunc(int (*func)()); 
int   (*func)(SKB_BOX *skbpos, SKB_POINT *mospos, int mosbutton);
 /* ドラッグ処理時に呼び出されるルーチンのオフセットアドレス  */

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     DragFunc(SKB_BOX *skbpos, SKB_POINT *mospos, int mosbutton) 
int     ret;

ret = SKB_getDragFunc(DragFunc);

- 内容 -
ドラッグが実行されたときに呼び出す関数を設定します。
設定する関数はNEAR CALLされます。
ドラッグ処理に移行したときには関数の各引数には次の値が設定されています。

  ret = Drag_func( SKB_BOX *skb_pos, SKB_POINT *mos_pos, int button); 

    SKB_BOX   skb_pos : ソフトウェアキーボード矩形座標(ドラッグ前)を格納し
                        た構造体のアドレス
    SKB_POINT mos_pos : 現在のマウスの表示位置を格納した構造体のアドレス
    int mosbutton     : 現在のマウスボタンの状態

また、ドラッグ処理終了時には次の引数の内容を設定しておいてください。ソフトウ
ェアキーボードライブラリは設定された座標に基づいてパターンを移動します。

    SKB_BOX   skb_pos : ソフトウェアキーボード矩形座標(ドラッグ後)を格納した
                        構造体
    ret               : 0(正常終了) 

-----------------------------------------------------------------------------
.SKB_setEGBwork
ソフトウェアキーボード用EGBワーク領域の設定
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_setEGBwork(char *SKB  EGBwork);
char    *SKB_EGBwork;
      /*  ソフトウェアキーボード専用EGBワーク領域へのポインタ */ 

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
char    SKB_EGBwork[1536];

ret = SKB_setEGBwork(SKB_EGBwork);

- 内容 -
ソフトウェアキーボードが専用で使用するEGBワーク領域を設定します。
ソフトウェアキーボードは以降このワーク領域を使用して動作するため、ワーク領域
の内容は変更されてしまいます。
アプリケーション用のEGBワーク領域とは別に確保してください。

- 注意 -
ソフトウェアキーボードは設定されたEGBワーク領域の内容を初期化しません。
設定されたEGBワークの内容に基づいて動作します。
アプリケーション用のEGBワーク領域の内容を、ソフトウェアキーボードに対して設定
するEGBワーク領域に複写しておくと、それまでのアプリケーションの設定状態と同じ
状態にすることができます。

-----------------------------------------------------------------------------
.SKB_setRewriteFunc
窓のリライト関数の設定
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_setRewriteFunc(int(*adr)( )); 
int(*adr)(int)      /*  リライト関数先頭アドレス                */
                    /*     NULL     : 登録しません              */
                    /*     NULL 以外: リライト関数先頭アドレス  */

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
extern int  Rewrite(int); 

ret = SKB_setRewriteFunc(Rewrite);

- 内容 -
ソフトウェアキーボードがパターンを書き直したために、画面の退避/復元が必要にな
ったときに呼ばれる関数の先頭アドレスを設定します。
リライト関数に何も登録しない場合はNULLポインタを設定してください。
標準の状態では何も登録されていません。

- 注意 -
リライト関数は、パターンの更新あるいは移動を行う前と後の2回呼びだされます。
引数には下記の値が設定されています。

RewriteFunc(int mode);

int mode;    /* SKB_drag_befor:ソフトウェアキーボードの画面更新前 */ 
             /* SKB_drag_after:ソフトウェアキーボードの画面更新後 */ 

-----------------------------------------------------------------------------
.SKB_setSave 
画面退避領域の設定
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_setSave(int offset_addr, int selector);
int     offset_addr;  /*  画面退避先のオフセットアドレス値 */ 
int     selector;     /*  画面退避先のセレクタ値           */ 

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
int     Size, mode; 
int     offset_addr;
int     selector; 

ret = SKB_getSize(&Size, mode); 

offset_addr = malloc(Size);
selector = getDS(); 

ret = SKB_setSave(offset_addr, selector);

- 内容 -
画面退避領域のアドレスを設定します。
画面退避領域を設定しない場合には、オフセットアドレスに"0"を設定してください。
画面退避に必要なメモリサイズは、SKB_getSize関数によって取得可能です。

- 注意 -
退避領域に指定するオフセットアドレスは、退避用に確保したオフセットアドレスに4
を加えて設定してください。画面退避領域には、SKB_getSize関数で取得したサイズ+4
バイト分を確保してください。

-----------------------------------------------------------------------------
.SKB_setSKBdrag
ドラッグ禁止状態の設定
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_setSKBdrag(flag); 
int     flag     /* ドラッグ禁止状態フラグ                    */
                 /*   SKB_drag_liberty:ﾄﾞﾗｯｸﾞ･ﾊﾟﾀｰﾝ変更許可   */
                 /*   SKB_drag_inhibit:ﾄﾞﾗｯｸﾞ･ﾊﾟﾀｰﾝ変更禁止   */

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

int     ret;
int     flag; 

flag = 1; 

ret = SKB_setSKBdrag(flag); 

- 内容 -
ドラッグ処理および画面パターン変更処理の禁止状態を設定します。
禁止状態になると、禁止状態が解除に再設定されるかあるいはソフトウェアキーボー
ドが消去されるまで、ドラッグ処理ルーチン及びパターン変更処理ルーチンの呼び出
しを行いません。また、パターン上の消去ボタンでは消去不可となります。

-----------------------------------------------------------------------------
.SKB_start 
ソフトウェアキーボードの初期化
-----------------------------------------------------------------------------

- 定義 -
#include <skb.h>
int     SKB_start(char *EGB_work, int scrn_mode, int color_char,
                    int color_key, int color_bar, int color_base);
char    *EGB_work;   /*   ソフトウェアキーボード専用の
                                       EGBワーク領域へのポインタ */ 
int     scrn_mode;   /*   画面モード                             */ 
int     color_char;  /*   文字色 (色識別番号)                    */ 
int     color_key;   /*   キートップ表示色 (色識別番号)          */ 
int     color_bar;   /*   バー表示色   (色識別番号)              */ 
int     color_base;  /*   ベース表示色 (色識別番号)              */ 

- 戻り値 -
0     :正常終了
0以外 :エラー

- 例 -
#include <skb.h>

char    EGB_work[1536]; 
int     scrn_mode;
int     ret, color_char, color_key, color_bar, color_base;

scrn_mode = SKB_display_mode_16;
color_char = 0; 
color_key = 15; 
color_bar = 9;
color_base = 7; 
ret = SKB_start(EGB_work, scrn_mode , color_char, color_key, 
                                                  color_bar, color_base);

- 内容 -
ソフトウェアキーボードの初期化を実行し、動作可能な状態にします。
ソフトウェアキーボードの使用にあたっては、必ず最初に初期化を行ってください。

画面モード一覧
┌────────────┬──────────────┐
│      設定値            │      画面モード            │
├────────────┼──────────────┤
│SKB_display_mode_16     │16色モード               　 │
│                        │                            │
│SKB_display_mode_256    │256色モード                 │
│                        │                            │
│SKB_display_mode_32k    │32Ｋ色モード                │
│                        │                            │
│SKB_display_mode_non    │画面退避領域なし            │
└────────────┴──────────────┘

画面モード指定値が画面退避領域なし以外の場合は、ライブラリ側が画面退避領域を
malloc関数により確保します。malloc関数による画面退避領域の確保に失敗した場合
は、画面退避領域なしの状態で初期化を行います。

    パターンの表示位置    :画面の左上(x,y) = (0,0) 
    ドラッグ関数のエントリ:ライブラリの標準ルーチン
    リライト関数のエントリ:登録なし
    パターンの表示        :なし
    ドラッグ禁止状態      :なし
    画面退避領域          :画面モード指定値(SKB_display_mode_non以外)の
                           場合、ライブラリ内
                           画面モード指定値(SKB_display_mode_non)の場合、
                           登録なし

- 注意 -
関数の実行時には、すでにEGBおよびマウスが初期化されていなければなりません。
本関数実行後に以下の関数を実行する場合は、SKB_end関数でいったん終了させるか、
SKB_getEGBwork関数で取得されるアドレスにEGBwork関数の内容を転送しなければなり
ません。
  ･EGB_init関数
  ･EGB_resolution関数
  ･EGB_displayPage関数
  ･EGB_writePage関数

2.3 サンプルプログラム

  添付のサンプルプログラムは、ソフトウェアキーボードとかな漢字変換ライブラリ
を使った簡単なサンプルプログラムです。サンプルプログラムのソースファイル名は
、"SKBSMP.C"と"SKBSMP.H"です。同じディレクトリに格納してHigh Cでコンパイルし
てください。サンプルプログラムを実行すると、画面を消去したのち、左上にカーソ
ルが点滅します。この状態で、キーボードからキーを入力するとその内容が画面に表
示されます。マウスの右ボタンをクリックするとソフトウェアキーボードが表示され
ます。ソフトウェアキーボードからの入力が可能になります。
  改行キーを入力すると、サンプルプログラムは、終了します(ソフトウェアキーボー
ドから改行を入力した場合も終了します)。
  このサンプルプログラムの動作概要は、以下のとおりです。

  ┌─────┐
  │キーボード├──┐       入力文字 ┌─→ CRTに表示
  └─────┘    ├────────┤
                    │                └─→ 仮想VRAM
  ┌──────┐  │                         │
  │ソフトウェア├─┘                         │単語登録文字列
  │キーボード  │                             ↓
  └──────┘                           かな漢字変換

  キーボードまたは、ソフトウェアキーボードから文字を入力し、その文字をCRTに
表示し、プログラム内に確保した仮想VRAMに格納します。単語登録時には、仮想VRAM
に記憶された内容から単語登録文字列を取得しています。キーボードまたは、ソフト
ウェアキーボードから入力できます。ソフトウェアキーボードの表示は、マウスによ
って切り換えています。
  実際にプログラミングをするときは、サンプルプログラムで行っている処理の他に
さらに、次の処理を加える必要があります。

 (1)ソフトウェアキーボードの窓に入力できる文字が30文字(半角文字)しかありませ
    ん。システムソフトウェアなどでは、スクロールさせてより多くの文字が入力で
    きるようになっていますが、サンプルプログラムでは配慮してありません。
 (2)カーソルの移動が常に半角単位でしか移動しません。実際のプログラミングでは
    漢字の右半分の位置にカーソルがこないように配慮する必要があります。
 (3)79桁目の位置に漢字を入力すると、左半分しか表示されず、右半分がなくなりま
    す。またこの位置にある漢字は、単語登録できません。実際のプログラミングで
    は、79桁目の位置に漢字がこないようにする配慮が必要です。

┌────────────────────────────────────┐
│  ソフトウェアキーボード  サンプルプログラム                            │
│  ■  機能  ■                                                          │
│    ソフトウェアキーボードを表示し、入力文字を受付けます。              │
└────────────────────────────────────┘
/*
 *
 *      include file for sample program.....
 *
 */

#ifndef     SAMPLE_HEADER

#define     SAMPLE_HEADER

#define         MOUSE_ERASE     0       /* マウスカーソルを消去         */
#define         MOUSE_DISPLAY   1       /* マウスカーソルの表示         */
#define         MOUSE_LEFT      1       /* マウスボタン (左)            */
#define         MOUSE_RIGHT     2       /* マウスボタン (右)            */

#define         COLOR_BLACK     0               /* 黒                   */
#define         COLOR_BULE      1               /* 青                   */
#define         COLOR_RED       2               /* 赤                   */
#define         COLOR_MAGENTA   3               /* 紫                   */
#define         COLOR_GREEN     4               /* 緑                   */
#define         COLOR_CYAN      5               /* 水                   */
#define         COLOR_YELLOW    6               /* 黄                   */
#define         COLOR_WHITE     7               /* 白                   */
#define         COLOR_INTENSITY    8               /*  高輝度           */
#define         COLOR_INTENSITY_BLACK      8       /* 黒 (高輝度)       */
#define         COLOR_INTENSITY_BULE       9       /* 青 (高輝度)       */
#define         COLOR_INTENSITY_RED        10      /* 赤 (高輝度)       */
#define         COLOR_INTENSITY_MAGENTA    11      /* 紫 (高輝度)       */
#define         COLOR_INTENSITY_GREEN      12      /* 緑 (高輝度)       */
#define         COLOR_INTENSITY_CYAN       13      /* 水 (高輝度)       */
#define         COLOR_INTENSITY_YELLOW     14      /* 黄 (高輝度)       */
#define         COLOR_INTENSITY_WHITE      15      /* 白 (高輝度)       */

#define         FOREGRAND_COLOR 0       /* 前景色                       */
#define         BACKGRAND_COLOR 1       /* 背景色                       */
#define         PAINT_COLOR     2       /* 面塗り色                     */

#define         WRITEMODE_PSET  0       /* PSET モード                  */
#define         WRITEMODE_PRESET    1   /* PRESET モード                */
#define         WRITEMODE_OR    2       /* OR モード                    */
#define         WRITEMODE_AND   3       /* AND モード                   */
#define         WRITEMODE_XOR   4       /* XOR モード                   */
#define         WRITEMODE_EOR   4       /* XOR モード                   */

#define         NOWAIT_VSYNC    0       /* V-SYNC 待ちなし              */
#define         WAIT_VSYNC      1       /* V-SYNC 待ち                  */

#define         SIZE_CHAR_X     8       /* 文字の大きさ (X軸)           */
#define         SIZE_CHAR_Y     16      /* 文字の大きさ (Y軸)           */
#define         CHAR_NULL       0       /* 終端文字                     */
#define         CHAR_BS         8       /* Back space                   */
#define         CHAR_LF         10      /* LINE FEED文字                */
#define         CHAR_CR         13      /* 改行文字                     */
#define         CHAR_RIGHT_ARROW    28  /* 右矢印                       */
#define         CHAR_LEFT_ARROW 29      /* 左矢印                       */
#define         CHAR_UP_ARROW   30      /* 上矢印                       */
#define         CHAR_DOWN_ARROW 31      /* 下矢印                       */
#define         CHAR_CR         13      /* 改行文字                     */
#define         CHAR_DEL        127     /* DELETE文字                   */
#define         CHAR_UNAVAILABLE    255 /* 無効な文字                   */

#define         CHAR_MAX_X      80      /* 画面上の最大桁数             */
#define         CHAR_MAX_Y      25      /* 画面上の最大行数             */
#define         CHAR_MAX        2000    /* 画面上の最大文字数           */

#define         SKB_BUF_SIZE    31      /* 窓のバッファサイズ           */

#define         MAX_CURSOR_COUNT    300

typedef     short           int16;      /* 16bit長整数の定義            */
typedef     int             int32;      /* 32bit長整数の定義            */
typedef     unsigned short  u_int16;    /* 16bit長符号なし整数の定義    */
typedef     unsigned int    u_int32;    /* 32bit長符号なし整数の定義    */

#endif

  /************************************************************************
   *  ソフトウェアキーボード  サンプルプログラム
   *
   *----------------------------------------------------------------------
   * Comments:
   *   このサンプルプログラム中の TAB SIZE は 4 になっています
   *   エディタなどの TAB SIZE の設定を 4 にして参照してください
   *
   *   このサンプルプログラムには専用のヘッダファイルがあります
   *   必ずインクルードしてください
   */
  /************************************************************************
  *
  *       ヘッダファイルをインクルードします
  *
  ************************************************************************/
  #include <stdio.h>                      /* C の標準入出力ライブラリ     */
  #include <stdlib.h>
  #include <string.h>

  #include <FMCFRB.H>                     /* FM/C 関数ライブラリ          */
  #include <EGB.H>                        /* EGBのインクルードファイル    */
  #include <MOS.H>                        /* Mouse                        */
  #include <SKB.H>                        /* ソフトウェアキーボード用     */
  #include <KKSTR2.H>                     /* かな漢字変換ライブラリ       */

  #include "skbsmp.h"                     /* サンプルプログラム用 ヘッダ  */
  /************************************************************************
   *
   *      マクロを定義します
   *
   ************************************************************************/
  #ifndef iskanji 
  #define iskanji(c)(0x81 <=c && c<= 0xff‖0xe0 <=c && c<= 0xfc) 
  #endif
  #ifndef TRUE
  #define      TRUE            1        /* 真                             */
  #define      FALSE           0        /* 偽                             */
  #endif
  #ifndef normal
  #define      normal          0        /* 正常終了                       */
  #define      abnormal        1        /* 異常終了                       */
  #endif

  #define     KAN_display         1       /* かな漢の表示                 */
  #define     KAN_erase           0       /* かな漢の停止                 */

  /************************************************************************
  *
  *       内部関数のプロットタイプ宣言
  *
  *************************************************************************/
  int     rewrite( int );                 /* SKBの書き換え時の実行関数    */

  int     display_init();                 /* EGB/MOSの初期化実行関数      */
  int     SKB_init();                     /* SKBの初期化の実行関数        */
  void    get_cursor( int*, int* );       /* かな漢未確定文字 表示位置取得*/
  void    get_strings( char* );           /* 表示文字列 取得関数          */
  int     Kana_init();                    /* かな漢 Lib 初期化関数        */
  int     SKB_terminate();                /* SKBの終了関数                */
  int     SKB_main();                     /* SKB実行時のメイン関数        */
  int     print( int );                   /* 1文字表示関数                */
  int     disp_cursor( int, int  );       /* カーソルを反転させます       */

  /************************************************************************
   *
   *      グローバル変数
   *
   ************************************************************************/
  /****************************************************
   * アプリケーション自体が使用する EGBとマウスの
   * ワーク領域をグローバル領域に確保します
   ****************************************************/
  char  EGB_work[EgbWorkSize];            /* アプリケーション用 EGB_work  */
  char  MOS_work[MosWorkSize];            /* マウス用のワーク領域         */

  /****************************************************
   * ソフトウェアキーボードのために、EGBのワーク領域
   * の複写を格納しておくための領域をグローバル領域に
   * 確保します
   ****************************************************/
  char  SKB_EGB_work[EgbWorkSize];        /* ソフトウェアキーボード用     */

  /****************************************************
   * ソフトウェアキーボードが表示されたときに その座標
   * を格納するための領域を確保します
   ****************************************************/
  SKB_POINT ppt1, ppt2;                   /*  SKBの座標格納用             */

  /****************************************************
   * ソフトウェアキーボードが表示されたときに その窓に
   * 格納される文字列を格納する領域を確保します
   ****************************************************/
  char    SKB_buffer[SKB_BUF_SIZE];       /* SKB動作時のバッファ          */

  /****************************************************
   * ソフトウェアキーボードが表示されたときに その窓の
   * 中に表示されるカーソル点滅の制御用変数領域を確保し
   * ます
   ****************************************************/
  int     SKB_cursor_flag;                /* カーソルの反転状態           */
  int     SKB_cursor_count;               /* カーソルカウンタ             */
  int     skb_pos_x, skb_pos_y;           /* SKB表示中のときのカーソル位置*/

  /****************************************************
   * EGBに対して描画するときに使用すべきパレット番号
   * を格納する変数領域を確保します
   ****************************************************/
  int     color_foregrand;                /* 前景色を保持します           */
  int     color_backgrand;                /* 背景色を保持します           */
  int     color_exclusive;                /* 反転に使う色                 */

  /****************************************************
   * 画面に文字を出力するときに出力すべきキャラクタ
   * 座標を格納する変数領域を確保します
   ****************************************************/
  int     x, y;                           /* 画面に表示する文字位置       */

  /****************************************************
   * 画面に表示されている文字列を格納するための領域
   * を確保します
   * この領域は仮想テキストVRAMとして用い、単語登録
   * を行うときに参照されます
   ****************************************************/
  char        vram[CHAR_MAX];             /* 80*25 の文字列格納用         */

  /****************************************************
   * プログラムのガイダンス表示に使うデータを
   * 定義します
   ****************************************************/
  char        *guidance[] = {
          "このプログラムはキーボードから入力された文字を画面に表示します",
          "このプログラムは改行キーが入力されると終了します",
          "マウスを右クリックするとソフトウェアキーボードが表示されます",
          ""
          };

  /************************************************************************
   *
   *      EGB / MOS 初期化ルーチン
   *
   *-----------------------------------------------------------------------
   *
   *      INPUT  : ( void )           なし
   *
   *      OUTPUT : normal             正常終了
   *             : abnormal           異常終了
   *
   *
   ***********************************************************************/
  int display_init()
  {

  /****************************************************
   * パレットを設定するときに使う変数領域を確保します
   ****************************************************/
      int32   palette, offset;            /* パレット設定用               */
      int     i;

  /****************************************************
   * EGBに渡すパラメータを格納する領域を確保します
   ****************************************************/
      char    para[16];

  /****************************************************
   * EGBに初期化のファンクションを発行し、初期化を
   * 実行します
   ****************************************************/
      EGB_init( EGB_work, EgbWorkSize );      /* EGBの初期化              */

  /****************************************************
   * レイヤ0 と レイヤ1 の画面モードを設定します
   * 設定する画面モードは 3 (16色 640*480 モード)
   ****************************************************/
      EGB_resolution( EGB_work, 0, 3 );       /* ページ 0 の画面モード    */
      EGB_resolution( EGB_work, 1, 3 );       /* ページ 1 の画面モード    */

  /****************************************************
   * 書き込みを実行するレイヤを指定します
   * このプログラムでは レイヤ0 を指定します
   ****************************************************/
      EGB_writePage( EGB_work, 0 );           /* 書き込みページの指定     */

  /****************************************************
   * CRTに表示するレイヤを指定します
   * このプログラムでは レイヤ0 レイヤ1 の両方を
   * 指定します  また重ね合わせの優先順位は、レイ
   * ヤ 1 を優先にします( TownsMENU と同じ設定 )
   ****************************************************/
      EGB_displayPage( EGB_work, 1, 3);       /* 表示ページを指定         */

  /****************************************************
   * マウスドライバ に初期化のファンクションを発行し、
   * 初期化を実行します
   ****************************************************/
      MOS_start( MOS_work, MosWorkSize );     /* マウスの初期化           */

  /****************************************************
   * マウスカーソルを消去状態に設定します
   ****************************************************/
      MOS_disp( MOUSE_ERASE );                /* マウスの消去の指定       */

  /****************************************************
   * パレット番号 1 〜 15 までに対し 初期のパレットを
   * 設定します
   * 設定するパレットの状態は以下のとおりです
   *
   *   パレット          パレット
   *       番号  表示色      番号   表示色
   *   --------  ------  --------   ------------
   *         0      黒         8     黒(高輝度)
   *         1      青         9     青(高輝度)
   *         2      赤        10     赤(高輝度)
   *         3      紫        11     紫(高輝度)
   *         4      緑        12     緑(高輝度)
   *         5      水        13     水(高輝度)
   *         6      黄        14     黄(高輝度)
   *         7      白        15     白(高輝度)
   *
   ****************************************************/

      for ( palette = 1; palette < 16; palette++ ) {

          /***********************************************/ 
          /* 高輝度の設定なら色情報を 127 offset します
          /***********************************************/
          offset = ( palette & COLOR_INTENSITY ) ? 127 : 0;

          /*********************************************/
          /* EGBに渡すパラメータを設定します
          /*********************************************/
          DWORD(para + 0 ) = 1;
          DWORD(para + 4 ) = palette;
          BYTE(para + 8 )  = ((palette & COLOR_BULE ) ? 128 + offset : 0);
          BYTE(para + 9 )  = ((palette & COLOR_RED  ) ? 128 + offset : 0);
          BYTE(para + 10 ) = ((palette & COLOR_GREEN) ? 128 + offset : 0);
          BYTE(para + 11 ) = 0;

          /*********************************************/
          /* EGBパレット情報を渡し、設定します
          /*********************************************/
          EGB_palette( EGB_work, NOWAIT_VSYNC, para );
      }

  /*********************************************
   * 8番のパレットのみ再設定します
   *********************************************/
      DWORD(para + 0 ) = 1;                   /* 8番のパレットのみ再設定  */
      DWORD(para + 4 ) = 8;

      BYTE(para + 8 )  = 64;  BYTE(para + 9 )  = 64;
      BYTE(para + 10 ) = 64;  BYTE(para + 11 ) = 0;

      EGB_palette( EGB_work, NOWAIT_VSYNC, para );

  /**********************************************
   * 画面全体を白色で描画します
   **********************************************/

  /*********************************************
   * EGBに対して、前景色と面塗り色に使う色を指
   * 定します ( 指定する色は、アプリの背景色 )
   *********************************************/
      EGB_color( EGB_work, FOREGRAND_COLOR, color_backgrand );
      EGB_color( EGB_work, PAINT_COLOR, color_backgrand );

  /*********************************************
   * EGBに対して、描画モードとペイントモード
   * を指定します
   *********************************************/
      EGB_writeMode( EGB_work, WRITEMODE_PSET );  /* 描画モードを PSET */
      EGB_paintMode( EGB_work, 0x22 );        /* ペイントモードを設定  */

  /*********************************************
   * 描画の対象とする画面の座標値を設定します
   *********************************************/
      WORD(para + 0 ) = 0;    WORD(para + 2 ) = 0;
      WORD(para + 4 ) = 639;  WORD(para + 6 ) = 479;

  /*********************************************
   * EGBに描画のリクエストを発行します
   *********************************************/
      EGB_rectangle( EGB_work, para );
                   /* 画面全体を 白で埋めます  */

  /*********************************************
   * 文字を描画する座標を左上に設定します
   *********************************************/
      x = 0;      y = 0;
                   /* 表示開始座標を設定       */

  /*********************************************
   * 仮想VRAMの内容を初期化します
   * 初期状態では、 '\0' で埋めます
   *********************************************/
      for ( i = 0; i < ( CHAR_MAX - 1 ); i++ )
          vram[i] = '\0';
  /*********************************************
   * 画面の下部にガイダンスを表示する関数を
   * 呼び出します
   *********************************************/
      print_guidance();
                   /* ガイダンスの表示         */
  /*********************************************
   * 画面の初期化を正常終了し、呼び出し元に復帰
   * します
   *********************************************/
      return( normal );

  }

  /************************************************************************
   *
   *      画面の下にガイダンスを表示する関数
   *
   *-----------------------------------------------------------------------
   *
   *      INPUT  : ( void )           なし
   *
   *      OUTPUT : normal             正常終了
   *             : abnormal           異常終了
   *
   *
   ***********************************************************************/
  print_guidance()
  {
      /*******************************************
       * EGBに渡すパラメータを格納するための領域です
       *******************************************/
      char para[128];

      /*******************************************
       * ループ制御変数です
       *******************************************/
      int     i;

      /*******************************************
       * ガイダンスを描画する文字色を設定します
       *******************************************/
      EGB_color( EGB_work, FOREGRAND_COLOR, color_foregrand );

      /*******************************************
       * カウンタの変数を初期化します
       *******************************************/
      i = 0;

      /*******************************************
       * 表示するX軸上の座標を設定します
       *******************************************/
      WORD( para + 0 ) = 20;

      /*******************************************
       * 用意されている行数分のMSGを表示します
       *******************************************/
      while( *guidance[i] ) {

          /************************************************
           * Y軸上の座標を決定し、 文字列の長さと文字列
           * 本体を para[] に設定し、EGB を呼び出します
           ************************************************/
          WORD( para + 2 ) = 420 + 20 * i;    /* Y軸方向の座標を計算  */
          WORD( para + 4 ) = strlen( guidance[i] );
          strcpy( &para[6], guidance[i] );
          EGB_sjisString( EGB_work, para );
          i++;
      }

      return( normal );

  }
  /************************************************************************
   *
   *      ソフトウェアキーボード関連の初期化ルーチン
   *
   *-----------------------------------------------------------------------
   *
   *      INPUT  : ( void )           なし
   *
   *      OUTPUT : normal             正常終了
   *             : abnormal           異常終了
   *
   ************************************************************************/
  int SKB_init()
  {
      int  scrn_mode, color_char, color_key, color_bar, color_base;
      int  ret;

  /*************************************************
   * EGBで初期化されたワーク領域をSKBのEGBワーク
   * 領域に対して複写します
   *************************************************/
      memcpy( SKB_EGB_work, EGB_work, EgbWorkSize );  /* ワーク領域の複写  */

  /*************************************************
   * ソフトウェアキーボードの動作モード、および
   * 表示に使うパレット番号を指定します
   *************************************************/
      scrn_mode  = SKB_display_mode_16;      /* 画面退避モードの指定   */
      color_char = COLOR_BLACK;              /* キーの文字色           */
      color_key  = COLOR_INTENSITY_WHITE;    /* キートップの色         */
      color_bar  = COLOR_BULE;               /* バーの表示色           */
      color_base = COLOR_INTENSITY_BLACK;    /* 本体ベースの表示色     */

  /*************************************************
   * ソフトウェアキーボードを初期化し、使用可能な
   * 状態にします
   *************************************************/
      if ( SKB_no_error == ( ret = SKB_start(
              SKB_EGB_work, scrn_mode, color_char, color_key, color_bar,
                   color_base )) )        /* 初期化を実行            */

      {                                   /* 正常に初期化できた場合  */
  /*************************************************
   * 以下は 正常に初期化された場合に実行します
   *
   * ドラッグなどによってソフトウェアキーボードの表
   * 示位置が変更されたときに、呼び出される関数のエ
   * ントリアドレスを設定します
   *************************************************/
          SKB_setRewriteFunc( rewrite );  /* リライト関数を設定します */

  /*************************************************
   * ソフトウェアキーボードが最初に表示されたときに、
   * 画面の中央に来るように表示位置を設定します
   * この設定は必ずしも必要ではありません
   * 表示位置を指定しなかった場合は、画面の左上に表
   * 示されます
   *************************************************/
          ppt1.X = 185;             /* 最初に表示する X 軸の位置    */
          ppt1.Y = 134;             /* 最初に表示する Y 軸の位置    */
          SKB_setDispPos( ppt1 );   /* 初期の表示位置の設定         */

}
      return( ret );
  }
  /************************************************************************
   *
   *      かな漢表示座標取得ルーチン
   *
   *-----------------------------------------------------------------------
   *
   *      INPUT  : ( void )           入力情報なし
   *
   *      OUTPUT : int  *cur_x        表示座標 ( グラフィック X軸 )
   *             : int  *cur_y        表示座標 ( グラフィック Y軸 )
   *
   *
   ************************************************************************/
  void get_cursor( int *cur_x, int *cur_y )
  {
      int     flag;

      SKB_getDisp( &flag );              /* SKBが表示されているか    */

      if ( flag == SKB_display ) {
                                         /* SKBのカーソル座標を取得  */
          /****************************************
           * ソフトウェアキーボードが表示されてい
           * るときは、窓の中の座標を返します
           ****************************************/
          *cur_x = skb_pos_x * SIZE_CHAR_X + ppt1.X + 2;
          *cur_y = (ppt2.Y - ppt1.Y - SIZE_CHAR_Y)/2 + ppt1.Y;

      }
      else {
                                          /* 表示中のカーソル座標     */
          /****************************************
           * 現在のカーソルの座標を返します
           ****************************************/
          *cur_x = x * SIZE_CHAR_X;
          *cur_y =  y * SIZE_CHAR_Y;
      }

      return;
  }
  /************************************************************************
   *
   *      かな漢表示文字列取得ルーチン
   *
   *-----------------------------------------------------------------------
   *
   *      INPUT  : ( void )           入力情報なし
   *      OUTPUT : *string            現在の座標から80文字分の文字データ
   *
   ************************************************************************/
  void get_strings( char *string )
  {
      int     offset, i, flag;

      /***********************************************
       * まず ソフトウェアキーボードが表示されている
       * か判定し､ かな漢に返す文字列の取得元を決めま
       * す  表示中ならソフトウェアキーボードの窓から
       * 取得し､ 表示されていなければ仮想VRAMから取得
       * します
       ***********************************************/

      SKB_getDisp( &flag );       /* SKB の表示フラグを取得します     */

      if ( flag == SKB_display ) {
      /************************************************
       * ソフトウェアキーボードが表示されている場合、
       * 窓の中のカーソルの位置から文字データを複写
       * します
       * 80文字に足りない分は '\0' を設定します
       ************************************************/
          for ( i = skb_pos_x; i < SKB_BUF_SIZE; i++ )
              *string++ = SKB_buffer[i];
          for ( i = 0; i < ( 80 - ( SKB_BUF_SIZE - skb_pos_x ) ); i++ )
              *string++ = '\0';
      }
      else {

          /************************************************
           * ソフトウェアキーボードが表示されていない場合、
           * 仮想VRAMのカーソルの位置から文字データを複写
           * します
           ************************************************/
          offset = x + y * CHAR_MAX_X;

          if ( offset > ( CHAR_MAX - 81 ) ) {
              for ( i = offset; i <= (CHAR_MAX - 1 ); i++ )
                  *string++ = vram[i];
              for ( i = 0; i <= ( CHAR_MAX + 80 - offset ); i++ )
                  *string++ = vram[i];
          }
          else{
              memcpy( string, &vram[offset], 80 );
          }
      }
      return;
  }

  /************************************************************************
   *
   *      かな漢関連の初期化ルーチン
   *
   *-----------------------------------------------------------------------
   *
   *      INPUT  : ( void )           入力情報なし
   *
   *
   *
   ************************************************************************/

  int Kana_init()
  {

      /************************************************
       * かな漢を初期化します   詳細はかな漢の解説を
       * 参照してください
       ************************************************/
      int     colour_tbl[16] = {
                  15, 1,  2,  3,  4,  5,  6, 7,
                   8, 9, 10, 11, 12,  0,  0, 0 };

      KANJ    kana;

      kana.scrn = 0;                 /* 16色モード                   */
      kana.egbw = EGB_work;          /* EGBワーク                    */
      kana.gets = get_strings;       /* 単語登録文字列取得関数       */
      kana.getPos = get_cursor;      /* かな漢文字列表示座標取得関数 */
      kana.wPage = 0;                /* 書き込みページ番号の設定     */
      kana.mosAp = 1;                /* マウスの制御を実行します     */
      kana.maxX = 639;               /* 最大のグラフィック座標       */
      kana.maxY = 479;

      if ( !KAN_prepare( &kana ) )        /* かな漢を初期化します    */
          KAN_setClrTbl( colour_tbl );    /* 色テーブルを設定します  */

      return( normal );
  }

  /************************************************************************
   *
   *      SKBの終了ルーチン
   *
   *-----------------------------------------------------------------------
   *
   *      INPUT  : ( void )           入力情報なし
   *
   *
   *
   ************************************************************************/
  int SKB_terminate()
  {

      return( SKB_end() );

  }

  /************************************************************************
   *
   *      ソフトウェアキーボードを表示しているときに実行する関数
   *
   *
   *   このサンプルプログラムでは、ソフトウェアキーボードを表示している間
   *   この関数の中を実行します
   *
   ************************************************************************/
  int SKB_main()
  {

      char para[16];                      /* EGBとのデータ通信用       */
      char string[64];                    /* SKB終了処理時のワーク     */ 

      int     i, flag, enter_flag;
      unsigned int moji, encode;

      /********************************************
       * ソフトウェアキーボードの窓の内容を初期化
       * し、未入力の状態に設定します
       ********************************************/
      for ( i = 0; i < SKB_BUF_SIZE; i ++ )
                                         /* SKBの入力バッファ初期化    */
          SKB_buffer[i] = '\0';

      skb_pos_x = 0;
      enter_flag = FALSE;

      /********************************************
       * ソフトウェアキーボードの窓の表示座標を取
       * 得し、入力中の文字を表示する座標を決定し
       * ます
       ********************************************/
      SKB_getWindow( &ppt1, &ppt2 );
                                     /* SKBの窓がある位置を取得します  */

/********************************************
 * ソフトウェアキーボードを表示させて、ソフ
 * トウェアキーボードを有効にします
 ********************************************/
SKB_disp( SKB_display );       /* SKBを画面に表示します          */

/********************************************
 * ソフトウェアキーボードの窓の中に表示する
 * カーソルの Y 軸座標の計算および、カーソル
 * 制御変数を初期化します
 ********************************************/
skb_pos_y = (ppt2.Y - ppt1.Y - SIZE_CHAR_Y)/2 + ppt1.Y + SIZE_CHAR_Y;
SKB_cursor_flag = FALSE;

/********************************************
 * 以下 ソフトウェアキーボードが表示されて
 * いる間 実行します
 ********************************************/
  do {

      /*******************************************
       * 画面に未確定文字列があるか判定します
       *******************************************/
      if ( KAN_impchk() )
          SKB_setSKBdrag( SKB_drag_inhibit );
      else
          SKB_setSKBdrag( SKB_drag_liberty );

      /********************************************
       * キーボードBIOSから入力文字を読み込みます
       * 文字がない場合、0xffff を読み込みます
       *******************************************/
      moji = ( KYB_read( 1, &encode ) & 0xff);

      /********************************************
       * カーソルの点滅制御をします
       * カウンタが一定のカウント値に達した場合、
       * カーソルの状態を反転し、カウンタをリセッ
       * トします
       *******************************************/
        if ( SKB_cursor_count++ == MAX_CURSOR_COUNT ) {
            disp_cursor( skb_pos_x * SIZE_CHAR_X + ppt1.X + 2, skb_pos_y );
            SKB_cursor_flag = !SKB_cursor_flag;
            SKB_cursor_count = 0;
        }

        /********************************************
         * キーボード BIOS から有効な文字が読み込めた
         * か判定し、ある場合はその処理をします
         *******************************************/
        if( moji != CHAR_UNAVAILABLE ) {    /* 有効な文字があったとき */

      /********************************************
       * 入力文字があるならカーソルを消去します
       *******************************************/
      if ( SKB_cursor_flag ) {        /* カーソルを消去します   */
          disp_cursor( skb_pos_x * SIZE_CHAR_X + ppt1.X + 2, skb_pos_y );
          SKB_cursor_flag = FALSE;
          SKB_cursor_count = 0;
      }

      /********************************************
       * 読み込んだ文字がシフトJISの第一バイト目
       * ならば、第二バイト目があるのでそれを読み
       * 込みます
       ********************************************/
      if ( iskanji( moji ) ) {
          moji = ( moji << 8 ) + ( KYB_read( 0, &encode ) & 0x0ff );

      }
      /********************************************
       * 読み込んだ文字を表示します
       * 制御文字なら 制御文字の処理をします
       ********************************************/
      if ( moji < ' ' ) {/* (SP) より小さいなら制御文字  */
                         /* 注) これは ASCIIコードを採用
                                している場合             */
          switch ( moji ) {
              case CHAR_BS:           /* 後退キー        */
              case CHAR_LEFT_ARROW:   /* 左矢印キー      */
                  if ( skb_pos_x-- == 0 ) {
                       skb_pos_x = 0;
                  }
                  break;
              case CHAR_RIGHT_ARROW:  /* 右矢印キー      */
                  if ( ( SKB_BUF_SIZE - 1 ) == ( ++skb_pos_x ) ) {
                      skb_pos_x = SKB_BUF_SIZE -2;
                  }
                  break;
              case CHAR_CR:           /* 改行キー        */
                  SKB_disp( SKB_erase );
                  enter_flag = TRUE;
                  break;
              case CHAR_DEL:          /* 削除キー        */
              case CHAR_UP_ARROW:     /* 上矢印キー      */
              case CHAR_DOWN_ARROW:   /* 下矢印キー      */
                  break;              /* キーを無視します*/
              default:
                  break;              /* キーを無視します*/
          }
      }
      else {
          if ( skb_pos_x < ( SKB_BUF_SIZE - 1 ) ) {
              MOS_disp( MOUSE_ERASE ); /* マウスカーソルを消去 */

              /************************************************
               *
               * カーソル位置の文字を消去します
               *
               ************************************************/
              WORD( para ) = skb_pos_x * SIZE_CHAR_X + ppt1.X + 2;
              WORD( para+2 ) = skb_pos_y - SIZE_CHAR_Y +1;
              WORD( para+6 ) = skb_pos_y;

              /*************************************************
               * 1バイト文字と 2バイト文字の場合で消去する範囲
               * が異なります
               *************************************************/
              if ( moji > 255 ) {
                  WORD( para+4 ) = (skb_pos_x+2) * SIZE_CHAR_X +
                                                      ppt1.X + 1;
              }
              else {
                  WORD( para+4 ) = (skb_pos_x+1) * SIZE_CHAR_X +
                                                      ppt1.X + 1;
              }

              EGB_writeMode( EGB_work, WRITEMODE_PSET );
              EGB_color( EGB_work, FOREGRAND_COLOR,
                                              color_backgrand);
              EGB_color( EGB_work, PAINT_COLOR, color_backgrand);
              EGB_rectangle( EGB_work, para );

              /************************************************
               *
               * カーソル位置に文字を表示します
               *
               ************************************************/
              EGB_color( EGB_work, FOREGRAND_COLOR,
                                              color_foregrand);
              WORD( para ) = skb_pos_x * SIZE_CHAR_X + ppt1.X + 2;
              WORD( para+2 ) = skb_pos_y;

              /************************************************
               * 1バイト文字と 2バイト文字では、 データの格納
               * 方法が異なります
               ************************************************/
              if ( moji > 255 ) {
                  WORD( para+4 ) = 2;
                  BYTE( para+6 ) = (unsigned char) ( moji >> 8 );
                  BYTE( para+7 ) = (unsigned char) ( moji & 0x0ff );
              }
              else {
                  WORD( para+4 ) = 1;
                  BYTE( para+6 ) = moji;
              }

              EGB_sjisString( EGB_work, para );

                    /************************************************
                     *
                     * 入力された文字をバッファに入れます
                     *
                     ************************************************/
                    if ( moji > 255 ) {
                        BYTE( SKB_buffer + ( skb_pos_x ) ) =
                                                    (char) ( moji >> 8 );
                        skb_pos_x++;
                        BYTE( SKB_buffer + ( skb_pos_x ) ) =
                                                 (char) ( moji & 0x0ff );
                        skb_pos_x++;
                    }
                    else {
                        BYTE( SKB_buffer+(skb_pos_x) ) = (char) moji;
                        skb_pos_x++;
                    }
                    MOS_disp( MOUSE_DISPLAY );
                }
            }
        }
        SKB_getDisp( &flag );      /* SKBが表示されているか判定    */
    }while( flag == SKB_display ); /* SKBが表示中なら繰り返します  */

    /****************************************************************
     *  改行キーの入力で終了したなら改行キーを付加します
     ****************************************************************/
    if ( TRUE == enter_flag ) {
        SKB_buffer[skb_pos_x++] = CHAR_CR;
    }

    /****************************************************************
     *  SKBの窓の文字列を KEYBOARD BIOS のバッファに追加します
     ****************************************************************/
    if ( skb_pos_x ) {              /* バッファに文字がある場合     */
        for( i = 0; i <= skb_pos_x; i++) {
            WORD( string+i*2 ) = (unsigned short int) SKB_buffer[i];
        }

        /****************************************************************
         *  KEYBOARD BIOS のバッファに文字を追加します
         ****************************************************************/
        KYB_addstr( 1, skb_pos_x, (unsigned short int *) string );
    }

    /****************************************************************
     *  リライト関数で かな漢を停止させているので、 再スタートさせます
     ****************************************************************/
    KAN_disp( KAN_display );

    return( normal );
}

/************************************************************************
 *
 *      ソフトウェアキーボードが移動するときに呼ばれる関数
 *
 *-----------------------------------------------------------------------
 *
 *      INPUT  : int    flag;       モード
 *
 *      OUTPUT : (void)
 *
 *************************************************************************/
int rewrite( int flag )
{

    char    para[64];
    short   i;

    /*********************************************
     * マウスカーソルを消去します
     *********************************************/
    MOS_disp( MOUSE_ERASE );        /* マウスカーソルを消去   */

    /*******************************************
     * 呼び出されたモードを判定します
     *******************************************/
    if ( flag == SKB_drag_before ) {    /* 移動前             */

        /*****************************************
         * SKBの移動前で呼び出されます
         * 窓の中のカーソルを消去し、かな漢システ
         * ムを停止させます
         *****************************************/
        KAN_disp( KAN_erase );     /* かな漢の表示を停止します     */

        if ( SKB_cursor_flag ) {   /* カーソルが表示中なら消去します */
            disp_cursor( skb_pos_x * SIZE_CHAR_X + ppt1.X + 2, skb_pos_y );
            SKB_cursor_flag = FALSE;
            SKB_cursor_count = 0;
        }
    }
    else {                         /* 移動後の処理                 */
        /*****************************************
         * SKBの移動後で呼び出されました
         * 新しい窓の位置を取得し、入力中だった文
         * 字列を再表示させます
         * かな漢システムを再開させます
         *****************************************/
        SKB_getWindow( &ppt1, &ppt2 );  /* 新しい 窓の位置を取得します */
        skb_pos_y = (ppt2.Y - ppt1.Y - SIZE_CHAR_Y)/2 + ppt1.Y +
                                                            SIZE_CHAR_Y;
        if ( skb_pos_x ) {              /* 入力中の文字を再表示します*/
            WORD( para )   = ppt1.X + 2;
            WORD( para+2 ) = skb_pos_y;
            WORD( para+4 ) = skb_pos_x;
            for ( i = 0; i < skb_pos_x; i++ ) {

                para[6+i] = SKB_buffer[i];
            }
            EGB_writeMode( EGB_work, WRITEMODE_PSET );
            EGB_color( EGB_work, FOREGRAND_COLOR, color_foregrand );
            EGB_sjisString( EGB_work, para );
        }

        KAN_disp( KAN_display );        /* かな漢の表示を再開します  */

    }

    /***********************************************
     * 処理が終了したらマウスカーソルを表示します
     ***********************************************/
    MOS_disp( MOUSE_DISPLAY );          /* マウスカーソルを表示します*/
    return( normal );
}

/************************************************************************
 *
 *      画面に1文字を出力する関数
 *
 *-----------------------------------------------------------------------
 *
 *      INPUT  : char string;       出力する文字
 *
 *      OUTPUT : (void)
 *
 *      GLOBAL VARIABLE :   x,  y   出力する画面の座標
 *
 ************************************************************************/
int print( int string )
{

char    para[16];                  /* EGBに渡すパタメータ格納用      */
int     print_x, print_y;          /* 出力するグラフィック座標       */
int     offset;

    if ( string < ' ' ) {
        switch( string ) {
            case CHAR_BS:          /* BSの場合 カーソルを戻します    */
                if ( x != 0 ) {    /* カーソルが左端でない場合       */
                    x--;           /* 左へ移動                       */
                }
                else {
                    x = CHAR_MAX_X -1 ; /* カーソルを右端に移動      */
                    if ( y != 0 ) {     /* カーソルを1行上に移動     */
                        y--;
                    }
                }
                break;             /* 処理終了                       */

            case CHAR_CR:          /* 改行キー                       */
                x = 0;             /* 無条件に左端に設定             */
                break;

            case CHAR_LF:          /* フィードキー                   */
                y++;
                if ( y == CHAR_MAX_Y ) { /* 一番下の行位置なら       */
                    y = 0;               /* 一番上の行に移動         */
                }
                break;

            case CHAR_DEL:               /*  削除キー                */
                break;

            case CHAR_RIGHT_ARROW:       /*  右矢印キー              */
                x++;
                if ( x == CHAR_MAX_X ) { /* 右端を越えたら           */
                    x = 0;               /* カーソルを左端に移して   */
                    y++;                 /* 1行下に移動              */
                    if ( y == CHAR_MAX_Y ) { /* 下端を越えたら       */
                        y = 0;               /* 上端に移動           */
                    }
                }
                break;

            case CHAR_LEFT_ARROW:            /* 左矢印キー           */
                x--;
                if ( x == -1 ) {             /* 左端を越えたら       */
                    x = CHAR_MAX_X -1;       /* 右端に移動           */
                    y--;                     /* 1行上に移動          */
                    if ( y == -1 ) {         /* 上端を越えたら       */
                        y = 0;               /* 上端に固定           */
                    }
                }
                break;

            case CHAR_UP_ARROW:              /* 上矢印キー           */
                y--;
                if ( y == -1 ) {             /* 上端を越えたら       */
                    y = 0;                   /* 上端に固定           */
                }
                break;

            case CHAR_DOWN_ARROW:            /* 下矢印キー           */
                y++;
                if ( y == CHAR_MAX_Y ) {     /* 下端を越えたら       */
                    y = 0;                   /* 上単に固定           */
                }
                break;
            default:                    /* それ以外のキーは無処理    */
                break;
        }
    }
    else {

        MOS_disp( MOUSE_ERASE );        /* まず マウスを消去        */

        print_x = x * SIZE_CHAR_X;      /* 出力する座標を計算します */
        print_y = (y+1) * SIZE_CHAR_Y;

        WORD( para+0 ) = print_x;
        WORD( para+2 ) = print_y - SIZE_CHAR_Y +1;
        WORD( para+6 ) = print_y;

        if ( string > 255 ) {
            WORD( para+4 ) = print_x + SIZE_CHAR_X * 2 -1;
        }
        else {
            WORD( para+4 ) = print_x + SIZE_CHAR_X -1;
        }
        EGB_writeMode( EGB_work, WRITEMODE_PSET );
        EGB_color( EGB_work, FOREGRAND_COLOR, color_backgrand );
        EGB_color( EGB_work, PAINT_COLOR, color_backgrand );
        EGB_rectangle( EGB_work, para );
                                      /* EGBに渡すパラメータを準備  */
        WORD(para + 0 ) = print_x;    /* 表示する X/Y 座標          */
        WORD(para + 2 ) = print_y;

        if ( string > 255 ) {
            WORD(para + 4 ) = 2;                /* 出力する文字数   */
            BYTE(para + 6 ) = string >> 8;      /* 出力する文字     */
            BYTE(para + 7 ) = string & 0x0ff;   /* 出力する文字     */
        }
        else {
            WORD(para + 4 ) = 1;        /* 出力する文字数           */
            BYTE(para + 6 ) = string;   /* 出力する文字             */
        }

        EGB_color( EGB_work, FOREGRAND_COLOR, color_foregrand );

        EGB_sjisString( EGB_work, para );   /* EGBに渡します        */
        MOS_disp( MOUSE_DISPLAY );

        /*****************************************
         * 画面上に描画した文字を仮想VRAMに転送
         * します
         *****************************************/
        offset = x + y * CHAR_MAX_X;    /* 仮想VRAM上のoffsetを計算 */

        if ( string > 255 ) {
            vram[offset] = string >> 8;
            if ( ( CHAR_MAX - 1 ) == offset )
                vram[0] = string & 0xff;
            else
                vram[offset+1] = string & 0xff;
        }
        else {
            vram[offset] = string & 0xff;
        }

        if ( string > 255 )
            x += 2;
        else
            x++;                         /* 出力座標を更新           */

        if ( x >= CHAR_MAX_X ) {         /* 最大桁数に達したか?      */

            /******************************************
             * 出力した文字が漢字でかつ79桁目の位置に
             * 出力したなら､ x を2桁目に設定します
             ******************************************/
            if ( CHAR_MAX_X > x && string > 255 )
                x = 1;             /* 桁位置を左に移動         */
            else
                x = 0;             /* 桁位置を左に移動         */

            y++;                   /* 下の行に移動             */
        }

        if ( y >= CHAR_MAX_Y ) {   /* 最大行数に達したか?      */
            y = 0;                 /* 行位置を上に移動         */
        }
    }

    return( normal );              /* 終了                     */
}

/************************************************************************
 *
 *      画面にカーソルを表示します
 *
 *-----------------------------------------------------------------------
 *
 *      INPUT  : int    x,  y;      出力する座標(グラフィック座標)
 *
 *      OUTPUT : (void)
 *
 ************************************************************************/
int disp_cursor( int x, int y )
{
char    para[16];                  /* EGBに渡すパラメータ格納用  */

    MOS_disp( MOUSE_ERASE );       /* マウスカーソルを消去       */

    /****************************************
     * カーソルの形の矩形座標を計算します
     ***************************************/
    WORD( para+0 ) = x;            /* カーソルを出力する矩形   */
    WORD( para+2 ) = y - SIZE_CHAR_Y +1;
    WORD( para+4 ) = x + SIZE_CHAR_X -1;
    WORD( para+6 ) = y;
                                   /* EGBの描画モードの設定    */
    EGB_writeMode( EGB_work, WRITEMODE_EOR );
    EGB_color( EGB_work, FOREGRAND_COLOR, color_exclusive );
    EGB_color( EGB_work, PAINT_COLOR, color_exclusive );

    EGB_rectangle( EGB_work, para );   /* カーソルの表示                 */

    MOS_disp( MOUSE_DISPLAY );         /* マウスカーソルを表示           */

    return( normal );                  /* 終了                           */
}

/************************************************************************
 *
 *      メインルーチン
 *
 *************************************************************************/
int main()
{

    int     string;                     /* キーボードから入力された
                                                            文字格納用  */
    int     sw;                         /* キーボードからの入力モード   */
    unsigned int  encode, moji;         /* キーボードBIOS
                                                    インターフェイス用  */
    int     mouse_x, mouse_y, button;   /* マウスBIOS
                                                    インターフェイス用  */
    int     cursor_flag, cursor_counter;/* カーソル点滅制御用           */
    int     ret;

    color_foregrand = COLOR_BLACK;      /* 前景色として表示する色  */

    color_backgrand = COLOR_INTENSITY_WHITE;/* 背景色として表示する色 */

    color_exclusive = COLOR_BLACK ^ COLOR_INTENSITY_WHITE;
                                        /* 反転に使う色            */

    /************************************
     * EGB/MOS を初期化します
     ************************************/
    display_init();                /* SKBを表示する画面を初期化    */

    /******************************************
     * ソフトウェアキーボードを初期化します
     *
     * 以下の if 文で ワーニングが発生しますが
     * バグではありません
     *****************************************/
    if ( ret = SKB_init() ) {      /* SKBを初期化します            */
        fprintf( stderr, "SKBの初期化に失敗しました\n" );
        return( ret );
    }

    /************************************
     * かな漢字変換を初期化します
     ************************************/
  Kana_init();                   /* かな漢を初期化します         */
  KAN_disp( KAN_display );       /* かな漢開始                   */

  MOS_disp( MOUSE_DISPLAY );     /* マウスカーソルを表示します   */

  sw = 1;                        /* キー待ちなしの状態にします   */
  cursor_flag = FALSE;           /* カーソル消去に初期設定       */
  cursor_counter = 0;            /* カウンタ 0 に初期設定        */

  do {
      /*****************************************************************
       *   テキスト画面のカーソル制御
       *   画面上にカーソルを表示させ 一定時間ごとにブリンクさせます
       *****************************************************************/
      if ( cursor_counter++ == MAX_CURSOR_COUNT ) { 
          disp_cursor( x * SIZE_CHAR_X, ( y + 1 ) * SIZE_CHAR_Y );
          cursor_flag = !cursor_flag;
          cursor_counter = 0;
      }
      /*****************************************************************
       *      キーボードBIOSから1文字を読み取ります
       *****************************************************************/
      moji = KYB_read( sw, &encode ); /* キーボードBIOSから読み込みます */

string = moji;

if ( (moji & 0xff) != CHAR_UNAVAILABLE ) {
                                 /* 有効な文字が入力されたとき   */ 
          if ( cursor_flag ) {   /* カーソルが表示されていたら
                                                      消去します */
              disp_cursor( x * SIZE_CHAR_X, ( y + 1 ) * SIZE_CHAR_Y );
              cursor_flag = FALSE;
              cursor_counter = 0;
          }

          /****************************************************
           * 入力された文字を判定し、漢字の第一バイト目なら
           * もう一文字あるので、それを読み取ります
           ****************************************************/
          if ( iskanji( moji ) ) {    /* 漢字の第一バイト目?     */
              string = ( moji << 8 ) +
                                  ( KYB_read( sw, &encode ) & 0x0ff );
          }

    print( string );            /* 1文字を画面に表示します */
      }

if ( moji == 13 )               /* 改行キーなら終了します  */
          break;

        /**************************************************
         * 右ボタンが押されたならソフトウェアキーボードを
         * 表示させます
         * 右ボタンが押されているか判定するために、マウスの
         * 状態を読み取ります
         **************************************************/
        MOS_rdpos( &button, &mouse_x, &mouse_y );

        /**************************************************
         * 右ボタンが押されたなら表示しますが、右ボタンが
         * 放されるのを待ちます
         **************************************************/
        if ( button & MOUSE_RIGHT ) {   /* マウスの右ボタンが押されたら */
            do {                        /* 放されるのを待って           */
                MOS_rdpos( &button, &mouse_x, &mouse_y );
            }while( button & MOUSE_RIGHT );

      if ( cursor_flag ) {        /* ｶｰｿﾙが表示されていたら消します */
    disp_cursor( x * SIZE_CHAR_X, ( y + 1 )*SIZE_CHAR_Y );
                cursor_flag = FALSE;
                cursor_counter = 0;
            }

            /**************************************************
             * ソフトウェアキーボードが表示されている間は、
             * 専用の関数に制御を移します
             **************************************************/
            SKB_main();                 /* SKBの処理に移行します    */
        }

    /**************************************************
     * break文によって抜けるまで繰り返し実行します
     * break文は 改行キーが入力されると実行するように
     * なっています
     **************************************************/
    }while( TRUE );

    KAN_disp( KAN_erase );              /* かな漢の停止       */
    KAN_finish();                       /* かな漢の終了       */
    SKB_terminate();                    /* SKBの終了処理      */
    MOS_end();                          /* マウスを終了します */

    return( normal );                   /* プログラムの終了   */
}

*****************************************************************************
第4章  サイドワークライブラリ
*****************************************************************************

1 サイドワーク機構の概要

  サイドワークとは、アプリケーション実行中にアプリケーションユーザの指定によ
り(あらかじめ登録されている)別のプログラムを呼び出す機構です。
  実行されるプログラムをサイドワークプログラムと呼びます。

  サイドワークに対応しているアプリケーションでは、その画面上のある特定のボタ
ンを押すことによりサイドワークプログラムが起動するようになります。
  サイドワークプログラムはディスクからロードされ実行されます。

  アプリケーションに対するデータ入力を、サイドワーク機構を利用して行う、いわ
ゆるFEP(Front End Processor)的な利用形態の例*1です。

  図EXL121R-006

  サイドワークプログラムによって入力されたデータを、アプリケーションの通常の
入力データに見せます。

2 サイドワークの運用

  サイドワークを利用するための必要な作業を説明します。なお標準システムではサ
イドワークはすでに動作可能状態で起動しているので、この章で述べる作業は不要で
す。
  利用者は最初にサイドワーク定義ファイルを作成します。これは、利用するサイド
ワークプログラムの名前を列記したテキストファイルです。このファイルが準備でき
れば、サイドワークスタートコマンドを発行するだけでサイドワーク機能の組み込み
が完了します。サイドワーク定義ファイルを作っておけば、以後のシステム起動から
はコマンド1つでサイドワーク機能が利用できます。
これは、DOSでいうCONFIG.SYSファイルのようなものです。

2.1 サイドワーク定義ファイル

  サイドワークプログラムのファイル名などを列記しておくテキストファイルをサイ
ドワーク定義ファイルと呼びます。通常、サイドワーク定義ファイルはSIDEWORK.SYS
というファイル名を起動ドライブのSIDEWORKディレクトリ下に配置しておきます。
ただし、この位置は変更可能です(後述)。
  各行は、必ず復帰/改行コード(0DH、0AH)で終了しなければなりません。

  ┌────────────────────────────────┐
  │Q  "選択メニュー"       D:\SIDEWORK\SIDEWORK.MNU                │
  │P  "コントロールパネル" D:\SIDEWORK\CTRL PNL.EXP                │
  │M  "メニュー色設定"     D:\SIDEWORK\SET PAL.EXP                 │
  │D  "電卓          "     D:\TS_TOOL\CM.EXP                       │
  │C  "CDプレーヤー  "     D:\TS_TOOL\CDPLAY.EXP                   │
  │A  "住所録        "     D:\TS_TOOL\ADDRESS.EXP  A:\LA.LMI       │
  │S  "予定表"             D:\TS_TOOL\SCL.EXP  A:\APPT.SDB         │
  │W  "単語登録"           D:\SIDEWORK\REGIWORD.EXP    ↑          │
  │B  "ドライバリスト"     D:\SIDEWORK\NSDDLIST.EXP    │          │
  │↑    ↑                          ↑                │          │
  └┼──┼─────────────┼────────┼─────┘
    │    │                          │          プログラムパラメータ
    │  メニュー表示文字列  サイドワークプログラムパス名
    │                      (先頭のドライブ名に'@'を指定すると
    │                        起動ドライブの指定になります)
ショートカットキー文字

    ▲サイドワーク定義ファイル例


      ┌────────┐
      │FMＴＯＷＮＳ    │
      ├────────┴┐
      〜─────────〜
      │コントロールパネル│
      │メニュー色設定  ↑│
      │電卓              │
      │ＣＤプレーヤー    │
      │住所録            │
      │予定表            │
      〜                  〜
      │ドライバリスト    │
      └─────────┘
        ▲サイドワークプログラム選択メニュー

サイドワーク定義ファイル構文
サイドワーク定義ファイル    →  {定義文}
定義文                      →  ショートカットキー文字△メニュー表示文字列△
                                サイドワークプログラムパス名△プログラムパラ
                                メータ
ショートカットキー文字      →  英字|数字(現バージョンでは未サポート)
メニュー表示文字列          →  '"'|{全角文字|半角文字}|'"' 
サイドワークプログラムパス名→  '@'|MS-DOS規約によるフルパス名
                                先頭のドライブ名に'@'を指定することにより、
                                起動ドライブを指定することができます。
プログラムパラメータ        →  {全角文字|半角文字}|復帰/改行コード
△(デリミタ)                →  {' '}
復帰/改行コード             →  0DH|0AH 

2.2 サイドワークスタートコマンド

  サイドワークを利用するアプリケーションの直前までに、サイドワークスタートコ
マンドを実行しておきます。標準システムではこの作業は不要です。

┌─サイドワークスタートコマンド─────────────────────┐
│  SIDEWORK{オプション}                                                  │
│  オプション ...                                                        │
│      -PAGE [サイドワークメモリ用ページ数]                              │
│      -SYS [サイドワーク定義ファイルのフルパス名]                       │
│      -REMOVE                                                           │
└────────────────────────────────────┘

オプションの説明

 1)-PAGE n ･省略形 -P n
   サイドワークの使用するメモリ(詳細は後述)として、nページ分(n×4KB)のメモリ
   を割り当てます。デフォルトでは、V2.1 L10では44ページ(176KB)、V2.1 L20以降
   では45ページ(180KB)が割り当てられます。文字列nで示される数は10進数として
   解釈されますが、最後にHを付加すれば16進数と見なされます。

 [例] SIDEWORK -PAGE 100; 100×4 =400KBをサイドワークメモリとして割り当てます
      SIDEWORK -PAGE 80H; 80H×4 =512KBをサイドワークメモリとして割り当てます

 2)-SYS pathname ･省略形 -S pathname
   サイドワークスタートコマンドが、サイドワーク定義ファイルを検索するためのパ
   ス名を指定します。デフォルトではサイドワークスタートコマンドは、起動ドライ
   ブのディレクトリSIDEWORK下でサイドワーク定義ファイルを検索します。

 [例] SIDEWORK   -SYS D:\SIDEWORK\FOO.SYS 
      ;  D:\SIDEWORK\FOO.SYSをサイドワーク定義ファイルとします

 3)-REMOVE ･省略形 -R 
   サイドワークの使用するメモリ(後述)を解放します。
   解放した領域は一般のアプリケーションが使用するメモリとなります。

   オプション導入記号は、"-"(マイナス)の他に"/"(スラッシュ)の指定も有効です。

2.3 サイドワークの取り外し/組み込み

  サイドワークの使用するメモリは、アプリケーションのメモリ空間とは独立してい
ます(詳細は後述)。サイドワークをインストールしているときにはアプリケーション
が使用できるメインメモリはサイドワークが使用している分だけ小さくなっています
。そこで、メモリを多く消費するアプリケーションのためにサイドワークを一時的に
取り外して動作させることができます。以下にその方法について説明します。

 ■アイコン起動によるサイドワーク組み込み/取り外し
   標準システムでは、TownsMENUの設定ウィンドウに｢サイドワークON｣と｢サイドワー
   クOFF｣のアイコンが登録されています。｢サイドワークOFF｣のアイコンを起動すれ
   ばサイドワークを取り外すことができます。逆に｢サイドワークON｣によって、先に
   取り外したサイドワークを再び組み込むことができます。

 ■アプリケーション起動時のサイドワーク取り外し/組み込み
   アプリケーションが動作するために充分なフリーメモリがない場合に、サイドワー
   ク機能を取り外してアプリケーションを起動することができます。フリーメモリが
   充分であれば、サイドワーク機能の状態は変化しません。従来では、このためにバ
   ッチファイルを用いていましたが、FM TOWNSシステムソフトウェアV2.1 L20以降で
   は以下に述べる方法によりアプリケーション起動を高速化し、さらにTownsMENUの
   ウィンドウ情報を保存することができます。

  ここに示す方法では、アプリケーションを直接指定して起動するのではなく、アプ
リケーション名とアプリケーションが動作する最小のメモリサイズ、および起動時の
MAXIBUFのサイズをパラメータとして、T_FILE ディレクトリ下にあるCHKMEMコマンド
を起動します。たとえば、次の条件でアプリケーションを起動する場合を考えます。
  ･アプリケーションのパス/ファイル名               :\T_TOOL\EDIT.EXP 
  ･アプリケーションが動作する最小のメモリサイズ    :1100KB
  ･アプリケーションが設定するMAXIBUFパラメータの値 :32KB
  この場合、CHKMEMコマンドに次のようなパラメータを設定してアプリケーションを
起動します。

  "\T_FILE\CHKMEM -MAXI 32 -INQU 1100 -EXEC \RUN386.EXE \T-TOOL\EDIT.EXP" 
アイテム登録する場合は、以下のようになります。
    パス          [\T_FILE           ]
    ファイル名    [CHKMEM.EXE        ]
    タイトル      [テキスト編集      ]
    パラメータ    [-MAXI 32 -INQU 1100 -EXEC \RUN386.EXE \T_TOOL\EDIT.EXP ]

CHKMEM.EXEのオプション

 1)MAXIBUFBオプション(省略形 MAXIまたはM)

【書式】  -MAXIBUF [バッファサイズ] 
【例】    -MAXIBUF 32 
  DOS-Extenderのシステムコール用のバッファサイズをKB単位に指定します。これは
  アプリケーションが実行時にRUN386コマンドに対して指定するものと同じ値を指定
  します。アプリケーションが明示的にMAXIBUFオプションを指定しない場合には、
  このオプションは指定する必要はありません。

 2)INQUIREオプション(省略形 INQUまたはI)

【書式】  -INQUIRE [メモリサイズ] 
【例】    -INQUIRE 1100 
  アプリケーションが実行に必要な最小限のメモリサイズをKB単位で指定します。
  指定範囲は1MBからメモリ実装可能サイズの上限までです。指定サイズのメモリが
  確保できなかった場合、CHKMEM.EXEはアプリケーション起動に先立ってサイドワー
  ク機能を取り外し、アプリケーション終了後に元の状態に戻します。

 3)EXECUTEオプション(省略形 EXECまたはE)

【書式】  -EXECUTE [起動コマンド名][コマンドパラメータ] 
【例】    -EXECUTE \RUN386.EXE \FOO\BAR\JACK.EXP
  メモリサイズを検査したあと、起動するコマンドとコマンドパラメータを指定しま
  す。

 4)CHDIRオプション(省略形 CDまたはC)

【書式】  -CHDIR [ディレクトリ名] 
【例】    -CHDIR \FOO\BAR 
  EXECUTEオプションで指定した起動コマンドの実行時に移動するディレクトリ名指定
  します。

3 サイドワークのメカニズム

3.1 サイドワークドライバ

  サイドワークスタートコマンドによって、DOS空間(アドレス0〜0C0000H)にサイドワ
ークドライバが常駐します。このDOS側に常駐するドライバをサイドワークドライバI
と呼びます。サイドワークドライバIは、サイドワーク定義ファイルの読み込みなどの
必要な初期設定をしたあと、管理情報のためのデータ領域として常駐します。
  一方、ネイティブ側のドライバをサイドワークドライバIIと呼びます。サイドワー
クドライバIIはT-BIOS本体の後部に連結しており、すべてのT-BIOSコールをフックし
ています。
  サイドワーク機能の主処理部は、このサイドワークドライバIIにあります。
  サイドワークスタートコマンドの発行後、アプリケーションから最初のT-BIOSコー
ルが行われたときに、サイドワークドライバIIの初期化処理部が実行されます。

        0 ┌─────────────┐
          │ DOS                      │
          ├─────────────┤
          │サイドワークドライバ I    │
          ├─────────────┤
          │                          │
          ├─────────────┤
       1MB│(RAMディスク等)           │
          ├─────────────┤
          │T-BIOS                    │
          ├─────────────┤
          │サイドワークドライバ II   │
          ├─────────────┤
          │ワイドワークメモリ        │
          ├─────────────┤
          │システムデータ            │
          ├─────────────┤
          │DOS-Extender              │
          │アプリケーション領域      │
          〜                          〜
          ├─────────────┤
          │サウンドメッセージドライバ│
          ├─────────────┤
          │ネイティブドライバ        │
  RAM上限 └─────────────┘

3.2 メモリ管理

  サイドワークが独自に管理するメモリ領域をサイドワークメモリと呼び、アプリケ
ーション空間とは別に指定量のメモリを占有します。サイドワークメモリは、サイド
ワークスタートコマンドによって確保されます。
  サイドワークメモリは、各サイドワークプログラムのコードやデータ、スタックを
はじめ、画面の退避領域やヒープ領域として個々のプログラムに配分されて利用され
ます。サイドワークメモリの容量はサイドワーク起動コマンドのパラメータで設定す
ることができます。
  実行プログラムの最小限必要なプログラムサイズがサイドワークメモリに確保でき
ないときはプログラムはロードされません。
  最小限必要なプログラムサイズは以下の式で計算できます。

  [最小限必要なプログラムサイズ]＝[ロードイメージのサイズ]
                                  +[スタックサイズ]
                                  +[デフォルトのヒープサイズ(8KB)]

  ･ロードイメージ:コードおよび初期化データの合計。
  ･スタックサイズ:セグメント結合の型にSTACKが指定されているセグメントのサ
                  イズ。リンカの-STACKオプションスイッチでも指定可能です。
  ･ヒープ        :未初期化データ領域。サイズは指定可能です(後述)。

  ヒープ領域のサイズはEGBとマウス機能が利用できる最低限サイズとして8KBがデフ
ォルトで与えられます。これ以上のサイズを使用したいアプリケーションは次に示す
方法のいずれかでヒープ領域を拡張します。
  (1) リンク時にMINDATAオプションでサイズを指定します。
  (2) プログラムからライブラリ関数を使用してヒープ領域を拡張します。

  (1)の方法では、サイドワークドライバがサイドワークプログラムをロードするとき
に、あらかじめMINDATA分のメモリが確保できるかどうかを調べ、もし不足していたら
サイドワークプログラムをロードしません。(2)の方法では、サイドワークドライバが
アプリケーションの必要なヒープ領域をあらかじめ知ることができないので、サイド
ワークプログラムはロードされ実行されます。サイドワークプログラムがヒープの要
求をライブラリ関数を用いて発行してメモリの過不足を判断することができ、これに
よってプログラムを終了するか、またはヒープを少なめにして続行するかをサイドワ
ークプログラムが決めることができます。

3.3 プロセス管理

  サイドワークプログラムの形式は、EXPファイルまたはREXファイルとし、DOS-Exten
derに対するランタイムオプション指定やリアルモードに関連する情報を含まないもの
に限ります。メモリ上にロードされ、実行または実行待ち状態にあるプログラムを、
サイドワークプロセスと呼びます。

 ■プロセスの生成
   サイドワークプログラムが実行される場合、プログラムは外部記憶からロードされ
   ます。現在のバージョンではメモリに常駐するサイドワークプログラムは作成でき
   ません。
   サイドワークシステムはコードセグメントとデータセグメント(スタックを含む)用
   として2つのエイリアスセレクタを割り当てます。このセレクタはプロセスが起動
   されるたびに割り当てられます。セグメント配置は、固定サイズスタックのスモー
   ルメモリモデルを想定しています(High-Cメモリモデルと互換)。
   データセグメントとスタックセグメントは同一セグメントです。

  CD,DS=SS            →┌────────────┐
                        │コード/データセグメント │
                        ├────────────┤
                        │↑伸長方向              │
                        │固定サイズスタック      │
  初期スタックポインタ→├────────────┤
                        │ヒープ                  │
                        │↓伸長方向              │
  セグメントリミット  →└────────────┘

4 データ通信

4.1 フロントエンド処理機能

  サイドワークプログラムが必要ならばユーザの入力に応じて加工し、アプリケーシ
ョンに入力データとして渡します。これは、キーボードBIOSを利用してキーバッファ
にデータを追加していくことにより実現されています。

┌─────────────┬──────────────────┐
│    例                    │  アプリケーションに渡されるデータ  │
├─────────────┼──────────────────┤
│  電卓                    │  計算結果                          │
└─────────────┴──────────────────┘

  図EXL121R-007

5 サイドワークプログラミング

5.1 開発環境

  サイドワークプログラムを開発する場合の開発ツールは基本的に通常の単独起動ア
プリケーションを作る場合と同様です。
  ただし、サイドワークライブラリ(T_OS.LIBに内包)が必須です。

┌───────┐
│   ｿｰｽﾌｧｲﾙ    │
└───┬───┘
        ├────────┐
┌───┴───┐┌───┴───┐
│   High C     ││  386|ASM     │
└───┬───┘└───┬───┘
        ├────────┘
┌───┴───┐┌────────┐┌───────┐┌───────┐
│ｵﾌﾞｼﾞｪｸﾄﾌｧｲﾙ  ││ ｻｲﾄﾞﾜｰｸﾗｲﾌﾞﾗﾘ  ││ High Cﾗｲﾌﾞﾗﾘ ││ T-BIOSﾗｲﾌﾞﾗﾘ │
└───┬───┘└────┬───┘└───┬───┘└───┬───┘
        ├─────────┴────────┴────────┘
┌───┴───┐
│    リンカ    │
└───┬───┘
┌───┴───┐
│  実行ﾌｧｲﾙ    │
└───────┘
┌──────────────┐
│    サイドワークシステム    │
├──────────────┤
│      T-BIOS                │
└──────────────┘
┌──────────────┐
│Townsｼｽﾃﾑｿﾌﾄｳｪｱ V2.1        │
└──────────────┘

5.2 プログラミング指針

  サイドワークプログラムのスケルトン

  図EXL121R-008

  単独起動するプログラムに対して、サイドワークプログラムで最低限必要なのは、
プログラムの開始と終了時に指定のライブラリ関数を呼び出すことです。さらに、必
要ならば(多くの場合、必要ですが)現在のアプリケーションの画面状態をそのままに
するため画面モードなどの情報を取得したり、元の画面データを退避/復元する処理が
加わります。画面モードを取得するためにはT-BIOSでライブラリ関数がいくつか用意
されています。画面の退避/復元を行うためには、T-BIOSのライブラリ関数を利用する
か、またはサイドワークのライブラリ関数として提供されているものを利用すること
ができます。

5.3 プログラミング規約

  この項では、サイドワークプログラムを作成する場合の留意事項を説明します。
  特に通常の単独起動アプリケーションとはプログラミング作法が異なる部分がある
ので注意してください。

 (1)メモリ管理に関する規約

  ●セレクタはプロセスに動的に割り当てられます
    サイドワークのプロセスに割り当てられるセグメントセレクタは、プロセス起動
    のたびにDOS-Extenderのメモリ管理下で動的に割り当てられます。このため、起
    動のたびにセレクタ値が同じである保証はありません。つまり、実行中のある時
    点で取得したセレクタ値はそのプロセスが生きている限りは有効ですが、プロセ
    ス終了後、次回の起動では異なるセレクタ値が割り当てられる可能性があります
    。特にDS=14hなどとはならないので注意してください。

  ●アプリケーションのセレクタの継承
    メインメモリにマッピングされているセレクタのうちPSPをマッピングしているも
    の以外は、すべてサイドワーク呼び出し時に動作中のアプリケーションプログラ
    ム(これを、オリジナルプログラムと呼ぶ)のセレクタを継承します。

  ●PSPとデフォルトDTA 
    PSPフィールドはサイドワークによって初期化されます。現在のバージョンではオ
    フセット5CHから64Hまでのメモリ割り当てに関する情報はサイドワークプログラ
    ムにとって無効です。オフセット80HからのデフォルトDTA領域はサイドワークプ
    ログラムにより使用可能です。
    また、DTAはオリジナルプログラムとは別に確保されます。

  ●環境セグメント
    サイドワークプログラムは、オリジナルプログラムの環境セグメントを継承しま
    す。このため環境セグメントに存在する起動パス名は、このアプリケーションプ
    ログラムのもので、サイドワークプログラム自身の起動パス名を取得することは
    できません。このため、C言語でのargv[0](起動コマンド名)は取得することがで
    きず、その内容は無効です。
    以上の事項を含め現バージョンでは環境変数を操作することを禁止します。

 (2)ファイルハンドルに関する規約
    現バージョンではサイドワーク起動時に実行していたプログラムの内部FCBの状況
    を知ることができません。このためファイルの排他制御が不可能です。サイドワ
    ークプログラムでのファイルの書き込み処理には十分に注意してください。

 (3)デバイスアクセスに関する規約
    CDドライブや通信回線、プリンタなどのデバイスは排他制御されません。オリジ
    ナルプログラムがこれらのデバイスにアクセスしている最中に起動されたサイド
    ワークプロセスがデバイスに対する初期化やデータ送信などを行った場合に、
    動作が不安定となります。

5.4 サイドワークライブラリの関数一覧

  サイドワークシステムには、サイドワークプログラムから利用するためのいくつか
のライブラリ関数が提供されています。
  以下にライブラリの各関数について説明します。

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│sdk_start                 │サイドワークプログラムのスタート          │
├─────────────┼─────────────────────┤
│sdk_terminate             │サイドワークプログラムの終了              │
├─────────────┼─────────────────────┤
│sdk_saveScrn              │画面データの退避                          │
├─────────────┼─────────────────────┤
│sdk_loadScrn              │画面データの復元                          │
├─────────────┼─────────────────────┤
│sdk_setKBuf               │キーボードバッファへの文字列転送          │
├─────────────┼─────────────────────┤
│sdk_isAtWork              │起動環境の取得                            │
├─────────────┼─────────────────────┤
│sdk_chain                 │連続実行プログラム番号の登録              │
├─────────────┼─────────────────────┤
│EGB_getScrnInfo           │画面モードに関する情報の取得              │
├─────────────┼─────────────────────┤
│sdk_getNumProg            │サイドワークプログラム登録数の取得        │
├─────────────┼─────────────────────┤
│sdk_getProgNameLen        │サイドワークプログラム識別名の長さの取得  │
├─────────────┼─────────────────────┤
│sdk_getProgName           │サイドワークプログラム識別名の取得        │
└─────────────┴─────────────────────┘

5.5 各関数の解説

-----------------------------------------------------------------------------
.EGB_getScrnInfo 
画面モードに関する情報の取得
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int  EGB_getScrnInfo(int mode, 
                       int *vx, int *vy, int *dx, int *dy, int *col); 
int mode;   /*画面モード*/
int *vx;    /*仮想画面水平方向ドット数を取得するint型変数へのポインタ*/
int *vy;    /*仮想画面垂直方向ドット数を取得するint型変数へのポインタ*/
int *dx;    /*表示画面水平方向ドット数を取得するint型変数へのポインタ*/
int *dy;    /*表示画面垂直方向ドット数を取得するint型変数へのポインタ*/
int *col;   /*同時発色数を取得するint型変数へのポインタ              */

- 戻り値 -
0 :正常終了

- 内容 -
指定した画面モード(中解像度モード)に対する仮想画面サイズ、表示画面サイズ、同
時発色数を取得します。画面モードはTowns BIOSのサポートする1から18までの範囲で
指定します。画面サイズ、同時発色数をEGB_getScrnInfo関数で取得することにより、
パレットの設定やマウスの移動範囲を速やかに設定することができます。
なお、取得する必要のない情報に対するポインタ引数にはNULLポインタを指定するこ
とができます。

- 注意 -
この関数は、中解像度モード時のみ有効です。

- 例 -
#include <sidework.h> 
            …
int mode;    /* 現在の画面モード         */ 
int vxsize;  /* 仮想画面水平方向ドット数 */ 
int vysize;  /* 仮想画面垂直方向ドット数 */ 
int dxsize;  /* 表示画面水平方向ドット数 */ 
int dysize;  /* 表示画面垂直方向ドット数 */ 
int colors;  /* 同時発色数               */ 
            …
 EGB_getScrnInfo(mode, &vxsize, &vysize, &dxsize, &dysize, &colors);
 switch(colors) {
     case    16 :      /*     16色モードのときの処理  */
     case   256 :      /*    256色モードのときの処理  */
     case 32768 :      /*  32768色モードのときの処理  */
}

-----------------------------------------------------------------------------
.sdk_chain 
連続実行プログラム番号の登録
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int  sdk_chain(unsigned int progNo);
unsigned int progNo;  /*  連続実行するプログラム番号(≧1) */ 

- 戻り値 -
0 :正常終了

- 内容 -
現在実行中のサイドワークプログラムの終了後、引き続いて実行させるプログラムの
番号を登録します。本関数は指定したプログラム番号の正当性の検査は行いません。
不正なプログラム番号の検出は、サイドワークプログラムが終了したあと、サイドワ
ークドライバが次のプログラムをロードしようとするときに行われます。
また、プログラム番号に0を指定した場合は本関数の効果は無効となります。

- 例 -
#include <sidework.h> 
      …
void main() {
      …
sdk_chain(n); 
      …
}
      ↓
┌──────────────────────────────────┐
│ｻｲﾄﾞﾜｰｸ定義ﾌｧｲﾙ中に登録されているn番目のﾌﾟﾛｸﾞﾗﾑ*1を引き続き実行する │
└──────────────────────────────────┘
 (*1 サイドワークプログラム選択メニューを0番目として起算する) 

-----------------------------------------------------------------------------
.sdk_getNumProg
サイドワークプログラム登録数の取得
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int  sdk_getNumProg(void);

- 戻り値 -
サイドワークプログラムの登録数

- 内容 -
現在、サイドワークプログラムとして登録されているプログラムの数を取得します。
登録数の中には、定義ファイルの中の最初に登録されている標準の選択メニュー表示
プログラムも含まれています。この関数は原則として、選択メニュープログラムを独
自に作成するときに使用します。

-----------------------------------------------------------------------------
.sdk_getProgNameLen
サイドワークプログラム識別名の長さの取得
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int  sdk_getProgNameLen(int n);
int n;    /*プログラムの登録番号 */ 

- 戻り値 -
0     :プログラムの登録番号に誤りがある
0以外 :n番目のプログラムの識別名の長さ(NULL文字は含まず)

- 内容 -
n番目に登録されているサイドワークプログラムの識別名の長さを取得します。この長
さに相当するバッファを確保し、後述のsdk_getProgName関数によって、プログラム識
別名を取得します。この関数は原則として、選択メニュープログラムを独自に作成す
るときに使用します。

- 参照 -
sdk_getProgName関数

-----------------------------------------------------------------------------
.sdk_getProgName 
サイドワークプログラム識別名の取得
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int  sdk_getProgName(int n, char *buf, char *key);
int n;      /* プログラムの登録番号                    */
char *buf;  /* プログラム識別名取得領域へのポインタ    */
char *key;  /* ショートカットキー取得領域へのポインタ  */

- 戻り値 -
0     :正常終了
0以外 :プログラムの登録番号に誤りがある

- 内容 -
n番目に登録されているサイドワークプログラムの識別名とショートカットキーの定義
を取得します。bufの指し示す領域にNULL文字で終了するプログラム識別名が格納され
、keyで指し示す領域に1バイトのショートカットキー文字コードが格納されます。
bufのサイズはsdk_getProgNameLen関数によってあらかじめ知ることができます。この
関数は原則として、選択メニュープログラムを独自に作成するときに使用します。

- 参照 -
sdk_getProgNameLen関数

-----------------------------------------------------------------------------
.sdk_isAtWork
起動環境の取得
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int     sdk_isAtWork(void); 

- 戻り値 -
0     :サイドワークは動作していない
0以外 :サイドワーク動作中

- 内容 -
現在サイドワーク機能が動作中かどうかを検査します。通常のプログラムからこのラ
イブラリ関数を利用することにより、そのプログラムがサイドワーク機能下で起動し
たか、または単独起動したかを識別することができます。

- 例 -
#include <sidework.h> 
        …
int sidework = 0;  /* 起動元を判断するためのフラグ */ 
        …
void main() 
{
    sidework =  sdk_isAtWork(); 
            …
    if (sidework) 
    sdk_start(heapSize);
            …
    /*  メインの処理  */
            …
     if (sidework)
        sdk_terminate(EGB_work, MOS_work, NULL);
}

-----------------------------------------------------------------------------
.sdk_loadScrn
画面データの復元
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int     sdk_loadScrn(unsigned short *rect, int npage);
unsigned short *rect; 

                /*  復元する矩形領域の座標を持つデータブロック  */
          ┌──┬───────┐  ┌──────────────┐
    rect→│word│左上Ｘ座標(x0)│  │                            │
          ├──┼───────┤  │                            │
          │word│左上Ｙ座標(y0)│  │   (x0,y0)                  │
          ├──┼───────┤  │    ×─────┐          │
          │word│右下Ｘ座標(x1)│  │    │ 退避領域 │          │
          ├──┼───────┤  │    │          │          │
          │word│右下Ｙ座標(y1)│  │    └─────×(x1,y1)   │
          └──┴───────┘  │                            │
                                    └──────────────┘
                                                          画面
int     npage;    /*  復元する画面データを書き込むページ          */

- 戻り値 -
0 :正常終了

- 内容 -
sdk_saveScrn関数でサイドワークシステムの持つ領域に退避した画面データを復元し
ます。

- 例 -
#include <sidework.h> 
            …
unsigned short rect = { X0, Y0, X1, Y1 }; 
            …
if (sdk_saveScrn(&rect, writePage)) 
    return ERR_SAVESCRN;  /*  画面退避に失敗 */ 
            …
sdk_loadScrn(&rect, writePage); 

- 参照 -
sdk_saveScrn関数

-----------------------------------------------------------------------------
.sdk_saveScrn
画面データの退避
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int     sdk_saveScrn(unsigned short *rect, int npage);
unsigned short *rect; 

                /*  退避する矩形領域の座標を持つデータブロック   */ 
              ┌──┬───────┐  ┌──────────────┐
        rect→│word│左上Ｘ座標(x0)│  │                            │
              ├──┼───────┤  │                            │
              │word│左上Ｙ座標(y0)│  │   (x0,y0)                  │
              ├──┼───────┤  │    ×─────┐          │
              │word│右下Ｘ座標(x1)│  │    │ 退避領域 │          │
              ├──┼───────┤  │    │          │          │
              │word│右下Ｙ座標(y1)│  │    └─────×(x1,y1)   │
              └──┴───────┘  │                            │
                                        └──────────────┘
                                                              画面

int     npage;  /*  退避する画面データのあるページ               */ 

- 戻り値 -
0     :正常終了
0以外 :･画面データを退避することができない
       ･領域指定に誤りがある(画面領域を超える指定をした)

- 内容 -
指定した矩形領域をサイドワークシステムが持つ領域内に退避します。
退避領域が不足している場合や画面を超える矩形領域を指定した場合にはエラーとな
ります。このような場合はそのままプログラムを終了してください。本関数でエラー
が発生したにもかかわらず、sdk_loadScrn関数を呼び出すとメモリプロテクションエ
ラーが発生します。この関数を用いるようなサイドワークプログラムを動かす場合に
は画面退避領域のためにサイドワークメモリを十分に確保しておく必要があります。
画面の退避を独自に行うプログラムはこの関数を呼び出す必要はありません。
また、この関数はサイドワーク機能下でしか動作できないため、単独起動とサイドワ
ークによる起動の両方に対応するプログラムでは、EGBライブラリ関数である
EGB_getBlock関数/EGB_putBlock関数を利用して画面の退避/復元を行ってください。

- 参照 -
sdk_loadScrn関数

-----------------------------------------------------------------------------
.sdk_setKBuf 
キーボードバッファへの文字列転送
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
void    sdk_setKBuf(char *str); 
char    *str;   /*  キーボードバッファへ追加するASCIIZ文字列  */

- 戻り値 -
なし

- 内容 -
本関数は、サイドワークプログラムで生成した文字列を、サイドワーク起動時に実行
中であったアプリケーションプログラムの入力データとするために利用します。指定
された文字列はBIOSの持つキーバッファに追加されます。サイドワークプログラムが
この関数を発行して終了すると、指定された文字列はサイドワーク起動時に実行中で
あったアプリケーションプログラム側からはキーボード入力データとして見えます。
転送できる文字列長はBIOSの持つキーデータバッファの長さに依存します。

- 例 -

  ■オリジナルプログラム              ■サイドワークプログラム

                  サイドワーク起動
            │                ┌─→┌───────────────┐
  ┌────┴────┬───┘    │    …                        │
  │  ユーザ入力待ち  │            │    sdk_setKBuf("sample");    │
  └────┬────┘←──┐    │    sdk_terminate();          │
            ↓                └──┴───────────────┘
  文字列'sample'が得られる

-----------------------------------------------------------------------------
.sdk_start 
サイドワークプログラムのスタート
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int    sdk_start(int heapSize);
int    heapSize;  /*  拡張するヒープ領域の4KBページサイズ  */

- 戻り値 -
0     :正常終了
0以外 :メモリが不足しているために指定サイズのヒープを割り当てることができない

- 内容 -
サイドワークシステムの初期設定を行うと同時にヒープ領域の割り当てを行います。
この関数は、main関数のエントリ直後、すべての処理に先立って最初に呼び出さなけ
ればなりません。
サイドワークプログラムには、デフォルトで8KBのヒープ領域が割り当てられます。
このヒープ領域は、malloc関数などの標準Cライブラリ関数を通して利用することがで
きます。ヒープ領域が8KBを超えない場合はheapSizeに0を指定してください。
8KBを超えるヒープ領域を利用するプログラムはheapSizeに拡張したいヒープのサイズ
を4KBページ単位で指定してください。拡張したヒープ領域はデフォルトのヒープ領域
に連結され、malloc関数などの標準Cライブラリ関数を通して利用することができます
。必要なヒープ領域を割り当てることができなかった場合、本関数は0以外の値を返し
、この状態ではデフォルトの8KBのヒープ領域のみが利用可能となります。

  セグメントベース     →┌───────────┐
  (CS,DS,ES,FS,GS初期値) │コード/データ         │
                         ├───────────┤
                         │スタック              │
                         ├───────────┼──
  SS:ESP初期値→         │ヒープ領域(デフォルト)│ ↑ 8KB
                         │                      │ ↓
                         ├───────────┼──
                         │拡張されたヒープ領域  │ ↑sdk_start関数で確保する
                         │                      │ ↓
  セグメントリミット   →└───────────┴──

-----------------------------------------------------------------------------
.sdk_terminate 
サイドワークプログラムの終了
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int     sdk_terminate(void *gwk, void *mwk, void *swk); 
void    *gwk;    /*   EGB作業領域へのポインタ                */
void    *mwk;    /*   マウスBIOS作業領域へのポインタ         */
void    *swk;    /*   サウンドBIOS作業領域へのポインタ       */

- 戻り値 -
0 :正常終了

- 内容 -
main関数が終了する直前に、本関数を呼び出してください。この関数によって必要な
後処理が行われます。作業領域を確保していない場合にはNULLポインタを指定してく
ださい。

5.6 サンプルプログラム

  次ページ以降にサイドワークプログラムのコーディング例のリストを示します。
  このプログラムのファイル名を"example.c"としたときのMAKEファイルおよびリンカ
応答ファイル例を以下に示します。

  ┌─────────────┐
  │  src1 = example          │
  │                          │
  │  $(src1).obj: $*.c       │
  │    hc386-c $* -obj $@    │
  │                          │
  │  $(src1).exp: $*.obj     │
  │        TLINK @$*         │
  └─────────────┘
    ▲MAKEファイル例

  ┌─────────────┐
  │    example               │
  │    -exe example          │
  │    -lib ..\lib\tbios     │
  │    -lib ..\lib\hce       │
  │    -lib ..\lib\t_os      │
  │    -stack 8192           │
  │    -twocase              │
  └─────────────┘
    ▲リンカ応答ファイル例

┌────────────────────────────────────┐
│サイドワークライブラリサンプルプログラム                                │
│■  機能  ■                                                            │
│  サイドワークによりボックスを表示するプログラムです。マウスボタンを押す│
│  ことにより終了します。                                                │
│■  構成する関数  ■                                                    │
│  buildBox: ボックス初期設定。前もって表示座標などの計算を行います。    │
│  showBox : ボックス表示                                                │
│  procsBox: ボックス主処理。ここではマウスボタンが押されるまで待ちます。│
│  init    : サイドワーク、T-BIOSの初期設定                              │
│  term    : サイドワーク、T-BIOSの終了処理                              │
└────────────────────────────────────┘
#include    <stdlib.h>
#include    <egb.h>
#include    <mos.h>
#include    <sidework.h>

typedef unsigned long   DWORD;
typedef unsigned short  USHORT;
typedef unsigned char   UCHAR;

/************************************/
/*  プログラムが占有する矩形領域    */
/************************************/

typedef struct {
    USHORT  x0;
    USHORT  y0;
    USHORT  x1;
    USHORT  y1;
} RECT;

#define XSIZE   360                 /*  X方向ピクセル数                 */
#define YSIZE    72                 /*  Y方向ピクセル数                 */
RECT frame;                         /*  影なし閉包矩形領域              */
RECT frameWithShadow;               /*  影付き閉包矩形領域              */

int shadow_x;                       /*  矩形本体と影のずれ(X方向)       */
int shadow_y;                       /*  矩形本体と影のずれ(Y方向)       */

/************************************/
/*  T-BIOS作業領域                  */
/************************************/
char    *gwk;                       /*  グラフィックス作業領域          */
char    *mwk;                       /*  マウス作業領域                  */
#define PltWorkSize_16  (4+8*16)    /*  パレット退避領域サイズ(16色)    */
#define PltWorkSize_256 (4+8*256)   /*  パレット退避領域サイズ(256色)   */
char    *pwk;                       /*  パレット退避領域                */

int     writePage;                  /*  現在の書き込みページ            */
int     orgWritePage;               /*  元の書き込みページ              */

int     colors;                     /*  同時発色数                      */

/************************************************************************

        buildBox ---- ボックス初期設定

        現在のマウスカーソルの位置がボックスの重心座標となるような
        矩形座標を算出します

*************************************************************************/
#define max(a,b)    ((signed int)(a) > (signed int)(b) ? (a) : (b))

int buildBox(void)
{
    int b;                          /*  マウスボタン状態                */
    int x;                          /*  マウスカーソル位置X座標         */
    int y;                          /*  マウスカーソル位置Y座標         */

    shadow_x = shadow_y = 8;        /*  矩形本体と影のずれ              */

    /*  現在のマウスカーソルの位置を矩形の重心位置とする                */
    MOS_rdpos(&b, &x, &y);
    frame.x0 = frameWithShadow.x0 = max((USHORT)x - XSIZE / 2, 0);
    frame.y0 = frameWithShadow.y0 = max((USHORT)y - YSIZE / 2, 0);

    frame.x1 = frame.x0 + XSIZE;
    frame.y1 = frame.y0 + YSIZE;
    frameWithShadow.x1  = frame.x1 + shadow_x;
    frameWithShadow.y1  = frame.y1 + shadow_y;

    return 0;
}

/************************************************************************

        showBox ---- ボックス表示

        ボックスを表示します

*************************************************************************/
int showBox(void)
{
    RECT r;

    EGB_writeMode(gwk, 0);          /* 描画モード : PSET                */
    EGB_color(gwk, 0,  8);          /* 境界線色   : 黒                  */
    EGB_color(gwk, 1, 15);          /* 背景色     : 白                  */
    EGB_color(gwk, 2, 15);          /* 面塗り色   : 白                  */
    EGB_paintMode(gwk, 0x22);       /* ベタ塗り                         */

    /*  矩形領域の描画  */
    EGB_rectangle(gwk, (char *)&frame);

    /*  影を付ける  */
    EGB_color(gwk, 2, 8);           /*  面塗り色    : 黒                */
    r.x0 = frame.x1 + 1;
    r.x1 = frameWithShadow.x1;

    r.y0 = frame.y0 + shadow_y;
    r.y1 = frameWithShadow.y1;
    EGB_rectangle(gwk, (char *)&r);

    r.x0 = frame.x0 + shadow_x;
    r.x1 = frameWithShadow.x1;
    r.y0 = frame.y1 + 1;
    r.y1 = frameWithShadow.y1;
    EGB_rectangle(gwk, (char *)&r);

    MOS_disp(1);

    return  0;
}

/************************************************************************

        procsBox ---- ボックス主処理

        ここではマウスボタンが押されるまで待ちます

*************************************************************************/
int procsBox(void)
{
    int b, p;           /*  マウスボタン状態とカーソル位置取得変数      */
    int d;              /*  = 0:押されるまで待つ/1:離されるまで待つ     */

    /*  マウスがクリックされたら終了    */
    d = 0;
    do {
        do {
            MOS_rdpos(&b, &p, &p);
        } while (b == d);
        d ^= 1;
    } while (d);

    return 0;
}

/************************************************************************

        setPalette ---- パレットの設定

*************************************************************************/
int setPalette(DWORD no, DWORD blue, DWORD red, DWORD green)
{
    struct  {
        DWORD   n;
        DWORD   no;
        UCHAR   blue;
        UCHAR   red;
        UCHAR   green;
        UCHAR   align;
    } paletteParam;

    paletteParam.n = 1;
    paletteParam.no = no;
    paletteParam.blue = (UCHAR)blue;
    paletteParam.red = (UCHAR)red;
    paletteParam.green = (UCHAR)green;
    paletteParam.align = 0;
    EGB_palette(gwk, 1, (char *)&paletteParam);

    return 0;
}
/************************************************************************

        init ---- 表示系の初期化処理

*************************************************************************/

int init(void)
{
    int page[2];       /*  画面モード          */
    int displayMode;   /*  画面表示状態        */
    int prior;         /*  画面優先順位        */

    if ((gwk = malloc(EgbWorkSize + MosWorkSize)) == NULL) {
        return -1;
    }
    mwk = gwk + EgbWorkSize;

    /*  色数を取得するため、いったん256色分のパレット取得領域を確保します */
    if ((pwk = malloc(PltWorkSize_256)) == NULL) {
        free(gwk);
        return -1;
    }

    EGB_getResolution(&page[0], &page[1]);
    EGB_resolution(gwk, 0, page[0] | 0x40); /* ページ#0の画面モード */
    EGB_resolution(gwk, 1, page[1] | 0x40); /* ページ#1の画面モード */

    /****************************************************
    *       書き込みページ設定                          *
    *    優先順位の高いページを書き込みページとします   *
    *    ただし, そのページが非表示状態であれば, 他方   *
    *    のページを書き込みページとします               *
    *****************************************************/
    /* 現在の書き込みページを退避 */
    orgWritePage = EGB_getWritePage(0, 0);

    prior = EGB_getDisplayPage(&prior, &displayMode);
    displayMode &= 3;   /* dispalyMode : 表示状態             */
    prior &= 0xff;      /* prior       : 優先度の高いページ   */
    switch (displayMode) {
        case 0: /* すべてのページが非表示状態   */
                    return 1;
        case 1: /* ページ#0のみ表示状態         */
        case 2: /* ページ#1のみ表示状態         */
                writePage = displayMode - 1;
                break;

        case 3: /* 全ページ表示状態             */
                writePage = prior;
    }
    /*---------------------------*/
    /*  書き込みページの設定     */
    /*---------------------------*/
    EGB_writePage(gwk, writePage);

    /************************************************************************
    *   パレットの初期設定                                                  *
    *     このサンプルプログラムでは16色モードのときにパレットを設定します  *
    ************************************************************************/
    if (EGB_getPalette(writePage, pwk) != -1 && (colors = *(int *)pwk) == 16)
        pwk = realloc(pwk, PltWorkSize_16);
        setPalette( 8,  32,  32,  32);
        setPalette(15,  64, 128, 128);

    } else {
        free(pwk);  /* パレット情報は必要ないのでメモリを解放します */
    }

   /*********************************
    *       マウスの初期設定        *
    *********************************/
    MOS_start(mwk, MosWorkSize);        /* マウス動作開始           */
    MOS_writePage(writePage);           /* マウス書き込みページ     */
    MOS_disp(0);                        /* マウスカーソルの消去     */

    return  0;
}

/************************************************************************

        term ---- 表示系の終了処理

*************************************************************************/
int term(void)
{
    if (colors == 16) {
    /*  元のパレットを復元                */
        EGB_palette(gwk, 1, pwk);
        free(pwk);
    }
    /*  元の書き込みページを復元          */
    EGB_writePage(gwk, orgWritePage);

    /*  マウス終了                        */
    MOS_disp(0);
    MOS_end();

    /*  サイドワークプロセス終了処理      */
    sdk_terminate(gwk, mwk, NULL);

    /*  作業領域のメモリを解放            */
    free(gwk);

    return 0;
}

/************************************************************************

        M A I N

*************************************************************************/
void main()
{
    sdk_start(0);                   /*  ｻｲﾄﾞﾜｰｸﾌﾟﾛｸﾞﾗﾑの動作開始        */
                                    /*  ヒープの拡張はしない            */

    if (init())                     /*  グラフィックスの初期化          */
        return;

    buildBox();                     /*  ボックス初期設定                */

    if (sdk_saveScrn(&frameWithShadow, writePage))  /*  画面退避        */
        return;

    showBox();                      /*  ボックス表示処理                */
    procsBox();                     /*  ボックス主処理                  */

    MOS_disp(0);
    sdk_loadScrn(&frameWithShadow, writePage);      /*  画面の復元      */

    term();                         /*  ｸﾞﾗﾌｨｯｸｽとｻｲﾄﾞﾜｰｸの終了処理     */

}

5.7 サイドワークプログラムのデバッグ方法

  サイドワークプログラムのデバッグにはツールキット付属のデバッガを利用します
。このときシンボルによるデバッグはできません。
  まず、サイドワークプログラムをデバッグするためにオリジナルプログラムとなる
適当な単独起動アプリケーションを386DEBUGによって起動します。

┌────────────────────────────────────┐
│  D> 386DEBUG APL                                                       │
└────────────────────────────────────┘
  サイドワークプログラムのデバッグを行うために、サイドワークプログラムに制御
が渡る場所をブレークポイントとして設定します。サイドワークプログラムは、サイ
ドワークドライバからセグメント間ジャンプによって制御が渡されます。ブレークポ
イントのアドレスは、TownsOS V2.1 L20までは固定値(00017104H)でしたが、V2.1 L30
以降ではシステム設定状態によって変動します。その値は以下のように算出します。
  まず、｢ビデオモードON｣の場合は、いったん｢ビデオモードOFF｣にしてください。

386debug起動後に、アドレス110:20を参照してください。
  [80386 protected mode]
  -dd 110:20
  0110:00000020 00017000 ....[省略]....

  110:20Hに格納されている値(この例では00017000H) に104Hを加算した値(この例の
場合は00017104H)が、ブレークポイントとなります。

┌────────────────────────────────────┐
│  -u 110:17104                                                          │
│  0110:00017104 CB                       RETF                           │
└────────────────────────────────────┘
  このアドレスにブレークポイントを設定することによって、まずサイドワークプロ
グラム選択メニューに制御が渡る直前でデバッガが停止します。ひき続きGコマンドに
よって実行を続行し、次に停止したところがデバッグ対象のプログラムの直前(1ステ
ップ前)となります。

- 例 -
┌────────────────────────────────────┐
│-bp 110:17104                                                           │
│-g                                                                      │
│Breakpoint at 0110:00017104 Elapsed time = XX.X seconds                 │
│EAX=00000000  EBX=00000000  ECX=00000000  EDX=00000000                  │
│ESI=00000000  EDI=00000000  EBP=00000000  ESP=000XXXXX                  │
│CS:EIP=0110:00017104  EFLAGS=00000246    NV  UP  EI  PL  ZR  NA  PO  NC │
│0110:00017104 CB                       RETF                             │
│-g    [  サイドワークプログラム選択メニューを実行  ]                    │
│Breakpoint at 0110:00017104 Elapsed time = XX.X seconds                 │
│EAX=00000000  EBX=00000000  ECX=00000000  EDX=00000000                  │
│ESI=00000000  EDI=00000000  EBP=00000000  ESP=000XXXXX                  │
│CS:EIP=0110:00017104  EFLAGS=00000246    NV  UP  EI  PL  ZR  NA  PO  NC │
│0110:00017104 CB                       RETF                             │
│- [ ここがデバッグ対象プログラムに制御が移る1ステップ前  ]              │
└────────────────────────────────────┘
  ここで、1ステップ実行によってサイドワークプログラムの実行開始アドレスに制御
移行できます。
┌────────────────────────────────────┐
│-t                                                                      │
│EAX=00000000  EBX=00000000  ECX=00000000  EDX=00000000                  │
│ESI=00000000  EDI=00000000  EBP=00000000  ESP=000XXXXX                  │
│DS=00XX  SS=00XX  ES=00XX  FS=00XX  GS=00XX                             │
│CS:EIP=00XX:XXXXXXXX  EFLAGS=00000202    NV  UP  EI  PL  NZ  NA  PO  NC │
│00XX:XXXXXXXX EBXX                     JMP      XXXXXXXX                │
│-                                                                       │
└────────────────────────────────────┘
              ▲サイドワークプログラムの開始アドレスに制御移行

  シンボリックデバッグはできないので、これ以降のデバッグはMAPファイルを参照し
ながら行います。

6 アプリケーションとサイドワーク

6.1 アプリケーションプログラムからのサイドワーク起動

  アプリケーションからサイドワークを起動する手段をユーザに提供することができ
ます。たとえば、標準システムの多くのアプリケーションは画面上にサイドワーク起
動用のアイコンを設けています。以降にアプリケーションからサイドワークプログラ
ムを起動するためのライブラリ関数を解説します。

■アプリケーション開発時のサイドワークライブラリの使用方法

  ┌─────────────┐
  │    apl                   │
  │    -exe apl              │
  │    -lib ..\lib\tbios     │
  │    -lib ..\lib\t_os      │
  │    -lib ..\lib\hce       │
  │          …              │
  │    -stack 77824          │
  │    -symbol               │
  │    -twocase              │
  └─────────────┘
      ▲リンカ応答ファイル例

6.2 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│sdk_invoke                │ｱﾌﾟﾘｹｰｼｮﾝからのｻｲﾄﾞﾜｰｸﾌﾟﾛｸﾞﾗﾑ起動         │
├─────────────┼─────────────────────┤
│sdk_setEntrance           │ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ起動時のﾕｰｻﾞ割り込みﾙｰﾁﾝの登録│
├─────────────┼─────────────────────┤
│sdk_setExit               │ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ終了時のﾕｰｻﾞ割り込みﾙｰﾁﾝの登録│
├─────────────┼─────────────────────┤
│sdk_delEntrance           │ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ起動時のﾕｰｻﾞ割り込みﾙｰﾁﾝの抹消│
├─────────────┼─────────────────────┤
│sdk_delExit               │ｻｲﾄﾞﾜｰｸﾌﾟﾛｾｽ終了時のﾕｰｻﾞ割り込みﾙｰﾁﾝの抹消│
└─────────────┴─────────────────────┘

6.3 各関数の解説

-----------------------------------------------------------------------------
.sdk_delExit 
サイドワークプロセス終了時のユーザ割り込みルーチンの抹消
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int     sdk_delExit(void);

- 戻り値 -
0 :正常終了

- 内容 -
サイドワークプロセスが終了したときに引き続き制御が渡るユーザ割り込みルーチン
の抹消を行います。sdk_setExit関数によって登録したユーザ割り込みルーチンは、
適宜本関数よって抹消してください。

-----------------------------------------------------------------------------
.sdk_delEntrance 
サイドワークプロセス起動時のユーザ割り込みルーチンの抹消
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int     sdk_delEntrance(void);

- 戻り値 -
0 :正常終了

- 内容 -
サイドワークプロセスが起動するときに先立って制御が渡るユーザ割り込みルーチン
の抹消を行います。sdk_setEntrance関数によって登録したユーザ割り込みルーチンは
、適宜本関数によって抹消してください。

-----------------------------------------------------------------------------
.sdk_invoke
アプリケーションからのサイドワークプログラム起動
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int     sdk_invoke(void); 

- 戻り値 -
 0〜255  :サイドワークプログラムの終了コード
-1       :サイドワークが未インストール
上記以外 :サイドワークプログラムが起動不可能

- 内容 -
アプリケーションプログラムからサイドワークを呼び出します。
これによりサイドワークプログラム選択プログラムが起動されます。
サイドワークはあらかじめインストールされている必要があります。

-----------------------------------------------------------------------------
.sdk_setEntrance 
サイドワークプロセス起動時のユーザ割り込みルーチンの登録
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int     sdk_setEntrance(void_far_(*func)(), unsigned dataSel);
void_far (*func)();    /*  割り込みルーチンのfarアドレス           */
unsigned dataSel;      /*  割り込みルーチン制御移行時に設定される  */
                       /*  データセグメントセレクタ値              */
- 戻り値 -
0 :正常終了

- 内容 -
サイドワークプロセスが起動するときに先立って制御が渡るユーザ割り込みルーチン
の登録を行います。ユーザ割り込みルーチンはfarコールされます。ユーザ割り込みル
ーチン内でのレジスタ、フラグの保存は不要です。ユーザ割り込みルーチンに制御移
行したときに、すべてのセグメントセレクタはdataSelで指定した値に設定されます。
dataSelに0を指定したときには便宜上、本関数を呼び出したときのデータセグメント
セレクタの値がそのまま設定されます。

-----------------------------------------------------------------------------
.sdk_setExit 
サイドワークプロセス終了時のユーザ割り込みルーチンの登録
-----------------------------------------------------------------------------

- 定義 -
#include <sidework.h> 
int     sdk_setExit(void_far (*func)(), unsigned dataSel);
void_far (*func)();    /*   割り込みルーチンのfarアドレス            */
unsigned dataSel;      /*   割り込みルーチン制御移行時に設定されます */
                       /*   データセグメントセレクタ値               */
- 戻り値 -
0 :正常終了

- 内容 -
サイドワークプロセスが終了したときに引き続き制御が渡るユーザ割り込みルーチン
の登録を行います。ユーザ割り込みルーチンはfarコールされます。ユーザ割り込みル
ーチン内でのレジスタ、フラグの保存は不要です。ユーザ割り込みルーチンに制御移
行したときに、すべてのセグメントセレクタはdataSelで指定した値に設定されます。
dataSelに0を指定したときには便宜上、sdk_setEntrance関数を呼び出したときのデー
タセグメントセレクタの値がそのまま設定されます。

*****************************************************************************
第5章  オーバレイライブラリ
*****************************************************************************

1 オーバレイライブラリについて

1.1 概要

  オーバレイライブラリは、Child Process相当をサポートするライブラリです。
  アプリケーションはモジュール化することにより、様々な利点があります。
  たとえば、メンテナンス効率の向上、そのモジュールを入れ換えることにより多様
の対応が可能となります。さらには、最近のシステムの高機能化にともなうアプリケ
ーション領域の圧迫を回避することなどです。使用頻度の少ないモジュールを外部モ
ジュールとしたり、大量のメモリを必要とするモジュールは単一モジュールにするこ
となどによる実現が考えられます。

1.2 動作モードについて

  動作モードは次の2種類です。最適なモードを選択してください。

 1)スモールモード
   スモールモードでは子プロセス起動時に、親プロセスがメモリから消去され、子プ
   ロセスがローディングされます。子プロセス終了時には、親プロセスは再ローディ
   ングされ、再起動されます。(子プロセス起動直前の状態には戻りません。)

   図EXL121R-009

 2)ラージモード
   ラージモードでは子プロセス起動時にも、親プロセスはメモリ上にあります。子プ
   ロセス終了時には、制御は子プロセス起動される直前の親プロセスの状態に渡りま
   す。スモールモードより多くのメモリを必要とします。

   図EXL121R-010

  ハッチング部分は、読み込まれた部分を示します。

1.3 基本動作フロー

  以下に、本ライブラリを使用したときの基本的なサンプルフローチャートを示しま
す。

  図EXL121R-011

1.4 注意事項

 (1)呼び出されたプロセスおよび呼び出す側のプロセスについて

  1 呼び出しプロセス側
   ･割り込みベクタを使用してユーザハンドラを生成している場合は、自プロセスが
    呼び出される以前の環境に戻してください。
    (特にハードウェア割り込みに関して)
   ･プロセスを呼び出すためのメモリ獲得はページ(4Kバイト)パラグラフでなくては
    なりません。
   ･ラージモード時のPCBはコンスタントでもスタティックでもかまいませんが
    pcl_detach_proc関数を呼び出すまではコンスタントデータである必要がありま
    す。
   ･プロセスを呼び出しそのプロセスから戻ってきた時点でカレントドライブおよび
    カレントパスは変更されている恐れがあるため、呼び出し以前の環境を引き継い
    でアクセスすることは危険です。

  2 呼び出されたプロセス側
   ･リアルコードが混在していてはいけません。
   ･High Cライブラリを使用している場合は、終了時にexit関数で終了しないでくだ
    さい。ラージモードで呼び出された場合にHigh Cライブラリがリカーシブルコー
    ルを考慮していないため、2回目以降のライブラリ動作が正常動作しない恐れがあ
    ります。

 (2)リンク
    リンク時には、本ライブラリがプログラムの先頭に配置されるようにオブジェク
    トを配置してください。LOADER.OBJ、PCPTOOL.OBJ、PCP_DTA.OBJ、PCP_EXIT.OBJ
    の順にリンクし、出力されるマップファイルが下記のようになっていることを確
    認してください。

┌────────────────────────────────────┐
│386 |LINK:X.X -- Copyright (C) 1986-Phar Lap Software,Inc.              │
│Target CPU is 80386                                                     │
│--------------  省略  --------------                                    │
│Segment map                                                             │
│    Name         Group      Class      Type      Offset      Size       │
│LOADER         CGROUP       CODE       PVT      00000000    00000A60    │
│LOADER         CGROUP       CODE       PVT      00000A60    00000BA1    │
│LOADER         CGROUP       CODE       PVT      00001604    00011000    │
│  .               .           .         .           .           .       │
│  .               .           .         .           .           .       │
└────────────────────────────────────┘
   また、オーバレイアプリケーション作成時には、リンクオプションに-packオプシ
   ョンを使用しないでください。

 (3)デバッグ
    本ライブラリにロードされる側のアプリケーションプログラムは、シンボリック
    デバッグおよび、MAPファイルによるデバッグはできません。十分テストを行った
    あとに、オーバレイ化し、printf関数などによるデバッグを行ってください。

 (4)起動状態の取得方法
    各プロセスは起動時に自プロセスを、PCLに対して宣言する必要があります。
    (｢3.3 各関数の解説  pcl_init_loader関数｣参照)
    このとき、自プロセス名ドライブ名を含むフルパスで指定する必要があります。
    (｢3.3 各関数の解説 GB_getStartPath関数｣参照)
    また、各プロセスは起動時に、自プロセスの起動状態を判断し、その状態にあっ
    た動作を行わなければなりません。
    自プロセスの状態の起動状態は大きく以下の3つの状態をとります。
     ･メニューから(ユーザから)の起動                   :通常起動状態
     ･スモールモードでの子プロセス実行終了による再起動 :再起動状態
     ･他のプロセスから子プロセスとして起動             :子プロセス起動状態
    上記の3つの状態は、以下の関数値を組み合わせて判断してください。

┌──────────┬────────────┬────────────┐
│                    │  pcl_get_dta() == 0    │   pcl_get_dta() != 0   │
├──────────┼────────────┼────────────┤
│pcl_init_load() == 0│                        │  通常起動状態          │
├──────────┤  子プロセス起動状態    ├────────────┤
│pcl_init_load() != 0│                        │   再起動状態           │
└──────────┴────────────┴────────────┘

 (5)子プロセスの存在の有無のチェック
    PCL自体にはMMI部がありませんのでエラーのハンドリングはすべてアプリケーシ
    ョン自身が行う必要があります。
    特に、スモールモードでの子プロセス実行時(｢3.3 各関数の解説 pcl_load_exec
    関数｣参照)には対象となる子プロセスの存在の有無を確認(fopen関数など)したあ
    とに実行してください。

 (6)起動パス名の取得方法
    GB_getStartPath関数を用いて、自プロセスの起動パス名をドライブ名を含むフル
    パスで取得することができます。この関数は自プロセスの起動パス指定が相対的
    な指定で行われている場合、カレントドライブ/カレントディレクトリを基準にフ
    ルパス名を作成します。
    このため、各プロセスは起動時には、起動環境を変更する前にこの関数を用いて
    自プロセスの起動パスを取得しなければなりません。また、子プロセスは終了時
    には起動時と同じ環境で、親プロセスに制御を戻す必要があります。

 (7)GUIライブラリと併用する場合
    GUIライブラリ(別売)と本ライブラリを併用する場合には、必ず下記の手順を守っ
    てください。

  1)スモールモードの場合
   ･オーバレイを起動するときには、GUIライブラリを終了してください。

            ･
            ･
      MMI_SetHaltflag(1); 
      overLay = ON; 
    }

   ･main関数に戻ってきたときに、オーバレイの必然性をチェックし、必要ならば
    起動します。

    if (APL_init() == NOERR)
        MMI_ExecSystem(); 
    }
    MMI_Close();
    if (overlay)
    {
        /*  オーバレイ･スモールモードの起動処理  */
    }

  2 ラージモードの場合
   ･メモリロットIDを獲得します。

    if ((lotID = TL_getLot()) > NOERR)
    {

   ･アプリケーションロードに必要なメモリを獲得します。
 
      if ((memAddr = TL_mallocMemory(lotID, memSize))!=NULL)
      {

   ･オーバレイが使用できるようにメモリを再配置します。

            TL_extendMemory(memAddr, memSize, &loadAddr, &applSize); 

   ･GUIライブラリの停止

            MMI_pauseSystem();

   ･オーバレイ･ラージモードの起動

            /*  オーバレイ･ラージモードの起動処理  */

   ･GUIライブラリの再開

            MMI_continueSystem(); 

   ･再度配置したメモリの廃棄

            TL_disposeMemory();
        }

   ･メモリロードの解放(このとき獲得されたメモリも一緒に解放されます。)

        TL_freeLot(lotID); 
    }

2 DTAについて

2.1 概要

  DTA(Data Transfer Area)は、プロセス間通信を行うための領域です。
  プロセス間で受け渡されるデータは次の2つに大別されます。

 (1)プロセスの実行状態(Exec Status)
    子プロセスのロード成否、子プロセスの終了状態など

 (2)プロセスの参照データ(Operation / Command Data)
    編集ファイル名など

  今回提供のオーバレイライブラリでは、DTA内のデータフォーマットについては提供
していません。オーバレイを用いたアプリケーションを構築する場合、親/子プロセス
間での閉じた(ローカルな)仕様に基づいてデータの受け渡しを行ってください。
  富士通提供のアプリケーション(FORMAT.exp / GX16.exp など)をターゲットにした
アプリケーション開発は行わないでください。
  各アプリケーションプログラムの設計においては以下の事柄に注意してください。

  ･通常データ領域は受け渡し不可
   プロセス間での参照データの受け渡しは、原則的にDTA領域のみで可能で、親プロ
   セス内の通常データ領域を参照することはできません。
   ただし、VRAM/WAVE-RAM内のデータを参照することは可能です。

  ･サイズ固定
   DTAのサイズなどは、親プロセスリンク時に決定され、ダイナミックに変更される
   ことはありません。

  ･セレクタが違う
   親プロセスからは、通常のデータ領域と同一のセレクタで参照可能ですが、子プロ
   セスからは通常データ領域とは異なるデータセレクタで参照しなければなりません
   。

  ･復帰情報の格納
   スモールモードでの子プロセス起動の際、親プロセスの復帰情報をDTA内に保存し
   ておく必要があります。

2.2 プロセス間のDTA関係

  プロセス間のDTA関係を下記に示します。

      ┌──────┐
      ├──────┤
      │   DTA 1    │───┬───────┐
      ├──────┤      │              │
      │ Process 1  │      │              │
      │            │      │              │
      └──────┘      │              │
                            │              │
                    ┌──────┐  ┌──────┐
                    ├──────┤  ├──────┤
                    │   DTA 2    │  │   DTA 3    │──┐
                    ├──────┤  ├──────┤    │
                    │ Process 2  │  │ Process 3  │    │
                    │            │  │            │    │
                    └──────┘  └──────┘    │
          ┌───────────┬───────────┤
          │                      │                      │
          │                      │                      │
  ┌──────┐        ┌──────┐        ┌──────┐
  ├──────┤        ├──────┤        ├──────┤
  │   DTA 4    │        │   DTA 5    │        │   DTA 6    │
  ├──────┤        ├──────┤        ├──────┤
  │ Process 4  │        │ Process 5  │        │ Process 6  │
  │            │        │            │        │            │
  └──────┘        └──────┘        └──────┘
  
     DTA 1  ← Process 2 / Process 3
     DTA 3  ← Process 4 / Process 5 / Process 6

  上記のように、呼び出したプロセス内のDTA領域が、呼び出されたプロセスのDTA
領域となります。

3 オーバレイライブラリ

3.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│pcl_init_loader           │PCLライブラリの初期化                 　　│
├─────────────┼─────────────────────┤
│pcl_load_file             │実行ファイルのロード(ハンドルの取得)  　  │
├─────────────┼─────────────────────┤
│pcl_load_exec             │実行ファイルの実行                        │
├─────────────┼─────────────────────┤
│pcl_exec_proc             │すでにﾛｰﾄﾞされている実行ﾌｧｲﾙへ制御を渡す  │
├─────────────┼─────────────────────┤
│pcl_detch_proc            │実行ハンドルのプログラム環境の削除        │
├─────────────┼─────────────────────┤
│pcl_check_exe             │必要なメモリ量の獲得                      │
├─────────────┼─────────────────────┤
│pcl_exit                  │自プログラムの終了                        │
├─────────────┼─────────────────────┤
│pcl_get_dta               │DTAアドレスの取得                     　　│
├─────────────┼─────────────────────┤
│pcl_check_error           │詳細エラーコードの取得                    │
├─────────────┼─────────────────────┤
│pcl_reset_error           │詳細エラーコードのリセット                │
├─────────────┼─────────────────────┤
│GB_getStartPath           │起動パス名の取得                          │
└─────────────┴─────────────────────┘

3.2 各関数の解説

-----------------------------------------------------------------------------
.GB_getStartPath
起動パス名の取得
-----------------------------------------------------------------------------

- 定義 -
#include <loader.h> 
void    GB_getStartPath(char *pathname, int func);
int     func; /* 取得モード 0: 文字列の最後に'\\'コードを付ける   */ 
              /*        0以外: 文字列の最後に'\\'コードを付けない */ 

- 戻り値 -
char    *pathname; /* 起動フルパス名          */

- 内容 -
自プロセスの起動パス名をドライブ名を含むフルパス名で返します。
ただし、文字列内はすべて大文字です。

- 注意 -
本関数は自プロセスの起動パス指定が相対的な指定で行われている場合、カレントド
ライブ/カレントディレクトリを基準にフルパス名を作成します。
このため、各プロセスは起動時には、起動環境を変更する前に本関数を用いて自プロ
セスの起動パスを取得しなければなりません。また、子プロセスは終了時には起動時
と同じ環境で、親プロセスに制御を戻す必要があります。
ただし、Townsシェルアプリケーションを作成する場合には、本関数で起動パス名を取
得することはできません。使用した場合に得られたパス名は不定です。
本関数の代わりに、拡張ライブラリIIのMMI_CallMessage関数(第2パラメータ:QM_QUER
YID、第3パラメータ:QM_PATH)を使用して、起動パス名を取得してください。

-----------------------------------------------------------------------------
.pcl_check_error 
詳細エラーコードの取得
-----------------------------------------------------------------------------

- 定義 -
#include <loader.h> 
int     pcl_check_error(void);

- 戻り値 -
0     :正常終了
0以外 :エラーコード

┌────────────────┬───────────────────┐
│          エラーコード          │             内          容           │
├─────────────┬──┼───────────────────┤
│LERR_DISK_NOTREADY        │   1│ドライブの準備ができていません        │
├─────────────┼──┼───────────────────┤
│LERR_FILE_NOTFOUND        │   2│ファイルが存在しません                │
├─────────────┼──┼───────────────────┤
│LERR_READ_FAILE           │   3│リードエラー                          │
├─────────────┼──┼───────────────────┤
│LERR_HANDLE_ILL           │ 256│実行ハンドル番号が誤っています        │
├─────────────┼──┼───────────────────┤
│LERR_FILE_ILL             │ 257│未サポートファイルタイプです          │
├─────────────┼──┼───────────────────┤
│LERR_MEM_POOR             │ 258│メモリが足りません                    │
├─────────────┼──┼───────────────────┤
│LERR_POOR_HANDLE          │ 259│すでにロードしているハンドルがあります│
│                          │    │(スモールモード)                   　 │
└─────────────┴──┴───────────────────┘

- 例 -
#include <loader.h> 

int     ret ; 

ret = pcl_check_error(void);

- 内容 -
詳細なエラーコードを返します。本エラーコードはpcl_reset_error関数または、
pcl_check_error関数が呼び出されるまでリセットされません。

-----------------------------------------------------------------------------
.pcl_check_exe 
必要なメモリ量の獲得
-----------------------------------------------------------------------------

- 定義 -
#include <loader.h> 
int     pcl_check_exe(char *file_name, NEED_PAGE *need_block);
char    *file_name;    /* プログラムフルパス名(ドライブ名も含む) */

- 戻り値 -
0     :正常終了 
       need_blockに対してそのプログラムが動作するために必要な最低のメモリサイ
       ズと最大のメモリサイズを返します
0以外 :異常終了

- 例 -
#include <loader.h> 

int         ret;
char        *file_name; 
NEED_PAGE   *need_block;

ret = pcl_check_exe(file_name, need_block); 

- 内容 -
指定されたパス名のプログラムがどれだけのメモリを必要としているか通知します。
エラーの詳細を知りたい場合は、pcl_check_error関数を使用してください。

-----------------------------------------------------------------------------
.pcl_detch_proc
実行ハンドルのプログラム環境の削除
-----------------------------------------------------------------------------

- 定義 -
#include <loader.h> 
int     pcl_detch_proc(int exe_handle);
int     exe_handle;      /* 実行ハンドル番号  */

- 戻り値 -
0     :正常終了
0以外 :異常終了

- 例 -
#include <loader.h> 

int     ret;
int     exe_handle; 

ret = pcl_detch_proc(exe_handle);

- 内容 -
指定された実行ハンドルの環境を削除します。
削除が成功した場合は戻り値0となり、削除に失敗した場合は0以外の値が戻ります。
エラーの詳細を知りたい場合は、pcl_check_error関数を使用してください。

-----------------------------------------------------------------------------
.pcl_exec_proc
すでにロードされている実行ファイルへ制御を渡す
-----------------------------------------------------------------------------

- 定義 -
#include <loader.h> 
int     pcl_exec_proc(int exe_handle, char *exe_pointer, int exe_size);
int     exe_handle;       /*  実行ハンドル番号  */
char    *exe_pointer;     /*  実行アドレス      */
int     exe_size;         /*  実行サイズ        */

- 戻り値 -
0     :(正常終了時は出力なし)
0以外 :異常終了

- 例 -
#include <loader.h> 

char    *exe_pointer;
char    exe_handle, exe_size, ret;

ret =  pcl_exe_proc(exe_handle, exe_pointer, exe_size);

- 内容 -
指定されたハンドルに対して制御を渡します。実行アドレスはpcl_load_file関数で
指定したロードアドレスと同一でなくても構いません。

-----------------------------------------------------------------------------
.pcl_exit
自プログラムの終了
-----------------------------------------------------------------------------

- 定義 -
#include <loader.h> 
void      pcl_exit(int ret_code);
int       ret_code;    /*   自プログラムの終了コード   */ 

- 戻り値 -
なし

- 例 -
#include <loader.h> 

int       ret_code; 

pcl_exit(ret_code);

- 内容 -
プログラムを終了します。本ファンクションは主に、本ライブラリを使用して呼び出
された側のプログラムに使用します。基本的には、アセンブラ言語のみでコーディン
グされたプログラムの場合は本ファンクションを使用する必要はありません。

-----------------------------------------------------------------------------
.pcl_get_dta 
DTAアドレスの取得
-----------------------------------------------------------------------------

- 定義 -
#include <loader.h> 
int     pcl_get_dta(ADDRESS *dta_address);

- 戻り値 -
0     :正常終了
0以外 :異常終了

- 例 -
#include <loader.h> 

int     ret;
ADDRESS *dta_address;

ret = pcl_get_dta(dta_address); 

- 内容 -
DTAアドレスを取得します。本ファンクションは自プロセスが、本ライブラリを使用し
て呼び出された場合のみ、正常終了します。その他の場合は異常終了となります。

-----------------------------------------------------------------------------
.pcl_init_loader
PCLライブラリの初期化
-----------------------------------------------------------------------------

- 定義 -
#include <loader.h> 
int     pcl_init_loader(char *start_path);
char    *start_path;  /*自プロセスの実行フルパス名            */
                      /*                     (ﾄﾞﾗｲﾌﾞ名も含む) */

- 戻り値 -
0     :正常終了
0以外 :正常終了(子プロセスから戻った場合)

- 例 -
#include <loader.h> 

int     ret;
char    strart_path[ ]="a:\SMP.EXP";

ret =  pcl_init_loader(start_path);

- 内容 -
本ライブラリのコントロール･データを初期化します。
さらに、戻り値を調べることにより、自プロセスが呼び出したプロセスから戻って来
たのか否かを知ることが可能です。

-----------------------------------------------------------------------------
.pcl_load_exec
実行ファイルの実行
-----------------------------------------------------------------------------

- 定義 -
#include <loader.h> 
int     pcl_load_exec(char *file_name);
char    *file_name;     /*  プログラムフルパス名 (ﾄﾞﾗｲﾌﾞ名も含む) */

- 戻り値 -
0     :正常終了
0以外 :異常終了

- 例 -
#include <loader.h> 

int     ret;
char    *file_name; 

ret =  pcl_load_exec(file_name);

- 内容 -
自プロセスのメモリを開放して、その開放されたメモリに指定されたパス名のファイ
ルを読み込み、実行します。エラーが発生した場合は戻り値が0となります。
エラーの詳細を知りたい場合は、pcl_check_error関数を使用してください。

-----------------------------------------------------------------------------
.pcl_load_file
実行ファイルのロード(ハンドルの取得)
-----------------------------------------------------------------------------

- 定義 -
#include <loader.h> 
int     pcl_load_file(char *file_name, char *load_pointer, PCB *work);
char    *file_name;     /*  プログラムフルパス名 (ﾄﾞﾗｲﾌﾞ名も含む)  */
char    *load_pointer;  /*  ロードするメモリのアドレス             */
char    *work;          /*  ロードするプログラムを管理するテーブル */

- 戻り値 -
0     :異常終了
0以外 :実行ハンドル

- 例 -
#include <loader.h> 

int     ret;
char    *file_name,  *load_pointer;
PCB     *work 
int     exe_handle; 

exe_handle =  pcl_load_file(file_name,load_pointer,work);

- 内容 -
指定されたパス名の実行ファイルを指定されたメモリにロードします。
ロードが成功した場合は、そのロードされた実行ハンドルを返します。
エラーが発生した場合は戻り値が0となります。
エラーの詳細について知りたい場合は、pcl_check_error関数を使用してください。

-----------------------------------------------------------------------------
.pcl_reset_error 
詳細エラーコードのリセット
-----------------------------------------------------------------------------

- 定義 -
#include <loader.h> 
void      pcl_reset_error(void);

- 戻り値 -
なし

- 例 -
#include <loader.h> 

pcl_reset_error();

- 内容 -
内部エラーコードをリセットします。


3.3 サンプルプログラム

┌────────────────────────────────────┐
│  オーバレイライブラリ  サンプルプログラム                              │
│  ■  機能  ■                                                          │
│    hello.exp をラージモードとスモールモードで呼び出します。            │
└────────────────────────────────────┘
/**************************************************************************

    オーバレイライブラリサンプルコーディング

       ovlsmp.exp :
       必要なメモリを獲得し､ラージモードでhello.expをロードし､繰り返し
       実行します さらに､スモールモードでhello.expをロード･実行します
       コマンドモードで実行してください

       ex. RUN386 -nocrt ovlsmp.exp

**************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <loader.h>
#define GET_MEMSIZE  0x100000

void main(){

        /****************************************************/
        /* 本プログラムは最後にスモールモードを実行するため */
        /* 永遠にプログラムはループします  終了するときは   */
        /* ctrl-Cを入力してください                         */
        /****************************************************/

    char *temp1;
    PCB   temp2;
    int   handle;
    int   proc_exit_code;
    int   temp3;

    if(pcl_init_loader("ovlsmp.exp"))
        printf("二回目以降の呼び出しです\n");
    else
        printf("第一回目の呼び出しです\n");

    if ( (temp1 = malloc(GET_MEMSIZE)) != NULL ){
        printf("ラージモードの実行を行います\n");
        if ((handle = pcl_load_file("hello.exp",temp1,&temp2)) == 0 ){
            printf("実行不可能なファイルタイプです\n");
            exit(0);
        }
        for ( temp3 = 0 ; temp3 != 10 ; temp3++ ){
            printf("第 %d 回目の呼び出しを行います\n",temp3);
            if ((proc_exit_code = pcl_exec_proc(handle,\                            
                temp1,GET_MEMSIZE)) == -1L){
                printf("エラー終了  ｴﾗｰｺｰﾄﾞ = %08LX \n",proc_exit_code);
                exit(0);
            }
            printf("呼び出しが終了しました\n");
        }
        pcl_detach_proc(handle);
    } else {
       printf("メモリが足りません  ラージモードが実行できません\n"); 
    }
    printf("スモールモードの実行を行います\n");
    pcl_load_exec("hello.exp");
}

/**************************************************************************

       hello.exp :
       "Hello, world"と画面に表示します

**************************************************************************/
#include <loader.h>
main () {
   ADDRESS temp;
   printf("Hello, world.\n");
   pcl_get_dta(&temp);
   pcl_exit(0); 
   return (0);
}

*****************************************************************************
第6章  TIFFライブラリ
*****************************************************************************

1 TIFFライブラリについて

1.1 概要

  本ライブラリは以下の機能をサポートしています。

  ･TIFFのヘッダ(タグ)情報の解析
  ･TIFF仕様のLZW圧縮/展開ルーチン
  ･TIFFデータの読み込みと表示可能な形式への展開
  ･FM TOWNS標準のTIFFヘッダ情報の作成

  TIFFデータとしてサポートしている形式は、Packed Pixel形式のビットマップで、
ピクセルあたりのビット数が1(2値)、4(16色)、8(256色)、16(32K色)、24(16M色)のも
のです。
  TIFFのリーダ部分については、FM TOWNSの標準TIFFの他に、Macintosh、MS-Windows
などのTIFFもある程度読めるようにしています。
  データローダは、24ビットピクセル以外は、グラフィックライブラリでそのまま出
力することのできる形式に変換します。ただし、本ライブラリがサポートするのは、
バッファからバッファの操作なので、ファイルの読み書きや実際の描画などは、アプ
リケーション側で処理を行う必要があります。TOWNSで扱うTIFFファイル形式の詳細に
ついては、｢付録Towns標準TIFFについて｣を参照してください。

1.2 使用方法

  TIFFデータを読み込んで表示する場合と、TIFFデータを作成する場合について解説
します。

 (1)TIFFデータのロード
    本ライブラリは、メモリ上にあるヘッダ情報を含むTIFFデータから、FM TOWNSの
    画面に表示可能な形式のデータを生成します。つまり、アプリケーションはファ
    イルイメージのバッファ(ロードバッファ)と展開先(展開バッファ)の2つのバッフ
    ァを用意する必要があります。
    また圧縮TIFFの展開のためには、これらのバッファとは別にDECOMP_WORK_SIZE
    (tifflib.hで定義)バイト固定の作業領域が必要となります。

    TIFFデータをファイルから読み込み、画面に表示する場合は以下の操作を行って
    ください。

    1)ファイルをオープンし、バッファ上にヘッダを含むファイルの最初の部分を読
      み込みます。
    2)TIFFヘッダ解析ルーチン(TIFF_getHead関数)を呼びます。
    3)ヘッダから必要な情報を取り出し、アプリケーションで読み込み可能な形式で
      あることを確認します。(TIFF_checkMode関数)
    4)TIFFの種類にしたがって、画面モードなどを設定します。
    5)必要なら、パレットデータを取り出します。(TIFF_getPal関数) 
    6)データの取り出し(画面への出力)とバッファへのロード(ファイルからのリード
      )のルーチンを登録します。(TIFF_setFunc関数)
    7)TIFF_setReadFuncでファイルからの任意位置のリード関数を登録します。
      この処理はなくてもTOWNS上の一般的なTIFFを扱うのに支障はありませんが、
      より広範囲のTIFFファイルを読むことを可能にします。
    8)TIFFのロードルーチン(TIFF_loadImage関数)をコールします。

  呼び出し側で用意する3つのバッファは最低限、以下の大きさを確保してください。

      ･ロードバッファ    ヘッダサイズ + 1ラインのデータサイズ
                         (256色パレット付き横1024ドットの場合、3Kバイト)
      ･展開バッファ      1ライン分のデータサイズ
      ･圧縮展開バッファ  DECOMP_WORK_SIZEバイト(現バージョンでは16K)

    したがって、一通りのTIFFを読む場合は、最低3+1+16=20Kバイトのバッファが必
    要になります。その他、圧縮展開ルーチン内では、最大20Kバイトのスタックを
    消費するので注意してください。また、ロードバッファと展開バッファは大きい
    ほど処理が高速になります。ロードバッファはバイト単位、展開バッファは1ライ
    ン分のデータ単位になります。圧縮展開のバッファは、非圧縮データの場合必要
    ないので、その場合は展開バッファに振り分けるなどの工夫をしてください。
    展開されたデータは、グラフィックライブラリのEGB_putBlock関数で利用できる
    形式になっています。必要に応じて16色の場合の4バイトバウンダリの処理をする
    こともできます。単純に画面に表示するだけの場合は、6で登録する関数内で、
    EGB_putBlock関数を呼び出すだけです。
    なんらかのコンバートが必要な場合は、この関数内で処理します。

 (2)TIFFデータのセーブ
    本ライブラリは、メモリ上にあるVRAMイメージのデータを、TIFF形式のデータに
    変換します。呼び出し側は、VRAMイメージのバッファ(イメージバッファ)とTIFF
    ファイルに書きだすデータを格納するバッファ(セーブバッファ)の2つのバッファ
    を用意する必要があります。またTIFFの圧縮セーブを行うためには、これらのバ
    ッファとは別にCOMP_WORK_SIZE(tifflib.hで定義)バイトの作業領域が必要になり
    ます。

    画面上のデータを、TIFFファイルとしてセーブする場合は、以下の操作を行って
    ください。

    1)ファイルをオープンし、ヘッダのサイズ(256色パレット付きでは2048バイト、
      その他では512バイト)分シークします。
    2)画面データの取り出しルーチンと、ファイルへ書き出すルーチンを登録します
      。(TIFF_setSaveFunc関数)。
    3)TIFFのセーブルーチン(TIFF_saveImage関数)をコールします。
    4)ヘッダ情報を作ります(TIFF_setHead関数)。
    5)ファイルを先頭にシークして、ヘッダを書き出します。

    ヘッダ情報を後から作るのは、圧縮TIFFの場合圧縮されたサイズがヘッダに入る
    ためです。

    呼び出し側で用意する3つのバッファは最低限以下の大きさを確保してください。
      ･イメージバッファ  1ライン分のデータサイズ
      ･セーブバッファ    任意
      ･圧縮展開バッファ  COMP_WORK_SIZEバイト(現バージョンでは65Kバイト)

    イメージバッファは行単位の大きさで設定しますが、画像の横サイズ以上の仮想
    サイズを一行の長さとして設定することができます。すなわち、16色モードでグ
    ラフィックライブラリのEGB_getBlock関数で取得したものや、EGB_resolutionRam
    関数で設定されたバッファが使用可能です。

1.3 エラーについて

    int tiff_err

  TIFFライブラリのエラーコードが上記に格納されます。一般に本ライブラリ中の
関数は、正常終了で0を返し、異常終了の場合tiff_errにエラーコードをセットし、
-1でリターンします。
  エラーコードは、TIFFLIB.H中に"TIFF_ERR_"で始まる名前で定義されています。

TIFFライブラリエラー情報
┌────────┬─┬─────────────────────────┐
│                │  │                  内          容                  │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_ID     │ 1│  TIFFのヘッダversionがおかしい                   │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_UNTYPE │ 2│  定義されていないタグタイプ                      │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_NOTAG  │ 3│  デフォルトが定義されていないのにタグがみつかりま│
│                │  │  せん                                            │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_NOHEAD │10│  バッファ中にヘッダ目的データがありません        │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_NOEXIST│11│  バッファ中に指定のタグデータがありません        │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_FORM   │12│  目的データの形式が不当                          │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_TYPE   │20│  SubfileType,NewSubfileTypeともに存在しません    │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_PLAN   │21│  PlanarConfigurationが1ではありません            │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_BPP    │22│  BitPerPixel が1,4,8,16,(8,8,8)のいずれでもありま│
│                │  │  せん                                            │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_FILL   │23│  fill orderが不当                                │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_PHOTO  │24│  photo.interp. が不当                            │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_CLUT   │25│  CLUTデータがありません                          │
├────────┼─┼─────────────────────────┤
│TIFF_ERR_COMP   │26│  サポートしてないCompresson                      │
└────────┴─┴─────────────────────────┘

2 TIFFライブラリ

2.1 関数一覧

 ･TIFFヘッダリードオペレーション
┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│TIFF_getHead              │TIFFヘッダの確認                          │
├─────────────┼─────────────────────┤
│TIFF_getTag               │タグデータのチェック                      │
├─────────────┼─────────────────────┤
│TIFF_tagValue             │タグデータ値の取り出し                    │
├─────────────┼─────────────────────┤
│TIFF_getPal               │TIFFパレット(CLUT)データの取り出し        │
├─────────────┼─────────────────────┤
│TIFF_checkMode            │TIFF形式の解析と必須情報の取り出し        │
└─────────────┴─────────────────────┘

 ･TIFFデータリードオペレーション
┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│TIFF_setLoadFunc          │データバッファ操作関数の登録              │
├─────────────┼─────────────────────┤
│TIFF_setReadFunc          │データ読み込み関数の登録                  │
├─────────────┼─────────────────────┤
│TIFF_setLoadBuffer        │ロードバッファの設定                      │
├─────────────┼─────────────────────┤
│TIFF_loadImage            │TIFFデータの展開                          │
└─────────────┴─────────────────────┘

 ･TIFFヘッダメイクオペレーション
┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│TIFF_setHead              │TOWNS標準TIFFのヘッダ作成                 │
└─────────────┴─────────────────────┘

 ･TIFFデータライトオペレーション
┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│TIFF_setSaveFunc          │バッファ操作関数の登録                    │
├─────────────┼─────────────────────┤
│TIFF_saveImage            │TIFFデータの作成                          │
└─────────────┴─────────────────────┘

 ･TIFF伸長オペレーション
┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│TIFF_setDecompFunc        │TIFF伸長用関数の登録                      │
├─────────────┼─────────────────────┤
│TIFF_decompress           │TIFF伸長処理                              │
└─────────────┴─────────────────────┘
  上記の関数は、LZWによるTIFFの圧縮データを復元するためのものです。
  上位関数のTIFF_loadImage関数を使う場合は、上記の関数をアプリケーションが
  呼び出す必要はありません。

 ･TIFF圧縮オペレーション
┌─────────────┬─────────────────────┐
│         関  数  名       │              機          能              │
├─────────────┼─────────────────────┤
│TIFF_setCompressFunc      │TIFF圧縮用関数の登録                      │
├─────────────┼─────────────────────┤
│TIFF_initCompress         │TIFF圧縮前処理                            │
├─────────────┼─────────────────────┤
│TIFF_compress             │TIFF圧縮開始                              │
├─────────────┼─────────────────────┤
│TIFF_termCompress         │TIFF圧縮後処理                            │
└─────────────┴─────────────────────┘
  上記の関数は、LZWによるTIFFの圧縮データを作成するためのものです。
  上位関数のTIFF_saveImage関数を使う場合は、上記の関数をアプリケーションが
  呼び出す必要はありません。

2.2 各関数の解説

-----------------------------------------------------------------------------
.TIFF_checkMode 
TIFF形式の解析と必須情報の取り出し
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
int TIFF_checkMode(int *x, int *y, int *comp, int *fill, long *strip,
long *clut);

- 戻り値 -
int *x, *y;       /*  TIFF画像の横/縦の大きさ(ドット数)            */
int *comp;        /*  圧縮フラグ(1:非圧縮  5:LZW圧縮)              */
int *fill;        /*  フィルオーダフラグ(16色モードのみ 2 or 1)    */
long *strip;      /*  画像データオフセット                         */
long *clut;       /*  パレットデータオフセット                     */

>0 :bit/pixel(1,4,8,16,24)
-1 :タグデータが不当、あるいはサポートしない形式

- 内容 -
ヘッダから必要最低限のタグデータを取り出し、FM TOWNSで読める形式のデータか
どうかチェックします。
comp、fill、clutは、TIFF_loadImage関数にそのまま渡すことができます。

strip == 0の場合は、マルチストリップ形式のデータです。
このデータはTIFF_loadImageで正しく読めるものと読めないものがあります。

clut != 0の場合は、パレットデータが存在するので、TIFF_getPal関数でパレット
データを取り出して処理する必要があります。

return == 24の場合は、RGB各8ビットのフルカラー(16M色)TIFFです。

-----------------------------------------------------------------------------
.TIFF_compress
TIFF圧縮開始
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
int TIFF_compress(char *buf, long size); 
char *buf;      /*  非圧縮データバッファ        */
long size;      /*  今回圧縮するデータバイト数  */

- 戻り値 -
 0 :正常終了
-1 :圧縮エラー

- 内容 -
buf内のsizeバイトのデータを圧縮します。圧縮された結果は、TIFF_setCompressFunc
関数で登録された関数に1バイトずつ渡されます。
この関数は、LZWによるTIFFの圧縮データを作成するためのものです。
上位関数のTIFF_saveImage関数を使う場合は、上記の関数をアプリケーションが呼び
出す必要はありません。

-----------------------------------------------------------------------------
.TIFF_decompress
TIFF伸長処理
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
int TIFF_decompress(int *cbuf);
char *cbuf;       /*  伸長処理用バッファ(DECOMP_WORK_SIZEバイト必要)  */

- 戻り値 -
0 :正常終了

- 内容 -
LZW圧縮されたTIFFデータの復元処理を行います。伸長処理は、圧縮されたコードから
復元データへ、それぞれ1バイト単位で処理されます。圧縮コードを1バイト取り出す
関数、復元データを1バイト出力する関数は、あらかじめTIFF_setDecompFuncd関数で
設定しておいてください。この関数は、LZWによるTIFFの圧縮データを復元するための
ものです。上位関数のTIFF_loadImage関数を使う場合は、上記の関数をアプリケーシ
ョンが呼び出す必要はありません。

-----------------------------------------------------------------------------
.TIFF_getHead 
TIFFヘッダの確認
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
int TIFF_getHead(char *bp, int bsize); 
char *bp;         /*  ロードバッファポインタ  */
char bsize;       /*  ロードバッファの大きさ  */

- 戻り値 -
ヘッダに含まれるタグの数

- 内容 -
bpからのバッファに格納されているTIFFのヘッダ部分を確認します。TIFFのデータで
ない場合や、タグ情報がバッファ中にない場合はエラーとなります。バッファ中のヘ
ッダの大きさを除いた部分は、TIFFイメージデータ部分のロードバッファとして使わ
れます。以下のヘッダ関係の関数を呼び出す際には、最初に必ず呼び出さなければな
りません。

-----------------------------------------------------------------------------
.TIFF_getPal
TIFFパレット(CLUT)データの取り出し
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
int TIFF_getPal(char *buf);
char *buf;      /*  パレットデータを格納するポインタ  */

- 戻り値 -
>0 :取り出したCLUTデータの数
 0 :CLUTデータは存在しない

- 内容 -
TIFFのCLUT情報から、TBIOSのEGB_palette関数のパラメータ形式のパレットデータを
作ります。

正しく取り出された場合、EGB_palette関数を使用してパレットの設定ができます。
bufで示されるバッファは、16色モードで16*8+4バイト、256色モードでは256*8+4バイ
ト必要になります。

bit/pixelが4,8の場合で、TIFFファイルにパレットデータが存在しない場合(旧アプリ
で作成したTIFF等)は、TBIOSの初期化時のパレットを作成して返します。

-----------------------------------------------------------------------------
.TIFF_getTag
タグデータのチェック
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
int TIFF_getTag(int tag, long *value, int *type, int *size, long *ofs);
int tag;      /*  取り出したいタグ  */

- 戻り値 -
0           :正常終了
long *value :タグデータの値
int  *type  :タグデータタイプ
int  *size  :タグデータサイズ
long *ofs   :タグデータのオフセット

- 内容 -
tagで指定したタグをヘッダ中から探します。
タグがスカラの場合は、valueにその値が入ります。このときofsは0となります。
タグがRational型かsize!=1の場合は、タグデータが格納されているオフセットがofs
に入ります。タグデータはこのofsを使って、TIFF_tagValue関数で取り出します。
TIFF_checkMode関数で取り出せないタグデータや、拡張されたタグ情報を取得したい
場合に使用します。

-----------------------------------------------------------------------------
.TIFF_initCompress 
TIFF圧縮前処理
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
void TIFF_initCompress(char *buf) 
char *buf;      /*  圧縮処理用作業バッファ(COMP_WORK_SIZEバイト)   */

- 戻り値 -
なし

- 内容 -
圧縮ルーチンの初期化をします。bufは呼出し側で用意する圧縮用ワークで現バージョ
ンでは、65792バイト必要です。圧縮処理の最初に一回呼び出します。
この関数は、LZWによるTIFFの圧縮データを作成するためのものです。
上位関数のTIFF_saveImage関数を使う場合は、上記の関数をアプリケーションが呼び
出す必要はありません。

-----------------------------------------------------------------------------
.TIFF_loadImage 
TIFFデータの展開
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
int TIFF_loadImage(int bpp, int width, int height, long strip, int fill,
 int comp, char *sbuf, int swidth, int sline, char *cbuf);
int bpp;            /*  ピクセルあたりのビットサイズ(1,4,8,16,24)       */
int width, height;  /*  TIFF画像の大きさ(横/縦ドット)                   */
long strip;         /*  TIFF画像データ本体オフセット                    */
int fill;           /*  fill order(16色モードのみ有効)                  */
int comp;           /*  圧縮フラグ(1:非圧縮  5:LZW圧縮)                 */
char *sbuf;         /*  展開バッファポインタ                            */
int swidth;         /*  展開バッファ横ドット数                          */
int sline;          /*  展開バッファライン数                            */
char *cbuf;  /*  圧縮伸長用作業バッファポインタ(DECOMP_WORK_SIZEバイト) */

- 戻り値 -
 0               :正常終了
-1               :get関数内で中断
-2               :put関数内で中断
-1、-2以外の負数 :ロードエラー(サポートできないTIFF)

- 内容 -
ロードバッファからTIFFファイルデータを読みだして、展開バッファにTBIOSで扱える
形で展開します。
この関数呼び出しまでに、TIFF_getHead関数または、TIFF_setLoadBuffer関数でロー
ドバッファが設定され、最初のデータが用意されていることが必要です。以降展開し
てロードバッファ中のデータが空になった時点で、TIFF_setLoadFunc関数で登録され
たget関数が呼び出されます。展開データが、展開バッファに指定したライン数だけた
まった時点で、TIFF_setLoadFunc関数で登録されたput関数が呼び出されます。
展開バッファの横ドット数はswidthで指定します。16色モードではこの値は偶数でな
ければなりません。展開されたデータをそのままTBIOSのEGB_putBlock関数などで使う
場合は、16色の場合swidthは8の倍数(4バイトバウンダリ)でなければなりません
(swidth >= widthであることが必要です)。16色以外では、普通はswidthにします。
bpp、strip、fill、compはTIFF_checkMode関数で得られた値をそのまま使うことがで
きます。

-----------------------------------------------------------------------------
.TIFF_saveImage 
TIFFデータの作成
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
int TIFF_saveImage(int bpp, int width, int height, int comp, char *dbuf,
 long disze, char *sbut, f int swidth, int sline, 
 char *cbuf); 
int bpp;          /*  ピクセルあたりのビットサイズ(1,4,8,16,24)         */
int width,height; /*  TIFF画像の大きさ(横/縦ドット)                     */
int comp;         /*  圧縮フラグ(1:非圧縮  5:LZW圧縮)                   */
char *dbuf;       /*  出力バッファポインタ                              */
long dsize;       /*  出力バッファサイズ                                */
char *sbuf;       /*  イメージバッファポインタ                          */
int swidth;       /*  イメージバッファ横ドット数                        */
int sline;        /*  イメージバッファライン数                          */
char *cbuf;       /*  圧縮用作業バッファポインタ(COMP_WORK_SIZEバイト)  */

- 戻り値 -
>0 :正常終了(セーブサイズ)
-1 :get関数内で中断
-2 :put関数内で中断

- 内容 -
画面のイメージのデータを、TIFFの形式にしてファイルなどへ出力します。イメージ
バッファ中のデータが空になった時点で、TIFF_setSaveFunc関数で登録されたget関数
が呼び出されます。データが、出力バッファに指定したライン数だけたまった時点で
、TIFF_setSaveFunc関数で登録されたput関数が呼び出されます。イメージバッファの
横ドット数はswidthで指定します。16色モードではこの値は偶数でなければなりませ
ん。(swidth >= widthであることが必要です。)
関数の戻り値は、セーブしたTIFFデータ本体のサイズ(バイト数)になります。
圧縮TIFFの場合この値はTIFF_setHead関数のcompパラメータに渡すことができます。

-----------------------------------------------------------------------------
.TIFF_setCompressFunc
TIFF圧縮用関数の登録
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
void TIFF_setCompressFunc(void (*put)()); 
void (*put)();      /*  圧縮されたコードを1バイト出力する関数  */

- 戻り値 -
なし

- 内容 -
TIFF_compress関数から呼ばれる圧縮されたデータを、1バイト出力する関数を登録し
ます。この関数は、以下のように呼び出されます。

put(int data);
int data;       /*  圧縮された1バイトのコード  */

この関数は、LZWによるTIFFの圧縮データを作成するためのものです。
上位関数のTIFF_saveImage関数を使う場合は、上記の関数をアプリケーションが呼び
出す必要はありません。

-----------------------------------------------------------------------------
.TIFF_setDecompFunc
TIFF伸長用関数の登録
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
void TIFF_setDecompFunc(void (*put)(), int (*get)()); 
void (*put)();      /*  復元データを受け取る関数  */
int  (*get)();      /*  圧縮元データを与える関数  */

- 戻り値 -
なし

- 内容 -
TIFF伸長ルーチンから呼び出される、1バイト入力/1バイト出力の関数を登録します。
TIFF_decompress関数を呼び出す前に、必ず呼び出される必要があります。
登録した2つの関数は、TIFF_decompress関数の中から次のように呼び出されます。

put(int data);
int data;       /*  復元された1バイトデータ  */

get();

==-1 :データの終わり
>0   :圧縮コード

この関数は、LZWによるTIFFの圧縮データを復元するためのものです。
上位関数のTIFF_loadImage関数を使う場合は、上記の関数をアプリケーションが呼び
出す必要はありません。

-----------------------------------------------------------------------------
.TIFF_setHead 
TOWNS標準TIFFのヘッダ作成
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
int TIFF_setHead(char *bp, int bpp, int x, int y, int comp, char *pal);
char *bp;       /*  ヘッダ作成バッファ              */
int bpp;        /*  bit/pixel(1,4,8,16,24)          */
int x,y;        /*  画像サイズ                      */
int comp;       /*  圧縮フラグ(圧縮されたサイズ)    */
char *pal;      /*  パレットデータ(へのポインタ)    */

- 戻り値 -
ヘッダサイズ

- 内容 -
TOWNS標準TIFFに準拠したTIFFのヘッダデータを作成します。bpからのバッファに作成
されたTIFFヘッダが入ります。ヘッダのサイズは256色の場合2048バイト、それ以外は
512バイトです。圧縮TIFFにする場合は、圧縮された結果のバイト数(ヘッダを除く)を
COMPに渡します。このサイズはTIFF_saveImage関数の戻り値として得ることができま
す。パレットデータがある場合は、palにパレットデータテーブル(EGB_palette関数の
パラメータ形式)のポインタを渡します。
bit/pixelが4、8の場合はパレットデータは必須です。

-----------------------------------------------------------------------------
.TIFF_setloadBuffer
ロードバッファの設定
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
void TIFF_setloadBuffer(char *bp, long size); 
char *bp;       /*  ロードバッファのポインタ  */
char size;      /*  ロードバッファのサイズ    */

- 戻り値 -
なし

- 内容 -
TIFF_loadImage関数内で使用し、ロードバッファ(もとデータを格納)を設定します。
この設定のあとTIFF_loadImage関数が呼び出されるまでに、イメージデータがbpから
sizeバイトに入っていることが必要です。
TIFF_getHead関数で設定されたロードバッファを再設定する場合、あるいはTIFFのヘ
ッダ解析をせず、画像データ本体のみを扱う場合に使用します。

-----------------------------------------------------------------------------
.TIFF_setLoadFunc
データバッファ操作関数の登録
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
void TIFF_setLoadFunc(int (*put)(), int (*get)());
int (*put)();       /*  展開バッファの内容をVRAMなどに出力するルーチン  */
int (*get)();       /*  ロードバッファへデータを取り込むルーチン        */

- 戻り値 -
なし

- 内容 -
登録した2つの関数は、TIFF_loadImage関数の中から次のように呼び出されます。

put(char *buf, int lofs, int lines);
char *buf;      /*  展開バッファのポインタ                            */
int lofs;       /*  今回出力するTIFFデータ先頭からのラインオフセット  */
int lines;      /*  今回出力するライン数                              */

get(char *buf, long size);
char *buf;      /*  ロードバッファのポインタ  */
long size;      /*  今回読み込むサイズ        */

TIFF_loadImage関数をコールする前に、必ず呼び出す必要があります。
それぞれの関数が-1を返した場合、その時点で画像の展開を中断してTIFF_loadImage
関数を終了します。

-----------------------------------------------------------------------------
.TIFF_setReadFunc 
データ読み込み関数の設定
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
void    TIFF_setReadFunc(int (*tiffget)());
int     (*tiffget)();       /*  ファイルの任意の位置を読むルーチン  */

- 戻り値 -
なし

- 内容 -
TIFFファイルの任意の部分のデータを取り出す関数を登録します。
TIFF_setHead関数を呼び出す前に登録してください。
この関数を定義することで、Towns以外の環境で作成したTIFFのサポート範囲が広がり
ます。定義しない場合でも、｢Towns標準TIFF｣形式の範囲まではサポートされます。
このTIFFライブラリで作成したTIFFを読むかぎりは、登録した関数が呼ばれることは
ありません。登録した関数は次のように呼び出されます。

int     tiffget(char *bp, int bsize, int ofs);
char   *bp;         /*  バッファポインタ                            */
int     bsize;      /*  バッファサイズ(最大読み込みサイズ)          */
int     ofs;        /*  TIFFファイルのファイル先頭からのオフセット  */

通常は、ファイルをofsの位置までシークして、そこから最大bsizeバイトのデータを
bpのバッファへリードする関数を用意すればよいことになります。
登録関数の戻り値は、読み込んだデータのサイズ(バイト)を返してください。
ファイルエラー等の致命的エラーが起こった場合は、-1(ERROR)を返してください。
エラーの場合は、登録した関数を呼び出した側でエラー終了します。

-----------------------------------------------------------------------------
.TIFF_setSaveFunc
バッファ操作関数の登録
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
void TIFF_setSaveFunc(int (*put)(), int (*get)());
int (*put)();   /*  セーブバッファの内容をファイルに出力するルーチン  */
int (*get)();   /*  イメージバッファへデータを取り込むルーチン        */

- 戻り値 -
なし

- 内容 -
登録した2つの関数は、TIFF_saveImage関数の中から次のように呼び出されます。

put(char *buf, long size) 
char *buf;      /*  セーブバッファのポインタ                          */
long size;      /*  今回出力するバイト数                              */

get(char *buf, int ofs, int lines); 
char *buf;      /*  イメージバッファのポインタ                        */
int ofs;        /*  今回取り込むTIFFデータ先頭からのラインオフセット  */
int lines;      /*  今回取り込むライン数                              */

TIFF_saveImage関数をコールする前に、必ず呼び出す必要があります。
それぞれの関数が-1を返した場合、その時点で画像の保存を中断してTIFF_saveImage
関数を終了します。

-----------------------------------------------------------------------------
.TIFF_tagValue
タグデータ値の取り出し
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
int TIFF_tagValue(int type, int size, long ofs, char *buf);
int  type;      /*  タグデータタイプ              */
int  size;      /*  タグデータサイズ              */
long ofs;       /*  タグデータ位置オフセット      */
char *buf;      /*  タグデータを取り出すバッファ  */

- 戻り値 -
0 :正常終了

- 内容 -
ofsの位置にある、typeタイプ、sizeサイズのタグデータを、bufからのバッファ中に
取り出します。TIFF_getTagで調べたタグの値を取り出すのに使用します。

-----------------------------------------------------------------------------
.TIFF_termCompress 
TIFF圧縮後処理
-----------------------------------------------------------------------------

- 定義 -
#include <tifflib.h>
void TIFF_termCompress(void); 

- 戻り値 -
なし

- 内容 -
圧縮終了処理です。未出力の圧縮データをフラッシュするので、すべてのデータを圧
縮し終わったあとでコールしてください。
この関数は、LZWによるTIFFの圧縮データを作成するためのものです。
上位関数のTIFF_saveImage関数を使う場合は、上記の関数をアプリケーションが呼び
出す必要はありません。

2.3 サンプルプログラム

┌────────────────────────────────────┐
│  TIFFライブラリ  サンプルプログラム   1                                │
│  ■  機能  ■                                                          │
│    TIFFデータを読み込み、画面に表示します。                            │
└────────────────────────────────────┘
/*
 *          TOWNS 標準TIFFライブラリサンプル
 *
 *  ごく簡単なTIFFローダ 
 *     コンソールから実行し，ファイル名で指定されたTIFFデータを表示する。
 *     キーを何かタイプすると終了する。
 *
 *  ex.   RUN386 tload sample.tiff 
 */

#include <stdio.h>
#include <stdlib.h>
#include <egb.h>
#include <strings.h>
#include <conio.h>
#include <msdos.cf>
#include "tifflib.h"

#define LOADBUFSIZE  150  /* ファイル読み込みバッファ */
#define EXPBUFSIZE   10   /* 展開用バッファ */
/* ここでは，ライブラリが扱うバッファの大きさを指定している｡(KByte単位)
 * 当然どちらのバッファも大きいほうが，高速にデータを表示できる。
 * ここでは，ファイルバッファを大きめ(16色フル画面TIFFの大きさ分)
 * にとり，展開バッファは少なめに定義してある。
 * この値を変えることにより，展開のされかたが違うことがわかる。
 */

/* ライブラリから呼ばれる，バッファに対する操作の関数  */
/* ユーザ側で用意して，登録しておく                    */
int read_data() ;
int put_data() ;
int read_file() ;

void setegb(), err() ;

int mode ;

char gwork[1540] ;          /* T-BIOS EGB ワーク */
char palt[ 256*8+4 ] ;      /* パレット設定用 */
FILE *fp ;
int x,y ;

void main( int ac,char **av )
{                                                                                        
    char *lbp, *dbp, *cbuf ;
    int lbsize, dbsize,bpp, d_line ;
    int comp,fill ;
    long strip, clut, dw ;

    if( ac < 2 ) 
        exit( -1 );
    lbsize = LOADBUFSIZE * 1024 ;   /* それぞれのバッファのサイズ */
    dbsize = EXPBUFSIZE * 1024;
    /* ロードバッファの取得 */
    lbp = malloc( lbsize ) ;
    /* 展開バッファの取得 */
    dbp = malloc( dbsize ) ;
    /* 圧縮展開用ワークの取得 */
    cbuf = malloc( DECOMP_WORK_SIZE ) ;  

    if( (fp = fopen( av[1], "rb" )) == NULL ) /* ファイルオープン */
        exit( -1 ) ;
    fread( lbp, 1, lbsize, fp ) ;   /* 最初のデータロード */

    /* 読み込み用関数の登録 */
    TIFF_setReadFunc( read_file ) ;
    
    /* ヘッダの解析 */
    if( TIFF_getHead( lbp, lbsize ) < 0 )
        err() ;
    /* タグの内容のチェック */
    if( ( bpp = TIFF_checkMode( &x,&y,&comp,&fill,&strip,&clut )) < 0 ) 
        err() ;
    if( bpp == 24 )
        err() ;         /* このプログラムではフルカラーデータは扱わない */
    mode = bpp ;

    /* バッファ操作関数の登録 */
    TIFF_setLoadFunc(  put_data, read_data ) ;
    /* 画面モードの設定 */
    setegb( bpp,x,y ) ;

    dw = x ;
    /* 16色モードの場合,T-BIOSでは横方向を8ドット単位で扱うため，
     一行のデータサイズを計算する際に，8ドット単位に調整しておく必要がある */
    if( bpp == 4)
        if( dw & 7 )
            dw += 8 - (dw & 7) ;

    /* 展開用バッファに何行分のデータが入るかの計算  */
    d_line = dbsize / ((dw * bpp + 7)/ 8) ;

    /* パレットの設定 */
    if( TIFF_getPal( palt ) != 0 )  {
        EGB_palette( gwork, 0, palt ) ;
    }
    /* TIFFデータのロード&表示  */
    TIFF_loadImage( bpp, x,y, strip,  fill, comp, dbp, dw, d_line, cbuf ) ;

    while( _kbhit() == 0 ) ;      /* キー入力待ち */

    free( lbp ) ;
    free( dbp ) ;
    free( cbuf ) ;
    fclose( fp ) ;
}

/*
    TIFFライブラリの中から呼ばれる関数
*/

/* バッファにデータをロードする                     */
/*    ファイルからロードする場合は freadだけでよい  */
read_data( char *bp, int size )
{

    fread( bp, 1, size, fp ) ; 
    if( ferror(fp) != 0 ) {
        return -1 ;
    }
    return 0 ;
}

/* バッファにデータをロードする。オフセット指定付き */
read_file( char *bp, int size, int ofs )
{
    int ret ;

    fseek( fp, ofs ,SEEK_SET ) ;
    ret = fread( bp, 1, size, fp ) ;
    if( ferror(fp) != 0 ) {
        ret =  -1 ;
    }
    return ret ;
}

/* 展開されたものを表示する                             */
/*    そのまま表示する場合は, EGB_putBlockを使えばよい  */
put_data( char *buf, int lofs, int lines ) 
{
    struct {
        char *bp ;
        short sel ;
        short sx,sy,ex,ey ;
    } p ;          /* EGB_putBlockのパラメータ */

    p.bp = buf ;
    p.sel = getds() ;
    p.sx = 0 ;
    p.ex = x -1 ;
    p.sy = lofs ;
    p.ey = lofs + lines -1 ;
    if( mode == 1 ) {

        EGB_putBlockColor( gwork, 0, (char *)&p ) ;   /* 2値TIFFの場合 */
    } else {
        EGB_putBlock( gwork , 0, (char *)&p ) ;
    }
    return 0 ;
}

/* 
    下請け関数群
*/
/* 画面モードの設定 */
void setegb( int bpp, int x, int y ) 
{
    EGB_init( gwork,1536) ;
    EGB_displayPage( gwork, 0, 3 ) ;
    switch( bpp ) {
    case 1:         /* 2値 */
    case 4:         /* 16色 */
        EGB_resolution( gwork, 0, 3 ) ;
        EGB_color( gwork, 0, 0 ) ;
        EGB_color( gwork, 1, 15 ) ;
        break ;
    case 8:         /* 256色 */
        EGB_resolution( gwork, 0, 12 ) ;
        break ;
    case 16:        /* 32K色 */
        if( x > 320 ) {/* 高解像度モードにする */
            EGB_resolution( gwork, 0, 17 ) ;
            EGB_displayStart( gwork, 3, 512, 480 ) ;
        } else {
            EGB_resolution( gwork, 0, 10 ) ;
            EGB_displayStart( gwork, 2, 2,2 ) ;
            EGB_displayStart( gwork, 3, 320,240 ) ;
        }
        break ;
    default: ;
    }
    if( bpp == 1 )          /* 2値TIFFの場合は画面を白で塗り潰す */
        EGB_clearScreen( gwork ) ;
}

void err()
{
    printf( "ERROR : %d\n", tiff_err ) ;
    exit( -1 ) ;
}

┌────────────────────────────────────┐
│  TIFFライブラリ  サンプルプログラム   2                                │
│  ■  機能  ■                                                          │
│    TIFFのヘッダ情報を参照します。                                      │
└────────────────────────────────────┘
/*
 *  TIFFライブラリサンプル
 *  
 *      TIFFのヘッダ情報を見る
 *          
 *  コンソール環境からTIFFファイルを指定して実行すると，TIFFヘッダの情報
 *  を表示する。コンソール上から実行する場合, 画面がクリアされるのを抑制
 *  するために，RUN386に対し"-nocrt"オプションを付けること。
 *  
 *  RUN386 -nocrt thead sample.tif
*/

#define TBUFSIZE 2048

#include <stdio.h>
#include <stdlib.h>
#include "tifflib.h"

void err() ;

char hbuf[TBUFSIZE];                        /* ヘッダ用バッファ   */
long pbuf[256*8+4] ;                        /* パレット用バッファ */

FILE *fp ;

read_file( char *buf, long size, long ofs)
{
    fseek( fp, ofs, SEEK_SET ) ;
    fread( buf, 1, size, fp ) ;
    return 0 ;
}
get_file( char *buf, long size)
{
    fread( buf, 1, size, fp ) ;
    return 0 ;
}
put_data()
{
/* dummy */
}

void main( ac,av )
int ac ;
char **av ;
{
    int tags,i ;
    int mode, x,y,comp,fill ;
    long ofs, clut ;

    if( ac < 2 ) 
        exit( -1 ) ;
    if( ( fp = fopen( av[1], "rb" )) == NULL ) {
        printf(" file cannot open\n" ) ;
        exit( -1 ) ;
    }
    TIFF_setReadFunc( read_file ) ;
    TIFF_setLoadFunc( put_data,get_file );

    fread( hbuf, 1, TBUFSIZE,fp ) ;
    if( (tags = TIFF_getHead( hbuf, TBUFSIZE )) < 0 ) 
        err() ;
    printf( "Number of tags : %d\n", tags ) ;

    /* タグ情報を表示 */
    tag( "New Subfile Type", NewSubfileType ) ;
    tag( "Subfile Type", SubfileType ) ;
    tag( "Image Width", ImageWidth ) ;
    tag( "Image Length", ImageLength ) ;
    tag( "Bits Per Sample", BitsPerSample ) ;
    tag( "Compresson", Compression ) ;
    tag( "Photo. Interp.", PhotoInterp ) ;
    tag( "Fill Order", FillOrder ) ;
    tag( "Document", Document ) ;
    tag( "Image Description", ImageDescription ) ;
    tag( "Make",Make) ;
    tag( "Strip Offset", StripOffsets ) ;
    tag( "Samples Per Pixel", SamplesPerPixel ) ;
    tag( "Rows Per Strip", RowsPerStrip ) ;
    tag( "Strip Byte Counts", StripByteCounts ) ;
    tag( "Min Sample Value", MinSampleValue ) ;
    tag( "Max Sample Value", MaxSampleValue ) ;
    tag( "X Resolution", XResolution ) ;
    tag( "Y Resolution", YResolution ) ;
    tag( "Planar Configration", PlanarConfiguration ) ;
    tag( "Resolution Unit",ResolutionUnit ) ;
    tag( "Software", Software ) ;
    tag( "Date Time", DateTime) ;
    tag( "Artist",Artist ) ;
    tag( "Host Computer",HostComputer ) ;
    tag( "Color Map", ColorMap ) ;

    /* TownsTIFFの情報を表示する */
    printf( "\n") ;
    if( ( mode = TIFF_checkMode( &x, &y, &comp, &fill,&ofs, &clut )) < 0 ) {
        printf( "ERR:%d\n", tiff_err ) ;
        printf( "This TIFF file not supported in TOWNS \n" ) ;
    } else {
        printf( "Towns TIFF mode\n" ) ;
        printf( "  Bit Per Pixel : %d\n", mode ) ;
        printf( "  TIFF size     : %d x %d\n", x, y ) ;
        printf( "  Image offset  : " ) ;
        if( ofs == 0 ) 
            printf( "multi strip\n" ) ;                                                  
        else
            printf( "%d\n", ofs ) ;
        printf( "  Compresson    : %s\n", (comp == 5)?"ON":"OFF" ) ;
        printf( "  Fill order    : %d\n", fill ) ;
        printf( "  Clut Data     : %s exist\n", (clut == 0)?"not":"" ) ;
    }
    /* パレットデータの内容をダンプ */
    if( clut != 0 ) {
        printf( "\n" ) ;
        if( TIFF_getPal( (char *)pbuf ) < 0 ) 
            err();
        for( i = 0 ; i < pbuf[0] ; i++ ) {
            clut = pbuf[i*2+2] ;
            printf( "%3ld : %2lx,%2lx,%2lx  ", (pbuf[i*2+1]),
                (clut & 0xff), ((clut >> 8) & 0xff),((clut >>16 ) & 0xff) ) ;
        if( i % 4 == 3 ) printf( "\n" ) ;
        }
    }
    
    fclose( fp ) ;
}

static int stable[] = {0,1,1,2,4,8} ;

/* タグの内容をダンプする */
tag( msg, tag ) 
char *msg ;
int tag ;
{
    long val,ofs ;
    int type, size,i ;
    char *b,*bp ;
    
    if( TIFF_getTag( tag, &val, &type, &size, &ofs ) < 0 ) 
        return( 0 ) ;
    if( ofs == 0 ) {               /*  スカラ */
        printf( "%20s : %u\n", msg, val ) ;
    } else {
        bp = b = malloc( stable[type]  * size ) ;
        if( TIFF_tagValue( type, size, ofs, b ) < 0 ) 
            err() ;
            printf( "%20s : ", msg ) ;
        for( i = 0 ; i < size ; i++ ) {
            switch( type ) {
            case ByteType:
                printf( "%d,", *(unsigned char *)bp++ ) ;
                break ;
            case AsciiType:
                printf( "%c",*bp++ ) ;
                break ;
            case ShortType:
                printf( "%u,", *(unsigned short *)bp ) ;
                bp +=2 ;                                                                        break ;
            case LongType:
                printf( "%lu,",*(unsigned long *)bp ) ;
                bp += 4 ;
                break ;
            case RationalType:
                printf( "%lu/%lu,",*(long *)bp, *(long *)(bp+4) ) ;
                bp += 8 ;
                break ;
            }
        }
        free( b ) ;
        printf( "\n" ) ;
    }
}

void err()
{
    printf( "ERROR -- %d\n", tiff_err ) ;
    exit( -1 ) ;
}

┌────────────────────────────────────┐
│  TIFFライブラリ  サンプルプログラム   3                                │
│  ■  機能  ■                                                          │
│    VRAMの内容をTIFFにセーブする関数です。                              │
└────────────────────────────────────┘
/*
*       TOWNS 標準TIFFライブラリサンプル
*
*   VRAMの内容をTIFFにセーブする関数
*
*   TIFF_saveScreen( fp,  mode, sx, sy, ex, ey, comp, egbwork )
*
*   パラメータ
*           FILE *fp : セーブファイルパス
*           int mode : 画面色数 4 (16色), 8 (256色), 16(32K色)のいずれか
*           int sx,sy: 保存左上座標
*           int ex,ey: 保存右下座標
*           int comp : 圧縮フラグ 0 (圧縮しない), 1 (LZW圧縮する)
*           char *egbwork : T-BIOSのEGBワーク
*   戻り値
*            0: 正常終了
*           <0: 異常終了(作業用メモリが確保できない)
*
*   機能
*       EGBのライトページに設定されている画面から画像を切り出してTIFFとして
*       セーブする｡ パラメータで渡す画面色数と，実際の画面モードの色数は一致
*       している必要がある。
*/
#include <stdio.h>
#include <stdlib.h>
#include <egb.h>
#include <tifflib.h>
#include <msdos.cf>


#define MALLOC      malloc      /* メモリ取得関数 */
#define FREE        free        /* メモリ開放関数 */
    
#define WBUFSIZE (1024*150)     /* ファイル書き込み用バッファサイズ */
#define LINES 1                 /* 処理単位ライン数 */

static char *egbw ;
static  struct {
        char *ptr ;
        short ds ;
        short sx,sy,ex,ey ;
} p ;
static int tiff_sy ;
static FILE *sfp ;

int save_get_func(), save_put_func() ;

TIFF_saveScreen( FILE *fp, int mode, int sx, int sy, int ex, 
                                         int ey, int comp, char *egbwork)
{
    int x,y, cmp,ret ;
    int dbs, sw, sl, size, hsize ;
    char  *pal, *cb, *sb, *db, *head ;

    egbw = egbwork ;
    tiff_sy = sy ;
    x = ex - sx + 1 ;
    y = ey - sy + 1 ;
    p.ds = getds() ;
    p.sx = sx ;
    p.ex = ex ;
    sfp = fp ;
    cmp = (comp) ? 5 : 1 ;
    ret = -1 ;
    pal = db = sb = cb = NULL ;

    if( mode == 4 || mode == 8 ) {
        /* パレット 取り出す */
        if( ( pal = MALLOC( (1 << mode) * 8 + 4 )) == NULL )
            goto end ;
        EGB_getPalette( EGB_getWritePage( egbw, getds() ) , (char *)pal ) ;
    }

    TIFF_setSaveFunc( save_put_func, save_get_func ) ;

    /* 圧縮展開用バッファの確保 */
    if( comp ) {
        if( (cb = MALLOC( COMP_WORK_SIZE )) == 0 ) {
            return -1 ;     /* 圧縮メモリ不足 */
        }
    }

    /* ファイル書き込みバッファの確保 */
    dbs = WBUFSIZE ;
    if( (db = MALLOC( dbs )) == 0 )
        goto end ; 
    /* 16色時のバウンダリ調整 */
    sw = ( mode == 4 ) ? (x + 7)/8 * 8 : x ;
    /* 取り込み用バッファの確保 */
    sl = LINES ;
    if( (sb = MALLOC( sw * mode / 8 )) == 0 )
        goto end ;
    /* ヘッダ作成用バッファの確保 */
    hsize = ( mode == 8 ) ? 2048 : 512 ;
    if( ( head = MALLOC( hsize )) == NULL ) 
        goto end ;
    fseek( fp, hsize, SEEK_SET ) ;

    /* TIFF保存 */
    size = TIFF_saveImage( mode, x, y, cmp, db, dbs, sb, sw, sl, cb) ;
    if( size > 0 ) {
        /* ヘッダをファイルに書く */
        TIFF_setHead( head, mode, x, y, (comp)?size:0, pal ) ;
        fseek( sfp, 0, SEEK_SET ) ;
        fwrite( head, 1, hsize, sfp ) ;
        ret = 0 ;
    }

end:
    if( pal ) FREE( pal ) ;
    if( db ) FREE( db ) ;
    if( sb ) FREE( sb ) ;
    if( cb ) FREE( cb ) ;
    if( head ) FREE( head ) ;

    return  ret  ;
}

/* TIFFライブラリから呼ばれる関数 */
/* VRAMから取り出す */
save_get_func( char *buf, int ofs, int lines )
{
    p.ptr = buf ;
    p.sy = tiff_sy + ofs ;
    p.ey = p.sy + lines - 1;
    EGB_getBlock( egbw, (char *)&p ) ;
    return 0 ;
}

/* ファイルに書きだす */
save_put_func( buf, size ) 
char *buf ;
int size ;
{
    fwrite( buf, 1, size, sfp ) ;
    return 0 ;
}

*****************************************************************************
第7章  ベクトルフォントライブラリ
*****************************************************************************

1 ベクトルフォントライブラリについて

1.1 概要

  ベクトルフォントライブラリはベクトル文字パターンを利用することにより、任意
の大きさの文字をビットマップに描きます。

ベクトル文字とは？
  ベクトル文字は一般的にアウトライン文字とも呼ばれ、文字の輪郭を数値情報化し
たものです。この情報より本ライブラリを利用して文字を描くと、大きく拡大しても
文字の輪郭がくずれません。

1.2 使用方法

 (1)パラメータ、ビットマップ領域を設定し、本ライブラリの関数を呼び出します。
    (パラメータ、ビットマップについては各関数の詳細を参照してください。)

 (2)ビットマップに描かれた文字はグラフィックライブラリなどにより画面に描画で
    きます。(グラフィックライブラリはHigh Cに付属しています。)

1.3 注意事項

  本ライブラリを使用するためにはベクトル文字パターン、またはベクトル文字パタ
ーンII(各別売)が必要です。本ライブラリを組み込んだソフトウェアでベクトル展開
する場合は、ベクトル文字パターンまたはベクトル文字パターンIIをICカードスロッ
トに挿入してください。
  なお、ベクトル文字パターンIIに格納されているプロポーショナル英文字は、使用
できません。プロポーショナル英文字を使用する場合は、本製品内の｢拡張フォント
管理ライブラリ｣をご利用ください。

2 ベクトルフォントライブラリ

2.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│VFT_get_filecount         │ベクトル文字ﾊﾟﾀｰﾝｶｰﾄﾞ ﾌｧｲﾙ数取得          │
├─────────────┼─────────────────────┤
│VFT_get_fileinfo          │ベクトル文字ﾊﾟﾀｰﾝｶｰﾄﾞ ﾌｧｲﾙ情報取得        │
├─────────────┼─────────────────────┤
│VFT_vecth                 │ベクトル文字フォント(高速版)              │
└─────────────┴─────────────────────┘

2.2 各関数の解説

-----------------------------------------------------------------------------
.VFT_get_filecount 
ベクトル文字パターンカード  ファイル数取得
-----------------------------------------------------------------------------

- 定義 -
#include <vft.h>
int VFT_get_filecount(char *page, int *file, int *size);
char *page;       /*  ページテーブル作成用領域アドレス          */
int  *file;       /*  取得ファイル数格納アドレス                */
int  *size;       /*  取得モジュールサイズ格納アドレス          */

- 戻り値 -
int  ret;           /*  0:正常にファイル数を取得した            */
                    /*  4:カード不完全挿入    または            */
                    /*      カードがない        または          */
                    /*      カードが異なる(CG-ROMカード以外)    */
                    /*  5:セグメントが取得できない              */

- 例 -
#include <vft.h>

char    page_tbl[8192];
int     file; 
int     size; 
int     ret;

ret=VFT_get_filecount(page_tbl,&file,&size);

- 内容 -
ベクトル文字パターンカードをアクセスし、ベクトルフォントファイル数とカードの
モジュールサイズを取得します。

《ページテーブル作成用領域アドレス》
  ･ページテーブルを作成するための領域を8KB確保し、先頭アドレスを設定します。
   (ページテーブル領域の内容は不定で良いです。)

《取得ファイル数格納アドレス》
  ･ファイル数を格納するint型変数のアドレスを設定します。

《取得モジュールサイズ格納アドレス》
  ･モジュールサイズを格納するint型変数のアドレスを設定します。

- 参考 -
ベクトル文字パターンカードには複数の字体･文字サイズのファイルが格納されている
場合があります。この関数で求めたファイル数を利用してベクトル文字パターンカー
ドファイル情報取得関数で必要とする格納領域を求めるのに使用できます。

-----------------------------------------------------------------------------
.VFT_get_fileinfo
ベクトル文字パターンカード  ファイル情報取得
-----------------------------------------------------------------------------

- 定義 -
#include <vft.h>
int VFT_get_fileinfo(char *page, char *file);
char *page;       /*  ページテーブル作成用領域アドレス              */
char *file;       /*  ファイル情報格納領域アドレス                  */

- 戻り値 -
int  ret;           /*  0:正常にファイル情報を取得した              */
                    /*  4:カード不完全挿入    または                */
                    /*      カードがない        または              */
                    /*      カードが異なる(ﾍﾞｸﾄﾙ文字ﾊﾟﾀｰﾝｶｰﾄﾞ 以外) */
                    /*  5:セグメントが取得できない                  */

- 例 -
#include <vft.h>

char    page_tbl[8192];
char    file_tbl[192];      /* 32 ﾊﾞｲﾄ * 6 ﾌｧｲﾙ = 192ﾊﾞｲﾄ */
int     ret;

ret=VFT_get_fileinfo(page_tbl,file_tbl); 

- 内容 -
ベクトル文字パターンカードのファイル情報を取得します。
 ┌ 1ファイルにつき、32バイトのメモリが必要です。不足した┐
 └場合はメモリ内容を破壊します。                        ┘

《ページテーブル作成用領域アドレス》
  ･ページテーブルを作成するための領域を8KB確保し、先頭アドレスを設定します。
   (ページテーブル領域の内容は不定で良いです。)

《ファイル情報格納領域アドレス》
  ･ファイル情報を格納する領域を確保し、先頭アドレスを設定します。
   なお、領域が足りない場合はメモリを破壊します。

┌───────────────────────────────────┐
│ファイル情報格納領域  ＝                                              │
│  ﾍﾞｸﾄﾙ文字ﾊﾟﾀｰﾝｶｰﾄﾞ ﾌｧｲﾙ数取得関数にて取得したファイル数 × 32バイト │
│ (VFT_get_filecount)                                                  │
└───────────────────────────────────┘

情報フォーマット

    0   1             17               31
  ┌──┬──────┬─────────┐
  │リザ│ファイル内容│    リサーブ      │
  │ーブ│            │                  │
  ├──┼──────┼─────────┤
  │  1 │     16     │        15        │
  └──┼──────┼─────────┘
        │            │
  ┌──┘            └─────────────────────┐
    1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │  │ド│ド│文│  │リ│リ│リ│リ│リ│リ│リ│リ│リ│リ│リ│
  │種│ッ│ッ│字│書│ザ│ザ│ザ│ザ│ザ│ザ│ザ│ザ│ザ│ザ│ザ│
  │  │ト│ト│セ│  │｜│｜│｜│｜│｜│｜│｜│｜│｜│｜│｜│
  │別│数│数│ッ│体│ブ│ブ│ブ│ブ│ブ│ブ│ブ│ブ│ブ│ブ│ブ│
  │  │Ｙ│Ｘ│ト│  │  │  │  │  │  │  │  │  │  │  │  │
  └┬┴─┴─┴┬┴┬┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
    │          │  └─────────────┐
    │          ↓                              ↓
    │  ┌────────────┐┌────────────────┐
    │  │01:  全角非漢字         ││01:  明朝体                     │
    │  │02:  全角第一水準漢字   ││02:  ゴシック                   │
    │  │03:  全角第二水準漢字   ││03:  大文字                     │
    │  │04:  全角常用漢字       ││04:  教科書                     │
    │  │05:  全角標準セット     ││05:  まる文字                   │
    │  │06〜7F:リザーブ         ││06:  毛筆(楷書)                 │
    │  │81:  半角標準セット     ││07:  毛筆(行書)                 │
    │  │82:  1/4角標準セット    ││08:  筆記体                     │
    │  │83:  半角英字セット     ││09:  丸ゴシック                 │
    │  │84:  MS-DOS文字セット   ││0A〜3F:リザーブ                 │
    │  │85〜FF:リザーブ         ││41:  イラストパターン           │
    │  └────────────┘│42:  デザイン文字               │
    │  ┌────────────┐│43〜7F:リザーブ                 │
    └→│00:  ドットフォント     ││81:  英字体10など半角書体       │
        │01:  ベクトルフォント   ││82:  クーリエなど正式英字書体   │
        └────────────┘│83〜FF:リザーブ                 │
                                    └────────────────┘

- 注意 -
･ドット数X/Yはベクトルフォントライブラリに格納されている字体の大きさを表しま
 す。
･5バイト目の書体コードとベクトル展開で指定する書体コードは異なります。
･複数のファイルが格納されている場合はファイル数分だけ、この情報フォーマット
 がくりかえされます。

-----------------------------------------------------------------------------
.VFT_vecth 
ベクトル文字フォント(高速版)
-----------------------------------------------------------------------------

- 定義 -
#include <vft.h>
int VFT_vecth(VFT_VECT_H *para, char *page); 
VFT_VECT_H *para; /*  パラメータのアドレス                      */
char *page;       /*  ページテーブル作成用領域アドレス          */

- 戻り値 -
int  ret;         /*  0:正常に文字列を設定した                  */
                    ※retコードは、下位2バイトに復帰コード1、2がそれぞれ
                      上位バイト、下位バイトに入ります。

- 例 -
#include <vft.h>

VFT_VECT_H  param;
char        page_tbl[8192];
int         ret;

ret = VFT_vecth(&param,page_tbl); 

- 内容 -
指定JISコード(1文字)のベクトル情報をベクトルフォント文字パターンカードより
検索し1ビットピクセルのイメージ情報に展開します。

パラメータの形式

           データGET有り
    ┌─┬───────────┐
  ０│Ｂ│インターフェイスレベル│
    ├─┼───────────┤
  １│Ｗ│コード体系指定        │
    ├─┼───────────┤
  ３│Ｂ│コール元ID            │
    ├─┼───────────┤
  ４│Ｂ│復帰情報1             │
    ├─┼───────────┤
  ５│Ｂ│復帰情報2             │
    ├─┼───────────┤
  ６│Ｗ│JISコード             │
    ├─┼───────────┤
  ８│Ｂ│書体情報              │
    ├─┼───────────┤
  ９│Ｂ│半角書体情報          │
    ├─┼───────────┤
  Ａ│Ｂ│デコレーション        │    フィールド情報で
    ├─┼───────────┤
  Ｂ│Ｂ│フィールド情報        │    縦横偏倍指定をしたとき
    ├─┼───────────┤←┬─┬───────────┐
  Ｃ│Ｗ│標準ドット            │  │Ｗ│Y座標展開ドットサイズ │←─┐
    ├─┼───────────┤  ├─┼───────────┤    │
  Ｅ│Ｂ│線幅制御              │  │Ｂ│線幅制御              │    │
    ├─┼───────────┤  ├─┼───────────┤    │
  Ｆ│Ｂ│拡大倍率(整数部)      │  │  │                      │←─┤
    ├─┼───────────┤  │Ｗ│X座標展開ドットサイズ │    │
  10│Ｂ│拡大倍率(小数部)      │  │  │                      │拡大率＜256
    ├─┼───────────┤←┴─┴───────────┘
  11│Ｗ│Y座標起点             │                                とすること
    ├─┼───────────┤
  13│Ｗ│X座標起点             │
    ├─┼───────────┤
  15│Ｂ│出力データID          │
    ├─┼───────────┤
  16│Ｗ│出力バッファ折り返し  │
    ├─┼───────────┤
  18│Ｄ│出力バッファOFFSET    │
    ├─┼───────────┤
  1C│Ｄ│出力バッファサイズ    │
    ├─┼───────────┤
  20│Ｂ│フォント上の横線幅    │
    └─┴───────────┘
      計  33バイト

パラメータ詳細

         インタフェースレベル

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
  +0│B │ 0   0   0   0   0   0   0   0│(00H固定)
    └─┴─┴─┴─┴─┴─┴─┴─┴─┘

  コード体系指定

          15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  +1│W │ 0   0   0   0   0   0   0   0   0   0   0   0   0   0   0│ 1│
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
                                              (0001H固定)

コール元ID

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
  +3│B │ 1   0   0   0   0   0   0   1│(81H固定)
    └─┴─┴─┴─┴─┴─┴─┴─┴─┘

復帰情報1

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
  +4│B │ ･│ ･│ ･│ ･│ 0   0   0   0│
    └─┴┼┴┼┴┼┴┼┴─┴─┴─┴─┘
          │  │  │  └──────────パラメータ指定エラー
          │  │  └────────────部品版数エラー
          │  └──────────────文字コードエラー
          └────────────────I/Oエラー

復帰情報2(リサーブ)

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
  +5│B │ 0   0   0   0   0   0   0   0│
    └─┴─┴─┴─┴─┴─┴─┴─┴─┘

JISコード

            15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
    +6┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  漢字│W │ 0│      上位コード          │ 0│      下位コード          │
      └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
  
  
            15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0 
    +6┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  ANK │W │ 0   0   0   0   0   0   0   0│        ANK文字コード         │
      └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
            └──────┬──────┘
    ANK文字コード(半角文字)を指定する場合は上位コードはゼロクリアします。

書体情報

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
  +8│B │ 0   0   0   0   0│          │
    └─┴─┴─┴─┴─┴─┴┬┴─┴┬┘
                              └───┴── 000:明朝体
                                             001:ゴシック
                                             010:教科書
                                             011:毛筆(楷書)
                                             100:丸文字
                                             101:毛筆(行書)
                                             110:筆記体
                                             111:丸ゴシック

半角書体情報

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
  +9│B │ 0   0   0   0   0   0   0   0│(00H固定)
    └─┴─┴─┴─┴─┴─┴─┴─┴─┘

デコレーション

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +A │B │ ･│ 0   0   0   0   0│      │
    └─┴┼┴─┴─┴─┴─┴─┴┬┴┬┘
          │                      └─┴── 00:回転無
          │                                 01:  90度回転
          │                                 10:180度回転
          │                                 11:270度回転
          │
          └──────────────── 0:フィールドクリア無
                                             1:フィールドクリア有

      ･フィールドクリア:出力バッファ中の文字枠相当部分をクリアします。

フィールド情報

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +B │B │ ･│ 0│      │ ･│ ･│ ･│ ･│
    └─┴┼┴─┴┬┴┬┴┼┴┼┴┼┴┼┘
          │      │  │  │  │  │  └ 1:横半分  ┐
          │      │  │  │  │  └── 1:縦半分  │｢標準ドットのみ参照｣
          │      │  │  │  └──── 1:横倍角  │ 指定のときのみ有効
          │      │  │  └────── 1:縦倍角  ┘
          │      │  │
          │      └─┴──────── 00:標準ドットのみ参照
          │                             01:拡大倍率参照
          │                             10:縦横偏倍指定
          │
          └────────────── 0:横書きフィールド
                                         1:縦書きフィールド

標準ドット

          15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +C │W │                                                              │
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
      ･フィールド情報で｢標準ドットのみ参照｣および｢拡大倍率参照｣を指定時のみ
       有効で標準ドットを基準にフォント文字の大きさを計算します。
      ･フィールド情報で｢標準ドットのみ参照｣指定時はこのドット数に対して半分･
       倍角を行います。
      ･フィールド情報で｢拡大倍率参照｣を指定時はこのドット数に対して拡大倍率
       を乗算します。

線幅制御

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +E │B │ 0   0   0   0   0   0   0   1│(01H固定)
    └─┴─┴─┴─┴─┴─┴─┴─┴─┘

拡大倍率(整数部)

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +F │B │                              │
    └─┴─┴─┴─┴─┴─┴─┴─┴─┘
      ･フィールド情報で｢拡大倍率参照｣を指定時のみ有効で標準ドットに乗算され
       ます。

拡大倍率(少数部)

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +10│B │                              │
    └─┴─┴─┴─┴─┴─┴─┴─┴─┘
      ･フィールド情報で｢拡大倍率参照｣を指定時のみ有効で標準ドットに
       (拡大倍率(少数部)/256)として乗算されます。

  例)2.5倍を指定する場合
      拡大倍率(整数部):    2 
      拡大倍率(少数部):  128 ＝ 0.5×256 となる。

Y座標フォントドットサイズ

          15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +C │W │                                                              │
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
      ･フィールド情報で｢縦横偏倍指定｣時のみ有効でフォント文字の縦方向ドット
       数を指定します。

X座標フォントドットサイズ

          15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +F │W │                                                              │
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
      ･フィールド情報で｢縦横偏倍指定｣時のみ有効でフォント文字の横方向ドット
       数を指定します。

Y座標起点

          15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +11│W │                                                              │
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
      ･フォント文字の左上を基準として出力バッファの縦方向描画位置をドット数
       で指定します。

X座標起点

          15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +13│W │                                                              │
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
      ･フォント文字の左上を基準として出力バッファの横方向描画位置をドット数
       で指定します。

出力データID

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +15│B │ 0   0   0   0   0   0   0   0│(00H固定)
    └─┴─┴─┴─┴─┴─┴─┴─┴─┘

出力バッファ折り返し

          15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +16│W │                              │                              │
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

  ※横方向の長さ(ドット数)を8ドット単位(バイト数)で指定します。

  ※次の式で計算できます。
┌──────────────────────────────────┐
│     ((横方向ドット数  +  7)/8)切捨て  ＝  出力バッファ折り返し     │
└──────────────────────────────────┘
《例》 横方向が100ドットの場合は
       ((100 +7)/8)切捨て ＝ 13バイト になります。

出力バッファOFFSET

         31            24              16               8               0 
    ┌─┬───────┬───────┬───────┬───────┐
 +18│D │              │              │              │              │
    └─┴───────┴───────┴───────┴───────┘
      ※フォント結果のビットマップイメージを格納する領域の先頭アドレスを
        指定します。

出力バッファサイズ

         31            24              16               8               0 
    ┌─┬───────┬───────┬───────┬───────┐
 +1C│D │              │              │              │              │
    └─┴───────┴───────┴───────┴───────┘
      ※フォント結果のビットマップイメージを格納する領域の大きさをバイト
        数で指定します。
      ※必要な大きさは(出力バッファ折り返し  ＊  縦方向ドット数)で計算
        できます。

フォント上の横線幅

           7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐
 +20│B │ 0   0   0   0   0   0   0   0│(01H固定)
    └─┴─┴─┴─┴─┴─┴─┴─┴─┘

《ページテーブル作成用領域アドレス》
  ページテーブルを作成するための領域を8KB確保し、先頭アドレスを設定します。
  (ページテーブル領域の内容は不定で良いです。)

出力イメージフォーマット
  ●出力はモノクロ(2値)ビットマップイメージとして作成されます。
    (グラフィックライブラリの任意文字表示関数で画面に描画可能です)

 《例》『亜』を32×10で展開した場合、以下のようなビットマップに展開されます。

  図EXL121R-012

    上のイメージは次のようにメモリ上に展開されます。

  出力バッファ
                ┌───┐        ┌───┐        ┌───┐
     OFFSET     │      ↓        │      ↓        │      ↓
  ┌00───┐  │  ├0A───┤  │  ├14───┤  │  ├1E───┤
  │00000000│  │  │00110000│  │  │00000011│  │  │00110000│
  ├01───┤  │  ├0B───┤  │  ├15───┤  │  ├1F───┤
  │00000000│  │  │00000000│  │  │00001100│  │  │00000000│
  ├02───┤  │  ├0C───┤  │  ├16───┤  │  ├20───┤
  │00000000│  │  │00000011│  │  │00110000│  │  │00111111│
  ├03───┤  │  ├0D───┤  │  ├17───┤  │  ├21───┤
  │00000000│  │  │11111111│  │  │11000000│  │  │11111111│
  ├04───┤  │  ├0E───┤  │  ├18───┤  │  ├22───┤
  │00001111│  │  │11111111│  │  │00000011│  │  │11111111│
  ├05───┤  │  ├0F───┤  │  ├19───┤  │  ├23───┤
  │11111111│  │  │11000000│  │  │11111111│  │  │11111100│
  ├06───┤  │  ├10───┤  │  ├1A───┤  │  ├24───┤
  │11111111│  │  │00000011│  │  │11111111│  │  │00000000│
  ├07───┤  │  ├11───┤  │  ├1B───┤  │  ├25───┤
  │11110000│  │  │00001100│  │  │11000000│  │  │00000000│
  ├08───┤  │  ├12───┤  │  ├1C───┤  │  ├26───┤
  │00000000│  │  │00110000│  │  │00000000│  │  │00000000│
  ├09───┤  │  ├13───┤  │  ├1D───┤  │  ├27───┤
  │00001100│  │  │11000000│  │  │00001100│  │  │00000000│
  ├──┬─┤  │  ├──┬─┤  │  ├──┬─┤  │  └────┘
        └───┘        └───┘        └───┘  出力バッファ
                                                           OFFSET 
                                                            +
                                                        出力バッファ
                                                            サイズ

- 参考 -
《出力バッファ領域メモリ量の計算方法》
  ((展開横ドット数+7)/8)切り捨て×展開縦ドット数

  例)300×300ドット時
    ((300+7)/8)×300  ＝  11400バイト

- 制限事項 -
  ･ANK文字の制御文字など以下のコードに対応する文字はベクトル文字パターンに
   存在しません。

《無いコード》
    00H〜1BH  :  制御文字
    7FH〜A0H  :  制御文字およびグラフィック文字
    E0H〜FFH  :  グラフィック文字

2.3 サンプルプログラム

┌────────────────────────────────────┐
│  高速版ベクトルフォントライブラリ  サンプルプログラム                  │
│  ■  機能  ■                                                          │
│    文字を序々に拡大して表示します。                                    │
└────────────────────────────────────┘

/**********************************************************************/
/***            高速版ベクトルフォント  サンプル                    ***/
/***                                                                ***/
/***  <<<このサンプルはベクトル展開ライブラリが出力したビットマッ   ***/
/***     プをEGBにより描画しています>>>                             ***/
/***   任意文字描画関数を使用していますので                         ***/
/***   仮想画面の大きさ/ピクセル数のスタック領域が必要です          ***/
/***                                                                ***/
/**********************************************************************/
#include  <egb.h>
#include  <stdlib.h>
#include  <VFT.H>
/***    共通領域設定   ***/
char        work[1536];     /* EGBワーク領域     */
char        para[64];       /* EGBパラメータ領域 */

VFT_VECT_H  prm;            /* ベクトル展開パラメータ           */
char        *VECT_buff;     /* ベクトル展開イメージ領域アドレス */
    /* ベクトル展開イメージ領域は固定で取得しても良いです       */
    /* char VECT_buff[8160]; */ /* この場合255*255ドットまで描画可能 */
char        PAGE_tbl[8192]; /* ページテーブル領域(8KB固定)      */

/*********************************************************************/
/***    ベクトルバッファクリア                                     ***/
/*********************************************************************/
/*  ベクトル展開のフィールドクリアは描画する領域のみクリアするので   */
/*  描画バッファ内すべてをクリアするのは自分で行います               */
BUFF_clr()
{
    int i;
    for( i=0 ; i < prm.p1.buff_size ; i++ )
    {   VECT_buff[i] = 0x00 ;   }
    return 0;
}
/*********************************************************************/
/***    ベクトル文字パターンカードチェック                         ***/
/*********************************************************************/
CGROM_chk()
{
    int     syotai;
    int     filesu;
    int     rom_size;
    char    *file_data;
        /* ROM内ファイル数取得 */
    if( (VFT_get_filecount(PAGE_tbl,&filesu,&rom_size)) != 0 )
    {   /* ベクトルデータなし */
        return -1;
    }
        /* ファイル情報格納領域確保 */
    if( (file_data = malloc(filesu * 32)) == 0 )
    {   /* ファイル情報格納領域確保不可 */
        return -1;
    }
        /* ファイル情報取得 */
    if( (VFT_get_fileinfo(PAGE_tbl,file_data)) != 0 )
    {   /* ベクトルデータファイル情報取得不可 */
        free(file_data);
        return -1;
    }
        /* ベクトル文字パターンカードの書体抜き出し */
        /* ROM内書体コードをベクトルフォントパラの書体コードに変更 */
    switch( ((int)(file_data[5])) )
    {
        case    1:  syotai = 0 ; break ;    /* 明朝体       */
        case    2:  syotai = 1 ; break ;    /* ゴシック体   */
        case    6:  syotai = 3 ; break ;    /* 楷書         */
        case    7:  syotai = 5 ; break ;    /* 行書         */
        case    9:  syotai = 7 ; break ;    /* 丸ゴシック体 */
        default  :  syotai = -1 ;           /* エラー       */
    }
        /*  ROMカードに無い書体で
            VFT_vecth()をCALLした場合は書体なしエラーが返ってきます   */
        /* 領域開放 */
    free(file_data);
    return syotai;
}
/*******************************************************************/
/***    ベクトルフォントのパラメータ作成                         ***/
/*******************************************************************/
PRM_edit(syotai,size)
int     syotai;     /* 書体 */
int     size;       /* 展開文字の大きさ */
{
    prm.p1.level      =  0x00;     /* インターフェイスレベル(00h固定) */
    prm.p1.code_type  =  0x01;     /* コードタイプ(01h固定)           */
    prm.p1.call_id    =  0x01;     /* コールID(01h固定)               */
    prm.p1.jis        =  0x3026;   /* JISコード(3026hは"愛")          */
    prm.p1.form       =  syotai;   /* 書体(0:明朝体 1:ゴシック体)     */
    prm.p1.h_form     =  0x00;     /* 半角書体(00h固定)               */
    prm.p1.dec        =  0;        /* 回転(0:無 1:90 2:180 3:270)     */
    prm.p1.dec        |= 0x80;     /* フィールドクリアあり            */
    prm.p1.field      =  0x00;     /* フィールド情報(横書き指定)      */

    prm.p1.field      |= 0x20;     /* 縦横偏倍指定 */
    prm.p1.ten_x      =  size;     /* 横方向ドット数 */
    prm.p1.ten_y      =  size;     /* 縦方向ドット数 */

    prm.p1.sen_haba   =  0x01;     /* 線幅制御 */
    prm.p1.gen_y      =  0;        /* フォント縦位置(左上を基準) */
    prm.p1.gen_x      =  0;        /* フォント横位置(左上を基準) */
    prm.p1.out_id     =  0x00;     /* 出力データID (00h固定) */
        /* 出力バッファ折り返しバイト */
    prm.p1.buff_ret   =  (prm.p1.ten_x + 7) / 8;
        /* 出力バッファアドレス */
        /* バッファアロケーション時に再セットします     */
        /* (0 のままだとプログラム領域を破壊します)     */
    prm.p1.buff_off   =  0;
        /* 出力バッファサイズ */
    prm.p1.buff_size  =  prm.p1.buff_ret * prm.p1.ten_y;
    prm.p1.font_haba  =  0x01;        /* フォント横線幅 */

    return 0;
}
/*********************************************************************/
/***    画面出力    EGBより出力します                              ***/
/*********************************************************************/
EGB_out(size)
int     size;       /* 展開位置(X,Y) */
{
        /* 全画面消去 */
    EGB_clearScreen( work );
        /* 字体の設定 */
    EGB_fontStyle( work, 0 );
        /*  任意文字描画関数は追加として文字を書くので
            一度NULL文字を書き描画位置を設定します   */
    WORD(para + 0)  = size;
    WORD(para + 2)  = prm.p1.ten_y + size;
    WORD(para + 4)  = 0;
    EGB_sjisString( work, para );
        /* 文字拡大率の設定 */
    EGB_textZoom( work,1,(prm.p1.buff_ret * 8),prm.p1.ten_y );
        /* 任意文字の描画 */
    EGB_anyChar( work,(prm.p1.buff_ret * 8),prm.p1.ten_y,prm.p1.buff_off );
     /* EGB_anyChar関数では255×255ドット以下の文字までしか描画できません */
    return 0;
}
/*********************************************************************/
/***    ベクトルフォントメイン                                     ***/
/*********************************************************************/
main()
{
    int     syotai;
    int     size;
/*  char    *pbuff;    */
        /* EGB初期設定 */
    EGB_init( work,1536 );
    EGB_resolution( work, 0, 3 );
    EGB_resolution( work, 1, 3 );
    EGB_displayPage( work, 0, 1 );
    EGB_writePage( work, 0 );
    EGB_color( work, 0, 13 );
    EGB_color( work, 2, 11 );
    EGB_writeMode( work, 0 );
    EGB_paintMode( work, 0x22 );
    EGB_pen( work, 0 );
    EGB_penSize( work, 1 );

        /* ベクトル文字カードの確認 */
    if( (syotai = CGROM_chk()) >= 0)
    {   /* ベクトル文字カードあり OK */
        for(size = 8 ; size <= 255 ; size += 8)
        {      /* パラメータ編集 */
            PRM_edit(syotai,size);
                /* バッファ確保 */
            VECT_buff = malloc(prm.p1.buff_size);
                /* バッファアドレスをパラメータに反映 */
            prm.p1.buff_off = VECT_buff ; 
            if( VECT_buff != 0)
            {   /* バッファ確保OK */
                    /* バッファ領域クリア */
                BUFF_clr() ;
                    /* ベクトルフォント */
                if( (VFT_vecth(&prm,PAGE_tbl)) == 0)
                {   /* ベクトルフォント正常終了 */
                        /* グラフィック画面に描画 */
                    EGB_out(size/2);
                }
                    /* ベクトルフォントバッファ開放 */
                free(VECT-buff);
            }
        }
    }
    return 0;
}

*****************************************************************************
第8章  Native RS-232Cライブラリ
*****************************************************************************

1 Native RS-232Cライブラリについて

1.1 概要
  本ライブラリはプロテクトモードで動作するRS-232Cライブラリです。
  High Cで作成したプロテクトモードで動作するアプリケーションプログラムにおい
て使用可能です。本ライブラリを組み込んだアプリケーションプログラム動作中には
、リアルモードのRS-232C BIOSは使用できません。
  また、GUIライブラリを使用してシェル対応アプリケーションを作成する場合には、
本ライブラリを使用できません。
  FMC関数ライブラリのRS-232Cインタフェースを使用してください。

1.2 基本動作フロー

  図EXL121R-013

- 注意 -
･回線の切り換え(PORT:0A0AへのWRITE)などはRSB_Open関数〜RSB_Close関数の間に行
 わないでください。
･本ライブラリはオブジェクトで提供します。
･リンク時にはスタックサイズを65535以上に設定してください。
･RSB_Init関数、RSB_Init2関数を再度発行する場合は、一度RSB_End関数を発行してか
 ら行ってください。

2 Native RS-232Cライブラリ

2.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│RSB_Init                  │Native RS-232Cの初期化                    │
├─────────────┼─────────────────────┤
│RSB_End                   │Native RS-232Cの終了                      │
├─────────────┼─────────────────────┤
│RSB_Open                  │回線オープン                              │
├─────────────┼─────────────────────┤
│RSB_Close                 │回線クローズ                              │
├─────────────┼─────────────────────┤
│RSB_Setpara               │通信パラメータの設定                      │
├─────────────┼─────────────────────┤
│RSB_Read                  │受信バッファ内の有効データ数の読み取り    │
├─────────────┼─────────────────────┤
│RSB_Receive               │データの受信                              │
├─────────────┼─────────────────────┤
│RSB_Send                  │データの送信                              │
├─────────────┼─────────────────────┤
│RSB_Ctrl                  │シリアルポートの制御                      │
├─────────────┼─────────────────────┤
│RSB_Status                │ステータス情報の読み取り                  │
├─────────────┼─────────────────────┤
│RSB_Initbuf               │受信バッファの初期化                      │
├─────────────┼─────────────────────┤
│RSB_Break                 │ブレーク信号の送信                        │
├─────────────┼─────────────────────┤
│RSB_Dtr                   │拡張DTR信号の保持設定                     │
├─────────────┼─────────────────────┤
│RSB_Chk                   │シリアルポートの検出                      │
├─────────────┼─────────────────────┤
│RSB_Rdpara                │通信パラメータの読み取り                  │
├─────────────┼─────────────────────┤
│RSB_Setint                │拡張割り込みの設定                        │
├─────────────┼─────────────────────┤
│RSB_Rdint                 │拡張割り込みの読み取り                    │
├─────────────┼─────────────────────┤
│RSB_Clsxoff               │XOFF受信のクリア                          │
├─────────────┼─────────────────────┤
│RSB_Gettxlen              │送信バッファ内の有効データ数の読み取り    │
├─────────────┼─────────────────────┤
│RSB_Init2                 │Native RS-232Cの初期化(ポート指定)        │
├─────────────┼─────────────────────┤
│RSB_Hdchk                 │FIFO機能の有無の検出                      │
└─────────────┴─────────────────────┘

2.2 各関数の解説

-----------------------------------------------------------------------------
.RSB_Break 
ブレーク信号の送信
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Break(int port, unsigned int brktime);
int     port;               /*  ポート番号(0〜4)        */
unsigned int   brktime;     /*  送信時間                */

- 戻り値 -
0 :正常終了
2 :範囲以外のポート番号を指定した
3 :拡張カードが接続されていないポートを指定した
4 :回線がオープン状態ではない
6 :送信時間の指定が以上

- 例 -
#include <rs.h> 
        …
int     port, brktime, ret; 

port = 0; 
brktime = 65535;
ret = RSB_Break(port, brktime); 

- 内容 -
送信時間が終了するまでブレーク信号を送信します。
送信時間  1〜65535×10ms

- 注意 -
時間指定が0のときはエラーとなります。

-----------------------------------------------------------------------------
.RSB_Chk 
シリアルポートの検出
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
unsigned int  RSB_Chk(void);

- 戻り値 -
検出データ

- 例 -
#include <rs.h> 
        …
unsigned int  portdt; 
portdt = RSB_Chk();

- 内容 -
RS-232Cカードの接続状態を読み取ります。

検出データ

          15  14  13  12  11  10   9   8
        ┌─┬─┬─┬─┬─┬─┬─┬─┐
 portdt:│ 0│ 0│ 0│ 0│ 0│ 0│ 0│ 0│
        └─┴─┴─┴─┴─┴─┴─┴─┘

          7    6   5   4   3   2   1   0
        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        │ 0│ 0│ 0│  │  │  │  │  │
        └┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┘
          └─┼─┘  │  │  │  │  └──ポート0
              │      │  │  │  └────ポート1
              │      │  │  └──────ポート2
              │      │  └────────ポート3
              │      └──────────ポート4
              └──────────────リザーブ

ビット対応により 0:非接続、1:接続 となります。
ポート0は内蔵のため1となります。

-----------------------------------------------------------------------------
.RSB_Close 
回線クローズ
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Close(int port);
int     port;                      /*   ポート番号(0〜4)  */

- 戻り値 -
0 :正常終了
2 :範囲外のポートを指定した
3 :拡張カードが接続されていないポートを指定した
4 :回線がオープン状態ではない

- 例 -
#include <rs.h> 
        …
int     port = 0; 
int     ret;

ret = RSB_Close(port);

- 内容 -
回線のクローズ(回線による割り込みの禁止)を行います。
ポート0にFIFO機能がある場合には、FIFO機能を回線オープン前の状態に戻します。

-----------------------------------------------------------------------------
.RSB_Clsxoff 
XOFF受信のクリア
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Clsxoff(int port);
int     port;                    /*   ポート番号(0〜4)     */ 

- 戻り値 -
0 :正常終了
2 :範囲外のポートを指定した
3 :拡張カードが接続されていないポートを指定した
4 :回線がオープン状態ではない

- 例 -
#include <rs.h> 
        …
int     port = 0; 
int     ret;

ret = RSB_Clsxoff(port);

- 内容 -
XON/XOFF制御を行っているときに、通常はXOFFのあとに XONが送信されて来ますが、
何らかの原因でXONが来なかった場合は送信不可能となります。
送信不可能となった場合、本ファンクションを実行することにより、XOFFの受信をク
リアし、送信可能とします。

-----------------------------------------------------------------------------
.RSB_Ctrl
シリアルポートの制御
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Ctrl(int port, unsigned int ctrl);
int     port;               /*  ポート番号(0〜4)          */
unsigned int    ctrl;       /*  制御データ                */

- 戻り値 -
0 :正常終了
2 :範囲以外のポート番号を指定した
3 :拡張カードが接続されていないポートを指定した
4 :回線がオープン状態ではない

- 例 -
#include <rs.h> 
        …
int     port, ret;
unsigned int    ctrl; 

port = 0; 
ctrl = 0x00;
ret = RSB_Ctrl(port, ctrl); 

- 内容 -
シリアルポートのDTR/RTSの信号をコントロールします。このモードは、次にこの関数
によって書き換えられるか、回線がクローズされるまで続きます。

制御データ

         7   6   5   4   3   2   1   0
      ┌─┬─┬─┬─┬─┬─┬─┬─┐
ctrl: │ 0│ 0│  │ 0│ 0│ 0│  │ 0│
      └─┴─┴┬┴─┴─┴─┴┬┴─┘
                │              └───ＤＴＲ  0:OFF 
                │                              1:ON
                └───────────ＲＴＳ  0:OFF 
                                                1:ON

-----------------------------------------------------------------------------
.RSB_Dtr 
拡張DTR信号の保持設定
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Dtr(int port, int sw);
int     port;                /*   ポート(0〜4)              */
int     sw;                  /*   0:保持しません
                                  1:保持します              */

- 戻り値 -
0 :正常終了
2 :範囲以外のポート番号を指定した
3 :拡張カードが接続されていないポートを指定した

- 例 -
#include <rs.h> 
        …
int     port, sw, ret;

port = 0; 
sw = 1; 
ret = RSB_Dtr(port, sw);

- 内容 -
RSB_Close関数を行っても、DTR信号がOFFされないように保持します。
なお、この機能はRSB_Open関数を行うと無効となります。
初期状態は｢保持しない｣になっています。

-----------------------------------------------------------------------------
.RSB_End 
Native RS-232Cの終了
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_End(void);

- 戻り値 -
不定

- 例 -
#include <rs.h> 
        …
int     ret;

ret = RSB_End();

- 内容 -
RS-232Cの割り込みをプロテクトモードで動作するアプリケーションプログラムから
開放します。
開放されたRS-232Cの割り込みはアプリケーション動作前の状態に戻ります。

-----------------------------------------------------------------------------
.RSB_Gettxlen
送信バッファ内の有効データ数の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Gettxlen(int port, int *len); 
int     port;                    /*   ポート番号(0〜4)     */ 
int     *len;                    /*   データ数             */ 

- 戻り値 -
0 :正常終了
2 :範囲外のポートを指定した
3 :拡張カードが接続されていないポートを指定した
4 :回線がオープン状態ではない

- 例 -
#include <rs.h> 
        …
int     port = 0; 
int     len;
int     ret;

ret = RSB_Gettxlen(port, &len); 

- 内容 -
送信バッファ内にはいっているデータ数を返します。

-----------------------------------------------------------------------------
.RSB_Hdchk 
FIFO機能の有無の検出
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
unsigned int  RSB_Hdchk(void);

- 戻り値 -
検出データ

- 例 -
#include <rs.h> 
        …
unsigned int  fifodt; 

fifodt = RSB_Hdchk();

- 内容 -
ポートごとにFIFO機能の有無を読み取ります。

検出データ

          15  14  13  12  11  10   9   8
        ┌─┬─┬─┬─┬─┬─┬─┬─┐
fifodt: │ 0│ 0│ 0│ 0│ 0│ 0│ 0│ 0│
        └─┴─┴─┴─┴─┴─┴─┴─┘

           7   6   5   4   3   2   1   0
        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        │  │  │  │  │  │  │  │  │
        └┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┘
          └─┴─┴─┼─┴─┴─┘  └─  ポート0
                      │
                      └─────────  リザーブ

bit0の値は、0:FIFO機能無し、1:FIFO機能有りとなります。
bit1〜bit7の値は、不定になります。

-----------------------------------------------------------------------------
.RSB_Init2 
Native RS-232Cの初期化(ポート指定)
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Init2(int IOport);
int     IOport;                    /*   ﾎﾟｰﾄ0(=0), ﾎﾟｰﾄ1〜4(=1)  */ 

- 戻り値 -
 0 :正常終了
-1 :異常終了(DOS-Extenderのシステムコールによる割り込みベクタのアドレス
    獲得/登録に失敗した)
-2 :範囲以外のパラメータ値を指定した

- 例 -
#include <rs.h> 
        …
int     IOport = 0; 
int     ret;

ret = RSB_Init2(IOport);

- 内容 -
下記の単位に、RS-232Cの割り込みをプロテクトモードで動作するアプリケーションで
使用できるように環境設定します。

  IOport = 0:ポート番号＝0をプロテクトモードで使用します
  IOport = 1:ポート番号＝1〜4をプロテクトモードで使用します

-----------------------------------------------------------------------------
.RSB_Initbuf 
受信バッファの初期化
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Initbuf(int port);
int     port;                /*   ポート番号(0〜4)          */

- 戻り値 -
0 :正常終了
2 :範囲以外のポート番号を指定した
3 :拡張カードが接続されていないポートを指定した
4 :回線がオープン状態ではない

- 例 -
#include <rs.h> 
        …
int     port, ret;

port = 0; 
ret = RSB_Initbuf(port);

- 内容 -
受信バッファ内のデータカウント、各ポインタを初期化します。

-----------------------------------------------------------------------------
.RSB_Init
Native RS-232Cの初期化
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Init(void); 

- 戻り値 -
 0 :正常終了
-1 :異常終了(DOS-Extenderのシステムコールによる割り込みベクタのアドレス獲得/
    登録に失敗しました)

- 例 -
#include <rs.h> 
        …
int     ret;

ret = RSB_Init(); 

- 内容 -
RS-232Cの割り込みをプロテクトモードで動作するアプリケーションで使用できるよう
に環境設定します。

-----------------------------------------------------------------------------
.RSB_Open
回線オープン
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Open(int port); 
int     port;                      /*   ポート番号(0〜4)  */

- 戻り値 -
0 :正常終了
2 :範囲外のポートを指定した
3 :拡張カードが接続されていないポートを指定した
5 :回線がクローズ状態ではない
7 :通信パラメータが設定されていないのに回線をオープンしようとした

- 例 -
#include <rs.h> 
        …
int     port = 0; 
int     ret;

ret = RSB_Open(port); 

- 内容 -
RSB_Setpara関数で設定したモードで回線をオープンします。回線オープン時には受信
バッファ内の文字カウンタ、入力ポインタ、出力ポインタを初期化します。
通信パラメータを設定しない場合、またはすでにオープンされている場合はオープン
できません。ポート0にFIFO機能がある場合には、FIFO機能を有効にします。

-----------------------------------------------------------------------------
.RSB_Rdint 
拡張割り込みの読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Rdint(int port, char *intbuf);
int     port;                      /*   ポート番号(0〜4)      */
RSB_INT  *intbuf;                  /*   割り込みパラメータ    */

- 戻り値 -
0 :正常終了
2 :範囲外のポートを指定した
3 :拡張カードが接続されていないポートを指定した

- 例 -
#include <rs.h> 
        …
int     port = 0; 
char    *intbuf;
int     ret;

ret = RSB_Rdint(port, &intbuf); 

- 内容 -
RSB_Setint関数で設定した割り込みパラメータを、指定した割り込みパラメータ領域
に読み込みます。

･割り込みパラメータアドレス

  intbuf→  ┌─┬─┬───────────────────┐
           0│Ｒ│Ｂ│          割り込みフラグ              │
            ├─┼─┼───────────────────┤
           1│Ｒ│Ｄ│  CS信号割り込みオフセットアドレス    │
            ├─┼─┼───────────────────┤
           5│Ｒ│Ｗ│  CS信号割り込みセレクタアドレス      │
            ├─┼─┼───────────────────┤
           7│Ｒ│Ｄ│  CI信号割り込みオフセットアドレス    │
            ├─┼─┼───────────────────┤
           B│Ｒ│Ｗ│  CI信号割り込みセレクタアドレス      │
            └─┴─┴───────────────────┘

-----------------------------------------------------------------------------
.RSB_Rdpara
通信パラメータの読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Rdpara(int port, char *paraadr);
int     port;                      /*   ポート番号(0〜4)  */
RSB_PARA  *paraadr;                /*   通信パラメータ    */

- 戻り値 -
0 :正常終了
2 :範囲外のポート番号を指定した
3 :拡張カードが接続されていないポートを指定した
7 :通信パラメータが設定されていないのに、通信パラメータを取得しようとした

- 例 -
#include <rs.h> 
        …
int         port = 0; 
char        *paraadr; 
int         ret;

ret = RSB_Rdpara(port, &paraadr); 

- 内容 -
RSB_Setpara関数で設定した通信パラメータを、指定された通信パラメータ領域に読み
込みます。

- 注意 -
オフセット12H以降は通信モードの拡張モード指定(bit7)がONのときのみ読み取りがで
き、OFFのときは読み取りができません。

通信パラメータアドレス

  paraadr →  ┌─┬─┬───────────────────┐
             0│Ｒ│Ｂ│          通信モード                  │
              ├─┼─┼───────────────────┤
             1│Ｒ│Ｂ│          ボーレート                  │
              ├─┼─┼───────────────────┤
             2│Ｒ│Ｄ│      受信バッファオフセット          │
              ├─┼─┼───────────────────┤
             6│Ｒ│Ｗ│      受信バッファセレクタ            │
              ├─┼─┼───────────────────┤
             8│Ｒ│Ｗ│      送信タイムアウト時間            │
              ├─┼─┼───────────────────┤
             A│Ｒ│Ｗ│      受信タイムアウト時間            │
              ├─┼─┼───────────────────┤
             C│Ｒ│Ｄ│      受信通知オフセット              │
              ├─┼─┼───────────────────┤
            10│Ｒ│Ｗ│      受信通知セレクタ                │
              ├─┼─┼───────────────────┤
            12│Ｒ│Ｂ│      拡張通信モード                  │
              ├─┼─┼───────────────────┤
            13│Ｒ│Ｂ│      XONコード                       │
              ├─┼─┼───────────────────┤
            14│Ｒ│Ｂ│      XOFFコード                      │
              ├─┼─┼───────────────────┤
            15│Ｒ│Ｄ│      送信バッファオフセット          │
              ├─┼─┼───────────────────┤
            19│Ｒ│Ｗ│      送信バッファセレクタ            │
              └─┴─┴───────────────────┘

-----------------------------------------------------------------------------
.RSB_Read
受信バッファ内の有効データ数の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Read(int port, int *leng);
int     port;               /*  ポート番号(0〜4)          */
int     *leng;              /*  データ長                  */

- 戻り値 -
0 :正常終了
2 :範囲以外のポート番号を指定した
3 :拡張カードが接続されていないポートを指定した
4 :回線がオープン状態ではない

- 例 -
#include <rs.h> 
        …
int     port, leng, ret;

port = 0; 
ret = RSB_Read(port, &leng);

- 内容 -
受信バッファ内に入っているデータ数を返します。

-----------------------------------------------------------------------------
.RSB_Receive 
データの受信
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Receive(int port, int *data, unsigned int *status); 
int     port;                  /*   ポート番号(0〜4)         */
int    *data;                  /*   データ                   */
unsigned int    *status;       /*   ステータス               */
                               /*   bit15-8 :ステータス      */
                               /*   bit7-0  :拡張ステータス  */

- 戻り値 -
0  :正常終了
2  :範囲外のポート番号を指定した
3  :拡張カードが接続されていないポートを指定した
4  :回線がオープン状態ではない
8  :タイムアウト時間内にデータの受信ができなかった
10 :即時復帰の場合に受信バッファにデータがなかった

- 例 -
#include <rs.h> 
        …
int     port, data, ret;
unsigned int    status; 

port = 0; 
ret = RSB_Receive(port, &data, &status);

- 内容 -
受信バッファ内に入っているデータを受け渡します。受信バッファが空の場合、受信
タイムアウト時間内にデータの受信ができなかったときは強制復帰を行います。
XON/XOFF制御ありのとき、XONコードとXOFFコードはデータにはなりません。
バッファオーバーフローになった場合、あふれたデータは捨てられます。

- 注意 -
statusのbit7-0は｢拡張通信モード｣の｢データ受信時のバッファオーバーフロー通知｣
が1のときのみ有効です。
｢バッファオーバーフロー通知｣が0のときはstatus のbit7-0の値は保存されます。

･ステータス

            15  14  13  12  11  10  9  8
          ┌─┬─┬─┬─┬─┬─┬─┬─┐
   status:│  │  │  │  │  │  │  │  │
          └┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┘
            │  │  │  │  │  │  │  └─書き込み状態 (TxRdy)  0:不可
            │  │  │  │  │  │  │                            1:可能
            │  │  │  │  │  │  └───読み込み状態 (RxRdy)  0:不可
            │  │  │  │  │  │                                1:可能
            │  │  │  │  │  └─────送信キャラクタ (TXE)  0:あり
            │  │  │  │  │                                    1:なし
            │  │  │  │  └───────パリティエラー (PE)   0:なし
            │  │  │  │                                        1:あり
            │  │  │  └────────オーバランエラー (OE)   0:なし
            │  │  │                                            1:あり
            │  │  └───────────フレームエラー (FE)   0:なし
            │  │                                                1:あり
            │  └───────────SYNCキャラクタ (SYNDET)   0:なし
            │                                                    1:あり
            └─────────────────DSR 信号 (DSR)    0:OFF 
                                                                  1:ON
  
･拡張ステータス

             7   6   5   4   3   2   1   0
          ┌─┬─┬─┬─┬─┬─┬─┬─┐
   status:│ 0│ 0│ 0│ 0│ 0│ 0│ 0│  │
          └─┴─┴─┴─┴─┴─┴─┴┬┘
                                        │
                                        └──バッファオーバーフロー
                                                    0: なし
                                                    1: あり

-----------------------------------------------------------------------------
.RSB_Send
データの送信
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Send(int port, int data, unsigned int *status) ;
int     port;                /*   ポート番号(0〜4)          */
int     data;                /*   データ(1バイト)           */
unsigned int    *status;     /*   ステータス                */

- 戻り値 -
0  :正常終了
2  :範囲以外のポート番号を指定した
3  :拡張カードが接続されていないポートを指定した
4  :回線がオープン状態ではない
8  :タイムアウト時間内にデータの送信ができなかった
9  :XOFFコードを受信していたためタイムアウト時間内にデータの送信ができな
    かった
11 :即時復帰の場合にデータが送信できる状態ではなかった

- 例 -
#include <rs.h> 
        …
int     port, data, ret;
unsigned int    status; 

port = 0; 
data = 0x41;
ret = RSB_Send(port, data, &status);

- 内容 -
シリアルポートにデータを書き込みます。
送信タイムアウト時間内に送信できない場合は強制復帰を行います。

･ステータス

            15  14  13  12  11  10   9   8
          ┌─┬─┬─┬─┬─┬─┬─┬─┐
   status:│ 0│ 0│ 0│ 0│ 0│ 0│ 0│ 0│
          └─┴─┴─┴─┴─┴─┴─┴─┘
  
             7   6   5   4   3   2   1   0
          ┌─┬─┬─┬─┬─┬─┬─┬─┐
          │  │  │  │  │  │  │  │  │
          └┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┘
            │  │  │  │  │  │  │  └─書き込み状態 (TxRdy)  0:不可
            │  │  │  │  │  │  │                            1:可能
            │  │  │  │  │  │  └───読み込み状態 (RxRdy)  0:不可
            │  │  │  │  │  │                                1:可能
            │  │  │  │  │  └─────送信キャラクタ (TXE)  0:あり
            │  │  │  │  │                                    1:なし
            │  │  │  │  └───────パリティエラー (PE)   0:なし
            │  │  │  │                                        1:あり
            │  │  │  └────────オーバランエラー (OE)   0:なし
            │  │  │                                            1:あり
            │  │  └───────────フレームエラー (FE)   0:なし
            │  │                                                1:あり
            │  └───────────SYNCキャラクタ (SYNDET)   0:なし
            │                                                    1:あり
            └─────────────────DSR 信号 (DSR)    0:OFF 
                                                                  1:ON

-----------------------------------------------------------------------------
.RSB_Setint
拡張割り込みの設定
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Setint(int port, char *intbuf); 
int     port;                      /*   ポート番号(0〜4)      */
RSB_INT  *intbuf                   /*   割り込みパラメータ    */

- 戻り値 -
0 :正常終了
2 :範囲外のポートを指定した
3 :拡張カードが接続されていないポートを指定した

- 例 -
#include <rs.h> 
        …
int     port = 0; 
char    *intbuf;
int     func1(), func2();            /*   割り込み処理ルーチン      */

intbuf.flg = 0x03;                   /*   CS,CI 割り込みがあります  */
BSSETCODEADR(&intbuf.cs_adr, func1);
BSSETCODEADR(&intbuf.ci_adr, func2);
ret = RSB_Setint(port, &intbuf);

- 内容 -
拡張割り込みの指定を行います。

- 注意 -
CS割り込みとCI割り込みは割り込みが入った場合、NEAR CALLしますので、処理が終了
したときは、NEAR RETを行ってください。

･割り込みパラメータアドレス

  intbuf→  ┌─┬─┬───────────────────┐
           0│Ｅ│Ｂ│          割り込みフラグ              │
            ├─┼─┼───────────────────┤
           1│Ｅ│Ｄ│  CS信号割り込みオフセットアドレス    │
            ├─┼─┼───────────────────┤
           5│Ｅ│Ｗ│  CS信号割り込みセレクタアドレス      │
            ├─┼─┼───────────────────┤
           7│Ｅ│Ｄ│  CI信号割り込みオフセットアドレス    │
            ├─┼─┼───────────────────┤
           B│Ｅ│Ｗ│  CI信号割り込みセレクタアドレス      │
            └─┴─┴───────────────────┘
  
･割り込みフラグ

     7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┐
  │ 0│ 0│ 0│ 0│ 0│ 0│  │  │
  └─┴─┴─┴─┴─┴─┴┬┴┬┘
                            │  └─  CS割り込み  0:なし
                            │                    1:あり
                            └───  CI割り込み  0:なし
                                                  1:あり

･CS割り込みアドレス
 回線からCS(Clear to Send)による割り込みがあったことを通知する処理ルーチンの
 アドレスを設定します。
 この指定は割り込みフラグのCS割り込み(bit0)が1の場合にのみ設定されます。
 なお、セレクタとオフセットの値が0のときは通知しません。

･CI割り込みアドレス
 回線からCI(Calling Indicator)による割り込みがあったことを通知する処理ルーチ
 ンのアドレスを設定します。
 この指定は割り込みフラグのCI割り込み(bit1)が1の場合にのみ設定されます。
 なお、セレクタとオフセットの値が0のときは通知しません。

-----------------------------------------------------------------------------
.RSB_Setpara 
通信パラメータの設定
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Setpara(int port, char *paraadr); 
int     port;                    /*   ポート番号(0〜4)         */ 
char    *paraadr;                /*   通信パラメータアドレス   */ 

- 戻り値 -
0 :正常終了
2 :範囲外のポートを指定した
3 :拡張カードが接続されていないポートを指定した
5 :回線がクローズ状態ではない
6 :受信バッファ領域が確保されていない

- 例 -
#include <rs.h> 
        …
int     port = 0; 
char    *paraadr; 
int     ret;

ret = RSB_Setpara(port, paraadr); 

- 内容 -
シリアルポートの通信パラメータを設定します。
オープン状態で通信パラメータを変更することはできません。

- 注意 -
送信タイムアウト時間、受信タイムアウト時間は0のみ指定可能です。
受信通知セレクタの値は無視され、リンクしたプログラムのCS値になります。

通信パラメータアドレス

  paraadr →  ┌─┬─┬───────────────────┐
             0│Ｅ│Ｂ│          通信モード                  │
              ├─┼─┼───────────────────┤
             1│Ｅ│Ｂ│          ボーレート                  │
              ├─┼─┼───────────────────┤
             2│Ｅ│Ｄ│      受信バッファオフセット          │
              ├─┼─┼───────────────────┤
             6│Ｅ│Ｗ│      受信バッファセレクタ            │
              ├─┼─┼───────────────────┤
             8│Ｅ│Ｗ│      送信タイムアウト時間            │
              ├─┼─┼───────────────────┤
             A│Ｅ│Ｗ│      受信タイムアウト時間            │
              ├─┼─┼───────────────────┤
             C│Ｅ│Ｄ│      受信通知オフセット              │
              ├─┼─┼───────────────────┤
            10│Ｅ│Ｗ│      受信通知セレクタ                │
            ─┼─┼─┼───────────────────┼─
            12│Ｅ│Ｂ│      拡張通信モード                  │
              ├─┼─┼───────────────────┤
            13│Ｅ│Ｂ│      XONコード                       │
              ├─┼─┼───────────────────┤
            14│Ｅ│Ｂ│      XOFFコード                      │
              ├─┼─┼───────────────────┤
            15│Ｅ│Ｄ│      送信バッファオフセット          │
              ├─┼─┼───────────────────┤
            19│Ｅ│Ｗ│      送信バッファセレクタ            │
              └─┴─┴───────────────────┘

･通信モード

     7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┐
  │  │ 0│  │  │  │  │  │  │
  └┬┴─┴┬┴┬┴┬┴┬┴┬┴┬┘
    │      │  │  │  │  │  └─  ビット長  0:7 bit
    │      │  │  │  │  │                  1:8 bit
    │      │  │  │  │  └───  パリティ  0:なし
    │      │  │  │  │                      1:あり
    │      │  │  │  └──  パリティビット  0:奇数 (ODD)
    │      │  │  │                          1:偶数 (EVEN) 
    │      │  │  └───    ストップビット  0:1 bit
    │      │  │                              1:2 bit
    │      │  └─────    XON/XOFF制御    0:なし
    │      │                                  1:あり
    │      └───────    クロック状態    0:内部
    │                                          1:外部
    └───────────  拡張モードの設定  0:なし
                                                1:あり

･ボーレート
 シリアルポートのボーレートを設定します。

     7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┐
  │ 0│ 0│ 0│ 0│ 0│  │  │  │
  └─┴─┴─┴─┴─┴┬┴─┴┬┘
                        └─┬─┘
                            └────ボーレート
                                        000:   300 bps
                                        001:   600 bps
                                        010:  1200 bps
                                        011:  2400 bps
                                        100:  4800 bps
                                        101:  9600 bps
                                        110: 19200 bps

･受信バッファ

   受信バッファアドレス
      │
      └→  ┌─┬─┬─────────────────┐
            │Ｅ│Ｗ│      受信バッファ長              │
            ├─┼─┼─────────────────┤
            │  │Ｗ│      文字カウンタ                │
            ├─┼─┼─────────────────┤
            │  │Ｗ│      入力ポインタ                │
            ├─┼─┼─────────────────┤
            │  │Ｗ│      出力ポインタ                │
    ────├─┼─┼─────────────────┤
      ↑    │Ｒ│Ｂ│      データ                      │
      受フ  ├─┼─┼─────────────────┤
            │Ｒ│Ｂ│      ステータス                  │
      信ァ  ├─┼─┼─────────────────┤
            │  │  │   データ/ステータス部分の        │
      バ領  │  │  │                                  │
            〜  〜  〜   繰り返し                       〜
      ッ域  │  │  │                                  │
      ↓    │  │  │                                  │
    ────└─┴─┴─────────────────┘

    バッファ長  :  受信バッファ領域の大きさを返します
    文字カウンタ:  受信バッファ内に入っているデータ数を示します
    入力ポインタ:  次に入力される文字のバッファ位置を示します
    出力ポインタ:  次に出力される文字のバッファ位置を示します

- 注意 -
受信バッファ内でのセグメントオーバーランを防ぐため、受信バッファ領域を受信
バッファ長より16byte余分に確保してください。
文字カウンタ、入力ポインタ、出力ポインタは回線オープン時に初期化されます。

･タイムアウト時間
 送信/受信のタイムアウト時間を設定します。

  タイムアウト時間
    指定時間  1〜65534×10ms
      0        :  送/受信の結果にかかわらず即時復帰を行います
      1〜65534 :  指定時間内に送/受信が完了しない場合はタイムアウト
                  となり強制復帰を行います
      65535    :  送/受信が完了するまで復帰しません

･XON/XOFFコード
 XON/XOFFのバッファ制御を指定します。

･拡張通信モード

     7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┐
  │ 0│ 0│ 0│ 0│  │  │  │  │
  └─┴─┴─┴─┴┬┴┬┴┬┴┬┘
                    │  │  │  └─ XON/XOFF 
                    │  │  │        コード変更  0:なし
                    │  │  │                    1:あり
                    │  │  └───データ受信時の
                    │  │            バッファオーバーフロー通知
                    │  │                        0:なし
                    │  │                        1:あり
                    │  └─────RTSフロー制御
                    │                            0:なし
                    │                            1:あり
                    └───────送信バッファアドレス指定
                                                  0:なし
                                                  1:あり

･送信バッファ

   送信バッファアドレス
      │
      └→  ┌─┬─┬─────────────────┐
            │Ｅ│Ｗ│      送信バッファ長              │
            ├─┼─┼─────────────────┤
            │  │Ｗ│      文字カウンタ                │
            ├─┼─┼─────────────────┤
            │  │Ｗ│      入力ポインタ                │
            ├─┼─┼─────────────────┤
            │  │Ｗ│      出力ポインタ                │
    ────├─┼─┼─────────────────┤
      ↑    │Ｅ│Ｂ│      データ                      │
      送フ  ├─┼─┼─────────────────┤
            │  │  │                                  │
      信ァ  │  │  │                                  │
            〜  〜  〜                                  〜
      バ領  │  │  │                                  │
            │  │  │                                  │
      ッ域  ├─┼─┼─────────────────┤
      ↓    │Ｅ│Ｂ│      データ                      │
    ────└─┴─┴─────────────────┘

    バッファ長  :  送信バッファ領域の大きさを返します
    文字カウンタ:  送信バッファ内に入っているデータ数を示します
    入力ポインタ:  次に入力される文字のバッファ位置を示します
    出力ポインタ:  次に出力される文字のバッファ位置を示します

-----------------------------------------------------------------------------
.RSB_Status
ステータス情報の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <rs.h> 
int     RSB_Status(int port, unsigned int *status, unsigned int *serial); 
int     port;             /*    ポート番号(0〜4)              */ 
unsigned int  *status;    /*  bit15-8 :ステータスレジスタの   */ 
                          /*           内容                   */ 
                          /*  bit7-0  :信号線状態             */ 
unsigned int  *scrial;    /*  bit15-8 :0:オープン状態         */ 
                          /*           1:クローズ状態         */ 
                          /*  bit7-0  :シリアルポートの状態   */ 

- 戻り値 -
0 :正常終了
2 :範囲以外のポート番号を指定した
3 :拡張カードが接続されていないポートを指定した

- 例 -
#include <rs.h> 
        …
int     port, ret;
unsigned int    status , serial;

port = 0; 
ret = RSB_Status(port, &status , &serial);

- 内容 -
シリアルポートのステータス情報を通知します。

･シリアルポートの状態
 シリアルポートの制御で設定したDTS/RTS信号の状態

             7   6   5   4   3   2   1   0
          ┌─┬─┬─┬─┬─┬─┬─┬─┐
  serial: │ 0│ 0│  │ 0│ 0│ 0│  │ 0│
          └─┴─┴┬┴─┴─┴─┴┬┴─┘
                    │              └─── DTR  0:OFF 
                    │                            1:ON
                    └─────────── RTS  0:OFF 
                                                  1:ON

･ステータスレジスタの内容

            15  14  13  12  11  10   9   8
          ┌─┬─┬─┬─┬─┬─┬─┬─┐
   status:│  │  │  │  │  │  │  │  │
          └┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┘
            │  │  │  │  │  │  │  └─書き込み状態 (TxRdy)  0:不可
            │  │  │  │  │  │  │                            1:可能
            │  │  │  │  │  │  └───読み込み状態 (RxRdy)  0:不可
            │  │  │  │  │  │                                1:可能
            │  │  │  │  │  └─────送信キャラクタ (TXE)  0:あり
            │  │  │  │  │                                    1:なし
            │  │  │  │  └───────パリティエラー (PE)   0:なし
            │  │  │  │                                        1:あり
            │  │  │  └────────オーバランエラー (OE)   0:なし
            │  │  │                                            1:あり
            │  │  └───────────フレームエラー (FE)   0:なし
            │  │                                                1:あり
            │  └───────────SYNCキャラクタ (SYNDET)   0:なし
            │                                                    1:あり
            └─────────────────DSR 信号 (DSR)    0:OFF 
                                                                  1:ON

･信号線状態

             7   6   5   4   3   2   1   0
          ┌─┬─┬─┬─┬─┬─┬─┬─┐
   status:│ 0│ 0│ 0│ 0│  │  │  │  │
          └─┴─┴─┴─┴┬┴┬┴┬┴┬┘
                            │  │  │  └── CI   0:OFF 
                            │  │  │              1:ON
                            │  │  └──── CTS  0:OFF 
                            │  │                  1:ON
                            │  └────── CD   0:OFF 
                            │                      1:ON
                            └──────── DSR  0:OFF 
                                                    1:ON

2.3 サンプルプログラム

┌────────────────────────────────────┐
│  Native RS232C  ライブラリ  サンプルプログラム                         │
│  ■  機能  ■                                                          │
│    簡易ターミナルを実現します。                                        │
└────────────────────────────────────┘
/************************************************************************/
/*                                                                      */
/*    TERM by RS232C Native-Library                                     */
/*    SAMPLEPROGRAM                                                     */
/*                                                                      */
/*    簡易ターミナルを実現します                                        */
/*    端末を接続して､コマンドモード上で動作させてください               */
/*    実行時には必ず通信ポートをパラメータとして指定してください        */
/*                                                                      */
/************************************************************************/
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h> 
#include <conio.h>
#include <egb.h>
#include <mos.h>
#include <fmcfrb.h> 
#include <string.h> 
#include <rs.h> 

char para[27];            /*    RSパラメータ    */
char buffer[65536];       /*    受信バッファ    */
unsigned status;
unsigned int moji = '?';
int sdata = '?';
int rdata = '?';
int leng; 

int chrcnt;
unsigned encode;
int main(int argc, char *argv[])
{
/********************************************************************/
/*                        各パラメータの設定                        */
/********************************************************************/
  int ret = 0;
  int port; 
  unsigned short limit;           /* 受信成功待ちループの最大値 */

  WORD(buffer+0) = 4096;

  BYTE(para+0) = 0x11;            /* 8ビット/X制御あり           */
  BYTE(para+1) = (char)3;         /* 2400bps                     */
  DWORD(para+2) = (unsigned int)buffer;  /* 受信バッファアドレス */
  WORD(para+6) = 0x14;                   /* 受信バッファセレクタ */
  WORD(para+8) = 0;               /* 送信タイムアウト時間        */
  WORD(para+10) = 0;              /* 受信タイムアウト時間        */
  DWORD(para+12) = 0;             /* 受信通知アドレス            */
  WORD(para+16) = 0;              /* 受信通知セレクタ            */
  BYTE(para+18) = 0;              /* 拡張通信モード              */
  BYTE(para+19) = 0;              /* XONコード                   */
  BYTE(para+20) = 0;              /* XOFFコード                  */
  DWORD(para+21) = 0;             /* 送信バッファアドレス        */
  WORD(para+25) = 0;              /* 送信バッファセレクタ        */

/********************************************************************/
/*                      プログラムスタート                          */
/********************************************************************/
  if(argc==2) 
    {
      port = atoi(argv[1]); 
    }
  else
    {
      printf(" [33m");
      printf("\n******* Parameter Error!! *******\n");
      printf("起動時にポート番号のパラメータを入力してください"); 
      printf(" [37m");
      return(-1);
    }

/********************************************************************/
/*                      初期化処理ルーチン                          */
/********************************************************************/

/* INPKEY INIT */
  chrcnt=0;
  encode=0;

/* TITLE MESSAGE */
  printf(" [2J");
  printf("Native RS-232cライブラリサンプルプログラム\n");
  printf("簡易ターミナルを実現します\n");
  printf("何かキーを押すと端末と画面に文字を送ります\n");
  printf("端末で押されたキーを表示します\n");
  printf("ANKのみ使用可能  通信中にかな漢字変換をしないでください\n");
  printf("PF1キーを押すと終了します\n");
  printf(" [32m");
  printf("\n〜 START EASY_TERM 〜");
  printf(" [36m");
  printf("   SEND");
  printf(" [37m");
  printf("/");
  printf(" [33m");
  printf("RECEIVE");
  printf(" [37m");
  printf("   [PORT = %d]\n",port);
  printf(" [37m");

/* RS232C INIT */
  ret = RSB_Init();
  ret = RSB_Setpara(port, para);
  ret = RSB_Open(port);

/* KEY INIT */
  KYB_init();
  KYB_clic(1);
  KYB_clrbuf();

/********************************************************************/
/*                      送受信処理ルーチン                          */
/********************************************************************/
for(;;)
  {                        /* START TERM */

/********************************************************************/
/*                      受信処理ルーチン                            */
/********************************************************************/
  ret = RSB_Read(port,&leng);

  if(leng>0)
    {
      ret = 1;
      for(limit=0;limit<0xffff;limit++)
        {
          ret = RSB_Receive(port, &rdata, &status);
          if(ret == 0) break;
        }
      printf(" [33m");
      printf("%c",rdata);
      printf(" [37m");
      if(rdata==0x0d) printf("%c",0x0a);
    }

/********************************************************************/
/*                      キー入力処理ルーチン                        */
/********************************************************************/
  for(limit=0;limit<0x000f;limit++)
    {
       moji=KYB_inpchk(&chrcnt,&encode);    /* キー入力チェック */
       if(chrcnt>0) break;

    }
      if(chrcnt>0)
    {
/********************************************************************/
/*                  終了指示の有無をチェックします                  */
/********************************************************************/
      if(moji==0x8001)                /* 'PF1' key */
        {
          KYB_clrbuf();
          printf(" [37m");
          printf("\n*******  [32mNOW END TERM-PROGRAM  [37m*******\n");
          printf(" [37m");
          ret = RSB_Close(port);
          ret = RSB_End();
          return(0);
        }

      sdata = moji;

/********************************************************************/
/*                        送信処理ルーチン                          */
/********************************************************************/
      ret = 1;
      for(limit=0;limit<0xffff;limit++)
        {
          ret = RSB_Send(port, sdata, &status);
          if(ret == 0) break;
        }
      if(ret!=0)
        {
          printf(" [37m");
          printf("\n===>  [31msend error occured  [37m<===\n");
          printf(" [37m");
        }

      printf(" [36m");
      printf("%c",sdata);
      printf(" [37m");
      if(sdata==0x0d) printf("%c",0x0a);

      chrcnt=0;
      KYB_clrbuf();

    }
  }                        /* END TERM */

/********************************************************************/
/*                        終了処理ルーチン                          */
/********************************************************************/
  printf(" [37m");
  printf("\n***  [31mProgram abnomal end  [37m***\n");
  printf(" [37m");

  return(0);
}

*****************************************************************************
第9章  ダイナミックリンクサポートライブラリ
*****************************************************************************

1 ダイナミックリンクサポートライブラリについて

1.1 ダイナミックリンクとは

  ダイナミックリンクは、プログラムが利用するライブラリをディスクファイルとし
ておき、必要なときにロードし、実行する機能です。ダイナミックリンク機能に対応
したライブラリをダイナミックリンクライブラリと呼びます。ダイナミックリンクラ
イブラリはプログラム本体にスタティックリンクされず、ファイルとしてディスク上
に置かれます。つまり、ライブラリは開発時にリンクされていません。プログラムが
処理中にダイナミックリンクライブラリ関数を呼び出したときに、ファイルをプログ
ラムの管理しているメモリ上に読み込み、実行します。いったんダイナミックリンク
ライブラリがメモリ上に読み込まれると、次からのライブラリ関数の呼び出しのとき
にはディスクから読み込まれることはなく、メモリ上のダイナミックリンクライブラ
リが実行されます。
  Townsシステムソフトウェア V2.1ではムービーライブラリ、アニメーションライブ
ラリ、JPEGライブラリ、拡張フォント管理ライブラリなどがダイナミックリンクライ
ブラリとして提供されています。ダイナミックリンクライブラリは従来のライブラリ
と形式が異なるため、現バージョンではTownsシステムソフトウェアやHigh C付属のラ
イブラリ(以上を標準ライブラリと呼ぶ)や従来から提供されている拡張ライブラリI/
IIはダイナミックリンクライブラリとして使用することはできません。

1.2 ダイナミックリンクの特徴

  Townsシステムソフトウェア V2.1はシングルタスクのシステムで実現されているこ
と、仮想記憶システムではないことなどから、WindowsやOS/2など他のOSが持つ一般的
なダイナミックリンクとは意味が異なります。

1.2.1 メモリ管理

  Townsシステムソフトウェア V2.1では一般にアプリケーションがすべてのフリーメ
モリを管理しています。このため、ダイナミックリンクライブラリのためにシステム
から動的にメモリを要求することはできません。
  そこで、アプリケーションにスタティックリンクされているダイナミックリンクマ
ネージャは、必要に応じてアプリケーションに対してメモリ要求を行います。アプリ
ケーションのメモリ管理関数を呼び出すことによって必要なメモリを取得するのです
。このため、ダイナミックリンクライブラリがロードされるメモリは一般的にアプリ
ケーション側が持つヒープ領域となります。
  また、ダイナミックリンクライブラリのあるメモリの解放は、ダイナミックリンク
マネージャ側から行われることはなく、アプリケーション自身が必要に応じて行うこ
とになります。この点でアプリケーションは、自分自身で各ダイナミックリンクライ
ブラリのロードや廃棄を管理することになります。

                                            ┌──────────┐
                                            │ ダイナミックリンク │
  ┌──────────┐                  │                    │
  │  アプリケーション  │                  │    マネージャ(注)  │
  │┌ 1───────┐│ 2 呼び出し       │┌ 3───────┐│
  ││ﾀﾞｲﾅﾐｯｸﾘﾝｸﾗｲﾌﾞﾗﾘ├┼────────→││ 必要サイズ算出 ││
  ││                ││                  │└───┬────┘│
  ││ 呼び出し       ││ 5 メモリ確保関数 │        │          │
  │└────────┘│                  │        ↓          │
  │┌ 6───────┐│   呼び出し       │┌ 4───────┐│
  ││ メモリ確保関数 ││←────────┼┤   メモリ確保   ││
  ││                ├┼────────→│└───┬────┘│
  ││ 実行           ││                  │        │          │
  ││                ││                  │┌ 7──┴────┐│
  ││ mallocなど     ││                  ││ライブラリロード││
  │└────────┘│                  │└───┬────┘│
  └──────────┘                  └────┼─────┘
                                       8ライブラリ実行↓
                                            ┌──────────┐
                                            │   ライブラリ本体   │
                                            └──────────┘

- 注意 -
ダイナミックリンクマネージャはアプリケーションにスタティックリンクされます。

1.2.2 ダイナミックリンクライブラリの呼び出し

  ダイナミックリンクライブラリがアプリケーション領域に展開されるため、ダイナ
ミックリンクライブラリは通常はNEARコール(オフセットアドレスのみの呼び出し)で
呼び出すことができます。このため、アプリケーションプログラマから見れば、従来
の(スタティックリンク)ライブラリとダイナミックリンクライブラリの呼び出しかた
は同等に見えます。
  ダイナミックリンクライブラリから、他のダイナミックリンクライブラリを呼び出
すことも可能です。また、ダイナミックリンクから標準ライブラリや拡張ライブラリ
を呼び出すことも可能です。この場合、これらのライブラリはアプリケーション本体
側にスタティックリンクされている必要があり、ダイナミックリンクライブラリから
アプリケーション本体側にスタティックリンクされているライブラリが呼び出される
ことになります。

  ┌───────────┐
  │   アプリケーション   │ 呼び出し ┌───────────┐
  │                      ├────→│  ダイナミックリンク  │
  │        本体          │    ┌──┤                      │
  │                      │    │    │  ライブラリ          │
  ├───────────┤    │    └───────────┘
  │  スタティックリンク  │    │                ↑
  │                      │    │      呼び出し  │
  │      ライブラリ      │    │                ↓
  │                      │←─┘    ┌───────────┐
  │  ･標準ライブラリ     │          │  ダイナミックリンク  │
  │                      │          │                      │
  │  ･拡張ライブラリ     │          │  ライブラリ          │
  └───────────┘          └───────────┘
  
1.2.3 コード共有

  Townsシェルアプリケーションがダイナミックリンクを行う場合、コード共有の機能
を利用することができます。詳しくは拡張ライブラリII｢GUIライブラリ V2.1 ユーザ
ーズガイド｣を参照してください。拡張子が".EXP"のアプリケーションでは、シングル
タスクのシステム上で実現されているため、コード共有の機能を利用できません。

1.3 ダイナミックリンク実現方式の概要

  アプリケーションがダイナミックリンクライブラリを呼び出した時点で、ディスク
上に存在するダイナミックリンクライブラリがメモリ上にロード(ダイナミックリンク
)されます。このとき、アプリケーションは呼び出したライブラリがダイナミックリン
クライブラリか従来のスタティックリンクライブラリかを意識しません。ライブラリ
がダイナミックリンクライブラリであれば、ダイナミックリンクマネージャが自動的
にダイナミックリンクに関する処理を行います。
  このとき、ダイナミックリンクマネージャは、アプリケーションのメモリ取得関数
を呼び返し、ダイナミックリンクライブラリをロードするメモリを確保します。
また、ダイナミックリンクライブラリがメモリから不要になった場合には、アプリケ
ーションがダイナミックリンクマネージャにメモリ開放要求を行うことにより、
ダイナミックリンクライブラリの占有していたメモリを開放することができます。

1.3.1 ダイナミックリンクライブラリの形式と配置

  通常のライブラリは、コンパイラやアセンブラが出力したオブジェクトファイル(拡
張子がOBJ)が結合されたライブラリファイル(拡張子はLIB)となっています。一方、ダ
イナミックリンクライブラリは、オブジェクトファイルをリンカを通したREX形式のフ
ァイルとなっています(通例的に拡張子はDLL)。ダイナミックリンクマネージャは、こ
のREX形式のダイナミックリンクライブラリモジュールを、そのリロケーション情報に
よってメモリ上にロードします。
  Townsシステムソフトウェア V2.1ではムービーライブラリやアニメーションライブ
ラリ、JPEGライブラリ、拡張フォント管理ライブラリなどの標準提供のダイナミック
リンクライブラリは、システム起動ドライブの\DLLディレクトリにインストールされ
ています。ダイナミックリンクマネージャは、ダイナミックリンクライブラリを検索
するときにデフォルトでこのディレクトリを参照します。ただし、この検索順序はア
プリケーションから変更が可能です。

1.3.2 データ構造

  アプリケーションおよびダイナミックリンクライブラリモジュールは、ライブラリ
関数の相互参照のためのシンボル情報を保持するデータ構造がスタティックリンクさ
れています。これをリソースと呼びます。リソースには、外部から引用するライブラ
リ名とそのライブラリが含まれるモジュール名、および外部に対して参照されるライ
ブラリ名とそのアドレスのリストが含まれています。また、外部から引用するライブ
ラリへのエントリもリソースの中に存在していて、ダイナミックリンクライブラリの
アドレスはリンカによって、これらのエントリにアドレス解決されています。

       apl.exp
  ┌────────┐
  │main(){         │
  │      …        │
  │  afunc(a, b);─┼┐
  │      …        ││  スタティックリンク
  │}               ││  してあるライブラリ
  ├────────┤│  を呼び出す
  │afunc(x, y){  ←┼┘
  │      …        │
  │}               │
  └────────┘
    ▲従来のアプリケーション
  
        apl.exp 
  ┌────────┐
  │main(){         │
  │    …          │
  │ afunc(a, b); ─┼─┐
  │    …          │  │                     afile.dll
  │}               │  │              (REX形式の外部ﾌｧｲﾙ)
  ├────────┤  │              ┌────────┐
  │ リソースデータ │  │      ┌─┬→│ リソースデータ │
  ├────────┤  │      │  │  ├────────┤
  │afuncは         │←┘      │  │  │afuncは         │
  │ファイルafile   ├─┐      │  │  │ここにあるという│
  │にあるという情報│  │      │  │  │情報            │
  ├────────┤  │      │  │  ├────────┤
  │ﾀﾞｲﾅﾐｯｸﾘﾝｸﾏﾈｰｼﾞｬ│←┴───┘  └→│afunc(x, y){    │
  └────────┘                  │      …        │
                                        │}               │
                                        └────────┘
    ▲ダイナミックリンク機能対応のアプリケーション

2 ダイナミックリンクを利用した開発

2.1 ダイナミックリンクを利用するアプリケーションの作成

 ダイナミックリンクライブラリを利用するためには、以下の作業が必要となります。

  ･アプリケーションプログラムでダイナミックリンクマネージャの初期設定を行いま
   す。
  ･リソースを作成し、アプリケーションプログラムにスタティックリンクしておきま
   す。

  なお、Townsシェルアプリケーションからダイナミックリンクライブラリを利用する
方法については拡張ライブラリII｢GUIライブラリ V2.1ユーザーズガイド｣を参照して
ください。

2.1.1 ダイナミックリンクマネージャの初期設定

  ダイナミックリンクを利用するアプリケーションは、以下の2ステップをアプリケー
ションの初期処理中に加える必要があります。
    _XLD_init(0);
    _XLD_setMemFunc(malloc, free); 

  ただし、GUIライブラリを用いているアプリケーションは次のようになります。
    _XLD_setMemFunc(TL_malloc, TL_free); 

  呼び出すライブラリがダイナミックリンクライブラリであるかどうかをアプリケー
ションが意識する必要はありません。また、ダイナミックリンクマネージャが提供し
ている、この他のアプリケーションインタフェースについては、｢4.ダイナミックリ
ンクサポートライブラリ｣を参照してください。

2.1.2 リソースの準備

  ダイナミックリンクを利用するアプリケーションは、リソースと呼ばれるデータを
作成し、アプリケーション本体にスタティックリンクしておく必要があります。
  通常、リソースは拡張子".SDL"のリソースライブラリファイル(拡張子".LIB"と同じ
ファイル形式)の中に収録されており、それをリンク時にライブラリファイルとして指
定することでスタティックリンクを行います。またそれ以外に、独自に作成したライ
ブラリなどでは拡張子".RCO"のリソースオブジェクトファイル、もしくは拡張子".RDF
"のリソース定義ファイル(リソース変換ツールによってリソースオブジェクトファイ
ルへの変換作業が必要)として用意され、拡張子".OBJ"と同様にスタティックリンクし
ます。

2.2 ダイナミックリンクライブラリの作成

  ダイナミックリンクライブラリのコーディングのスタイルは、基本的には通常のラ
イブラリの作成方法と同じです。ただし、Townsシェルアプリケーション間でのコード
共有を行えるような構造にするためには、再入可能(リエントラント)なコーディング
を行わなくてはなりません。
  さらに、通常のライブラリが386LIBを用いてライブラリを作成するのに対して、
ダイナミックリンクライブラリはREX形式のEXPファイルを生成します。
  ダイナミックリンクライブラリも、アプリケーション本体と同様にリソースと呼ば
れるデータが必要です。リソース定義ファイルを作成しリソースオブジェクトファイ
ルを得てから、ダイナミックリンクライブラリ本体にスタティックリンクしておきま
す。
  また、ダイナミックリンクライブラリだけでなく、そのライブラリを呼び出すアプ
リケーション側に必要なリソース定義ファイルも作成し、リソースオブジェクトファ
イルに変換して用意しておく必要があります。リソースオブジェクトファイルはその
まま提供するか、または必要に応じて386LIBによりリソースライブラリファイルとし
てまとめます。

  すなわち、ダイナミックリンクライブラリとしては
   ･ダイナミックリンクライブラリ本体(拡張子".DLL")
   ･リソースファイル(2種類のうちどちらか片方)
     1)リソースオブジェクトファイル(拡張子".RCO")
     2)リソースライブラリファイル  (拡張子".SDL")
  の2つのファイルを作成することになります。

2.3 ダイナミックリンクを利用するアプリケーションの開発手順

  図EXL121R-014

  ダイナミックリンクを利用するアプリケーションは、通常の開発手順に加えて、リ
ソースと呼ばれるデータをスタティックリンクしておくことが必要です。リソースは
、アプリケーションが呼び出すダイナミックリンクライブラリに関するデータを含ん
でおり、この中でダイナミックリンクライブラリ関数とそれらが存在する外部のファ
イルとの関連付けが行われています。

2.4 ダイナミックリンクライブラリの開発手順

  図EXL121R-015

  ダイナミックリンクライブラリは、アプリケーションとは別に、ファイルとしてデ
ィスク上に存在し、ライブラリ本体(コードおよびデータ)にリソースをスタティック
リンクしたREXフォーマットとなっています。通常のスタティックリンクライブラリ
(一般に拡張子".LIB"を持つもの)が、複数のOBJファイルが結合されてLIB形式となっ
ているのに対して、ダイナミックリンクライブラリはひとつのOBJファイル(この中に
複数のライブラリ関数が存在する)にリソースを付加したREXファイルとなっています
(ただし、拡張子は通例として".DLL"とします)。
  ダイナミックリンクライブラリのリソースは、他のダイナミックリンクライブラリ
やアプリケーション本体のスタティックリンクライブラリを呼び出すための情報から
成っています。
  また、この他に、アプリケーション用にリソースを作成する必要があります。
  リソースはリソース変換を行っただけのリソースオブジェクトか、386LIBを介して
リソースライブラリとして作成します。

2.5 リソース定義ファイル

  ダイナミックリンクライブラリを開発する場合には、リソース定義ファイルを作成
します。

┌────────────────────────────────────┐
│EXTERN                            ─┐                                  │
│  Xfunc01    module01.dll           │■EXTERNブロック                  │
│  Xfunc02    module02.dll     (0)   │  外部からダイナミックリンクする関│
│  Xfunc03    module03.dll    (-1)   │  数名とモジュール名を列記します  │
│  Xfunc04    module04.dll (-1000)   │                                  │
│  sprintf    NUL                    │                                  │
│END                               ─┘                                  │
│                                                                        │
│PUBLIC                            ─┐                                  │
│  Pfunc01                           │■PUBLICブロック                  │
│  Pfunc02                           │  外部に公開する関数名のリスト    │
│  Pfunc03                           │                                  │
│  Pfunc04                           │                                  │
│END                               ─┘                                  │
└────────────────────────────────────┘
    ▲リソース定義ファイル例(ダイナミックリンクライブラリ用)

  EXTERNブロックは、アプリケーションが使用するダイナミックリンクライブラリ関
数とそれらが存在するモジュール名(ファイル名のみで、ディレクトリ指定は不可)、
およびダイナミックリンクの際にエラーが発生した時の関数戻り値の関連づけを定義
するものです。この例では、ダイナミックリンクライブラリからはライブラリ関数
Xfunc01、Xfunc02、Xfunc03、Xfunc04、sprintfを呼び出し(または、呼び出す可能性
があり)、これらのライブラリ関数のうち4つはそれぞれファイルmodule01.dll、
module02.dll、module03.dll、module04.dllにあることを示しています。
  また、モジュール名にNUL指定を行っているsprintf関数はアプリケーション本体に
あることを示します。この指定は、ダイナミックリンクライブラリのリソースにのみ
存在し(アプリケーション中には存在してはならない)ダイナミックリンクライブラリ
がアプリケーション本体のスタティックリンクライブラリ関数を呼び出すときに指定
されます。モジュール名のパス指定については次節で説明します。
  モジュール名の後にカッコで数値が指定されているものは、ダイナミックリンクラ
イブラリをロードしてダイナミックリンクエラーが発生し、強制終了されたときに、
ライブラリ関数の戻り値に格納する数値の指定です。ここに特定の値を入れることに
より、ダイナミックリンクエラーの発生を関数の戻り値だけで判断することが可能に
なります。ただし、詳しいエラーの内容はエラー情報取得関数(_XL_getError関数)を
利用しなければ取得できません。
  PUBLICブロックは、ダイナミックリンクライブラリ内に存在する関数のうち外部か
ら呼び出される関数の宣言を行います。上の例では、Pfunc01、Pfunc02、Pfunc03、
Pfunc04がダイナミックリンクライブラリ内に存在し、これらの関数が外部(アプリケ
ーションや他のダイナミックリンクライブラリ)から呼び出されることがあることを示
します。アプリケーション用のリソースの場合は、ダイナミックリンクライブラリか
らモジュール名をNULと指定して呼び出される関数をここに記述します。
  リソース定義ファイルはリソース変換ツールによって.OBJファイルのフォーマット
に変換され、リンカ(386LINKまたはTLINK)によってアプリケーションに統合されます
。リソース定義ファイルは1つのアプリケーションについて複数のファイルでの結合が
可能ですので、たとえばムービー、アニメ、JPEG、フォント管理のうち複数の機能を
用いる場合には、それぞれに提供されているリソース(オブジェクト形式またはライブ
ラリ形式)をスタティックリンクする必要があります。

2.6 ダイナミックリンクライブラリのディレクトリ

  ダイナミックリンクマネージャは、以下に述べる規約によりダイナミックリンクラ
イブラリを検索するディレクトリパスを決めます。

  デフォルトでは、ダイナミックリンクマネージャはリソースで指定されているモジ
ュールを起動ドライブの\DLLディレクトリ内で検索します。システムで標準に提供さ
れるダイナミックリンクライブラリはすべてこのディレクトリに存在します。
  あるアプリケーションのみで利用するダイナミックリンクライブラリは、原則とし
てアプリケーションのディレクトリ下などに配置します。このために、アプリケーシ
ョンが独自にダイナミックリンクライブラリのディレクトリ検索パスを決めることが
できます。ディレクトリ検索パスの設定は以下のようになります。
    _XLD_setLinkPath("Q:\FOO\BAR");

  この例では、この指定以降、アプリケーションから呼び出すダイナミックリンクラ
イブラリは、まず"Q:\FOO\BAR"中で検索されます。"Q:\FOO\BAR"に指定のダイナミッ
クリンクライブラリが存在しない場合には、次にシステムデフォルトのデフォルトで
ある起動ドライブの\DLLディレクトリを検索します。

2.7 ダイナミックリンクライブラリの属性

  ダイナミックリンクライブラリは、ダイナミックリンクマネージャの動作を制御す
る属性を持ちます。属性はリソースの中にあり、リソース定義ファイルからリソース
オブジェクトファイルを生成するときにリソース変換ツールに指定するオプションに
よって決定されます。
  ただ、リソースオブジェクトファイル自身は複数個リンクすることが可能になって
いるので、それら複数個あるうちの一番初めにリンクされたリソース内の属性がその
ダイナミックリンクライブラリの属性となります。他のリソースに属性が設定されて
いてもすべて無効です。

  現バージョンでは以下の3種の属性をサポートしています。

【ロック】
    ロック属性は、ダイナミックリンクライブラリがメモリ上にロードされた直後か
  らロックされた状態にする属性です。この属性を設定しておくことにより、アプリ
  ケーションやシステムなどによって安易にダイナミックリンクライブラリを開放さ
  れる事態を防ぐことができます。
    この属性が設定されていない場合には、ロックはアプリケーション等が明示的に
  ロックさせる関数(_XLD_lockLib関数)を使用しない限りロックされません。
    また、この属性によってロックされたダイナミックリンクライブラリは、関数に
  よってロックを解除することができないため、アプリケーションが終了するまで開
  放させることができませんので、扱いには注意してください。

【コード共有】
    コード共有属性は、Townsシェルアプリケーションから使用されるときにダイナミ
  ックリンクライブラリが複数のアプリケーション間で共有可能であるという属性で
  す。Townsシェル上でなければ複数のアプリケーションが動作することはないため、
  この属性は無視されます。
    ダイナミックリンクライブラリを使用する際に、この属性を持ったライブラリを
  すでに他のアプリケーションがロードしていたならば、そのロード済みのライブラ
  リを使用します。このようにすることで、同じダイナミックリンクライブラリを複
  数個読み込んでメモリを無駄に消費することがなくなります。
    ただし、この属性を持ったダイナミックリンクライブラリは、必ずコードを共有
  することが可能な構造(リエントラント)になっていなくてはなりません。コード部
  分のみならずライブラリ内部の静的変数も含めて共有されるため、複数のアプリケ
  ーションが同じ共有されたライブラリを呼んだときに変数の内容に不都合が起きる
  可能性があります。

【コード占有】
    コード占有属性はコード共有属性と対になるもので、ダイナミックリンクライブ
  ラリがコード共有不可能であり、呼び出したTownsシェルアプリケーションによって
  占有されることを示す属性です。この属性もまた、Townsシェル上でなければ無視さ
  れます。
    ダイナミックリンクライブラリをロードする際に、あるTownsシェルアプリケーシ
  ョンが同じライブラリを使用中であっても、新たにメモリ上に読み込んでダイナミ
  ックリンクします。そのため、スタティックリンクライブラリのようにアプリケー
  ションごとにダイナミックリンクライブラリがロードされ、リンクされることにな
  ります。
    TownsOS V2.1 L20で提供されたダイナミックリンクライブラリや拡張ライブラリI
  V2.1 L20によって作成されたダイナミックリンクライブラリ、及びライブラリ作成
  時にコード共有属性を設定しなかったダイナミックリンクライブラリは、コード占
  有属性を持っているものとみなされます。

2.8 リソース変換ツール

  リソース変換ツールは、リソース定義ファイルを入力ファイルとして、リンカによ
ってリンクするためのオブジェクトファイルを生成します。リソース変換ツールの使
用法は以下のとおりです。
┌────────────────────────────────────┐
│DLRC   <オプション>  [リソース定義ファイル名]                           │
│                                                                        │
│        オプション :-OBJ <ｵﾌﾞｼﾞｪｸﾄﾌｧｲﾙ名>   オブジェクトファイル名を指定│
│                                                                        │
│                    -LOCK                 ロック属性を設定              │
│                                                                        │
│                    -COMMON               コード共有属性を設定          │
│                                                                        │
│                    -SHARE                コード占有属性を設定          │
└────────────────────────────────────┘
  リソース定義ファイルは一般的なテキストファイルですが、デフォルトの拡張子は
通例として".RDF(Resource Definition File)"とします。また、生成されるオブジェ
クトファイルは、拡張子".OBJ"を持つ通常のオブジェクトファイルと同等のフォーマ
ット(Easy OMF-386)です。ただし、通常のプログラムのオブジェクトファイルと区別
するために、リソース変換ツールではデフォルトの拡張子を".RCO(Resource Object)"
としています。
  リソースオブジェクトファイルには任意の属性を書き込むことができます。ダイナ
ミックリンクライブラリに組み込むリソースを変換する際に属性を書き込み、そのリ
ソースオブジェクトファイルをリンクすることにより、ダイナミックリンクライブラ
リに対して属性を設定することができます。

  -OBJオプションはリソースオブジェクトファイル名を変更するオプションです。
  オプションによる指定がない場合はリソース定義ファイルの拡張子を".RCO"に置き
換えたファイル名になり、出力先ディレクトリはカレントディレクトリになりますが
、このオプションを使用することにより任意のディレクトリに任意のファイル名で出
力できます。

【例】
  DLRC -OBJ ..\OBJ APL.RDF
  DLRC -OBJ F:\APL\OBJ\APL.RCO APL.RDF

  -LOCKオプションは、ロック属性をリソースオブジェクトファイルに書き込むオプシ
ョンです。
  このオプションを指定して作成したリソースをダイナミックリンクライブラリにリ
ンクすることにより、アプリケーションやシステムなどによって安易にダイナミック
リンクライブラリを開放される事態を防ぐことができます(属性を設定したリソースを
他のリソースよりも先にリンクさせることが必要です)。
  このオプションを指定しなかった場合には、ロック属性は設定されません。

【例】
  DLRC -LOCK MODULEA.RDF

  -COMMONオプションは、コード共有属性をリソースオブジェクトファイルに書き込む
オプションです。
  このオプションを指定して作成されたリソースオブジェクトファイルをダイナミッ
クリンクライブラリに組み込んであれば、そのライブラリが複数のアプリケーション
から呼ばれた際にロード済みのライブラリを共有するようになります(属性を設定した
リソースを他のリソースよりも先にリンクさせることが必要です)。
  なお、このオプションを指定したリソースを組み込むダイナミックリンクライブラ
リは、必ずコード共有を行えるような構造になっていなくてはなりません。

【例】
  DLRC -COMMON MODULEA.RDF

  -SHAREオプションは-COMMONオプションと対になるもので、コード占有属性を書き込
むオプションです。
  このオプションを指定して作成されたリソースオブジェクトファイルをダイナミッ
クリンクライブラリに組み込んであれば、他のアプリケーションがすでにロード済み
であっても新たにメモリ上に読み込んでダイナミックリンクを行います(属性を設定し
たリソースを他のリソースよりも先にリンクさせることが必要です)。その結果スタテ
ィックリンクライブラリのように、アプリケーションごとに同一のライブラリがリン
クされることになります。
  TownsOS V2.1 L20で提供されたダイナミックリンクライブラリ、及び拡張ライブラ
リI V2.1 L20によって作成されたダイナミックリンクライブラリは、-SHAREオプショ
ンが指定されたものとみなされて動作します。また、特にオプション指定がない場合
にもこのオプションが指定されたものとして扱われます。

【例】
  DLRC -SHARE MODULEA.RDF 

2.9 複数のリソースの扱い

  リソースはアプリケーション及びダイナミックリンクライブラリに1つ以上リンクさ
せることができます。複数のダイナミックリンクライブラリを利用するためには、2通
りの方法があります。

  1つは、すでに変換済みのリソースオブジェクトファイルを必要なライブラリの分だ
けリンクするという方法です。オブジェクトファイル形式になった状態のまま扱うの
で自分で定義を書き換えることはできませんが、リソース定義ファイルを変更する必
要はありません。

  リソースオブジェクトファイル自身は通常のオブジェクトファイル形式であるため
、ライブラリアン(386LIB)によってライブラリファイルにまとめることもできます。
ただしリンカの仕様から、externブロックの定義がなくpublicブロックのみを持つリ
ソースをリソースライブラリファイルに入れた場合には、そのリソースはスタティッ
クリンクされませんので注意してください。リソースをライブラリファイルとしてま
とめる場合には拡張子".SDL"を使用します。

  もう1つは、リソース定義ファイル1つに全てのダイナミックリンクライブラリ呼び
出しの記述をまとめ、1つのリソースオブジェクトファイルを作成してリンクする方法
です。これは変換前のリソース定義ファイルが存在している場合でのみ利用すること
ができます。どのダイナミックリンクライブラリを使用しているかが把握でき、また
無駄なリソースを省いてサイズを縮小できる反面、ライブラリがバージョンアップす
るときには、それにあわせてリソース定義ファイルを変更しなくてはなりません。

2.10 開発手順例

  ダイナミックリンクを利用するアプリケーションの開発手順の具体例を示します。
  例としてファイル構成を以下に示します。

 ･アプリケーション本体のソースファイル  ……  main.c, sub1.c, sub2.c
 ･リソース定義ファイル  …………………………  apl.rdf 
 ･アプリケーションファイル名  …………………  apl.exp 
 ･ダイナミックリンクライブラリ
                    モジュール名  ……………  moduleA.dll, moduleB.dll

                    ▲ファイル構成

  アプリケーション本体とダイナミックリンクライブラリモジュールの間での関数の
呼び出しは以下のように行われているとします。

  図EXL121R-016

  ▲アプリケーションとダイナミックリンクライブラリの呼び出し関係図

アプリケーション本体のリソース定義ファイル(apl.rdf)は次のようになります。

extern
  func1   moduleA.dll …  func1がmoduleA.dllに存在する(前頁図 1の関連づけ)
  func2   moduleA.dll …  func2がmoduleA.dllに存在する(前頁図 2の関連づけ)
  func3   moduleB.dll …  func3がmoduleB.dllに存在する(前頁図 3の関連づけ)
end 
public
  fopen   ………  fopenが他のモジュールから参照される(前頁図 4の関連づけ)
  fread   ………  freadが他のモジュールから参照される(前頁図 5の関連づけ)
  fclose  ………  fcloseが他のモジュールから参照される(前頁図 6の関連づけ)
  scanf   ………  scanfが他のモジュールから参照される(前頁図 8の関連づけ)
  printf  ………  printfが他のモジュールから参照される(前頁図 9の関連づけ)
end 
            ▲apl.rdf :アプリケーションのリソース定義ファイル

アプリケーション本体(apl.exp)の開発手順は以下に示します。

  図EXL121R-017

  また、ダイナミックリンクサポートライブラリ(moduleA.dllとmoduleB.dll)は以下
のようになります。

extern
  fopen   NUL ……………  fopenがアプリ本体に存在する(前頁図 4の関連づけ)
  fread   NUL ……………  freadがアプリ本体に存在する(前頁図 5の関連づけ)
  fclose  NUL ……………  fcloseがアプリ本体に存在する(前頁図 6の関連づけ)
  func4   moduleB.dll …  func4がmoduleB.dllに存在する(前頁図 7の関連づけ)
end 
public
  func1 …………  func1が他のモジュールから参照される(前頁図 1の関連づけ)
  func2 …………  func2が他のモジュールから参照される(前頁図 2の関連づけ)
end 
        ▲moduleA.rdf :ダイナミックリンクライブラリのリソース定義ファイル

extern
  scanf   NUL …………  scanfがアプリ本体に存在する(前々頁図 8の関連づけ)
  printf  NUL …………  printfがアプリ本体に存在する(前々頁図 9の関連づけ)
end 
public
  func3 …………  func3が他のモジュールから参照される(前々頁図 3の関連づけ)
  func4 …………  func4が他のモジュールから参照される(前々頁図 7の関連づけ)
end 
        ▲moduleB.rdf :ダイナミンクリンクライブラリのリソース定義ファイル

  ダイナミックリンクライブラリ(moduleA.dllとmoduleB.dll)の開発手順は以下に示
します。

  図EXL121R-018

3 ダイナミックリンクのメカニズム

3.1 ダイナミックリンクのしかけ

  実際にダイナミックリンクがどのように行われるかを解説します。

 (1)アプリケーションからダイナミックリンクライブラリの呼び出し
    アプリケーションがダイナミックリンクライブラリAを呼び出すと、あらかじめス
    タティックリンクされているリソース内のエントリAに制御が移ります。

                アプリケーション
          ┌────────────┐
          │  アプリケーション本体  │
          │┌──────────┐│
    ┌──┼┤ call A             ││
    │    │└──────────┘│
    │    ├────────────┤
    │    │  リソース              │
    │    │┌──────────┐│
    └──→│A:                  ││
          │└──────────┘│
          └────────────┘

 (2)ダイナミックリンクマネージャの呼び出し
    リソースの内部データ構造から、ダイナミックリンクライブラリAは外部ファイル
    Xに含まれていることが認識され、引き続いてダイナミックリンクマネージャに制
    御が移ります。

            アプリケーション
        ┌────────────┐
        │  アプリケーション本体  │
        │                        │
        ├────────────┤
        │  リソース              │
        │┌──────────┐│
        ││A:  A ∈ X          ││
        │└────┬─────┘│
        └─────┼──────┘
                    ↓
    ┌────────────────┐
    │  ダイナミックリンクマネージャ  │
    └────────────────┘

 (3)ライブラリ領域の割り当て
    あらかじめ登録してあるアプリケーションのメモリ取得関数を呼び出し、ダイナ
    ミックリンクライブラリのための領域を確保します。
    ダイナミックリンクはモジュール(ファイル)単位で行われます。

                     アプリケーション
                 ┌────────────┐
                 │  アプリケーション本体  │
                 │┌──────────┐│
     ┌─────→│malloc:             ├┼─┐
     │          │└──────────┘│  │(2)割り当て
     │    80000H│┌──────────┐│  │
     │          ││  メモリブロック    │←─┘
     │          ││                    ││
     │          │└──────────┘│
     │          └────────────┘
     │        ┌──────────────┐
     │        │ダイナミックリンクマネージャ│
     │        │  ┌──────────┐  │
     └────┼─┤    メモリ取得      │  │
    (1)呼び出し│  │                    │  │
               │  └──────────┘  │
               └──────────────┘

 (4)ダイナミックリンクライブラリのロード/再配置
    メモリを確保したあと、ダイナミックリンクライブラリモジュールXをロードし、
    必要なアドレスの解決(再配置)を行います。

              アプリケーション
          ┌────────────┐
          │  アプリケーション本体  │
          │┌──────────┐│        ダイナミックリンク
          ││malloc:             ││
          │└──────────┘│          ライブラリモジュール
    80000H│┌──────────┐│      ┌────────────┐
          ││  メモリブロック    ││ロード│  ライブラリ本体        │
          ││                    │←───┼────────────┤
          │└──────────┘│再配置│  リソース              │
          └────────────┘      └────────────┘
        ┌──────────────┐
        │ダイナミックリンクマネージャ│
        │  ┌──────────┐  │
        │  │  ロード/再配置     │  │
        │  │                    │  │
        │  └──────────┘  │
        └──────────────┘

 (5)ダイナミックリンクライブラリのリンク
    ダイナミックリンクライブラリモジュールのロードが正常に行われたあと、アプ
    リケーションとダイナミックリンクライブラリとの間の相互参照のためのアドレ
    ス解決(リンク)を行います。以下のアドレスがリンク対象となります。
     ･アプリケーションが参照する、ダイナミックリンクライブラリモジュールX内
      のライブラリのアドレス(次図:アドレス解決(1))。
     ･ダイナミックリンクライブラリモジュールXから参照する、アプリケーション
      内のライブラリのアドレス(次図:アドレス解決(2))。

    図EXL121R-019

 (6)ライブラリの呼び出し
    ライブラリ領域にロードしたライブラリAを呼び出します。このとき、ライブラリ
    領域はコードセグメントとしてマッピングされている必要があります。

                  アプリケーション
            ┌────────────┐
            │  アプリケーション本体  │
            │                        │
      80000H│┌──────────┐│
    ┌───→│A:  実体            ││
    │      │└──────────┘│
    │      ├────────────┤
    │      │  リソース              │
    │      │                        │
    │      └────────────┘
    │    ┌──────────────┐
    │    │ダイナミックリンクマネージャ│
    │    │  ┌──────────┐  │
    └──┼─┤ ライブラリ呼び出し │  │
          │  └──────────┘  │
          └──────────────┘

3.2 メモリ管理

3.2.1 ライブラリ領域の取得

  ダイナミックリンクマネージャはライブラリ領域の確保/開放に際して、あらかじめ
アプリケーションが登録していたメモリ確保/開放の関数のエントリを呼び出します。
このため、ライブラリ領域はアプリケーションヒープ中に確保することになります。
ライブラリ領域のハンドルまたはポインタはダイナミックリンクマネージャが保持し
、原則的にアプリケーション側からは知ることができません。このため、アプリケー
ションがライブラリ領域を開放するときには、ダイナミックリンクマネージャを経由
してライブラリ領域を開放することになります。また、ヒープ領域に対してはあらか
じめコードセレクタがエイリアスとして必要です。

  図EXL121R-020

3.2.2 ダイナミックリンクライブラリのロック

  ダイナミックリンクライブラリ領域の開放によって、ダイナミックリンクライブラ
リが保持している必要なデータ(スタティックデータ)の消失を防ぐため、ダイナミッ
クリンクライブラリをメモリ上にロックする機能を提供します。
  たとえば、以下のようなダイナミックリンクライブラリを考えます。
┌───────────────────────────────┐
│  static FILE handle = 0;                                     │
│                                                              │
│                                                              │
│  void  init(){ handle = fopen("afile", "rw"); }              │
│                                                              │
│  void  end() { fclose(handle); }                             │
└───────────────────────────────┘
  この例では、init関数の実行によって設定されたhandle変数は、end関数が実行さ
れるまでデータを保持している必要があり、メモリ上にロックしておく必要がありま
す。

  次の事項に該当するダイナミックリンクライブラリはロックするべきです。
  ･モジュール内で、モジュール内のグローバル変数を共用するような場合
  ･割り込みハンドラ

3.3 ダイナミックリンクライブラリのローディング

  ダイナミックリンクライブラリのローディングはモジュール単位で行われます。こ
のため、ひとつのモジュールに複数のライブラリ関数が含まれている場合には、その
中のいずれかの関数が呼び出されたときに、モジュールが一括してロードされます。
そこで、初期化関数が提供されているようなダイナミックリンクライブラリは、この
初期化関数が呼び出されたときにダイナミックリンクライブラリがメモリ上にロード
されます。

- 例 -

  アプリケーション                           ダイナミックリンクライブラリ
  ┌────────────────┐
  │                                │               (MVS.DLL)
  │  main(){                       │      ┌─────────────┐
  │                                │ロード│┌───────────┐│
  │   MVS_InitCompMovie(...);    ←┼─┬─┼┤MVS_InitCompMovie     ││
  │  ┌─────────────┐│  │  │├───────────┤│
  │  │この時点で、              ││  ├─┼┤MVS_PutMovieFileInfo  ││
  │  │ﾀﾞｲﾅﾐｯｸﾘﾝｸﾗｲﾌﾞﾗﾘ          ││  │  │├───────────┤│
  │  │がロードされている        ││  └─┼┤MVS_CompMovieFile     ││
  │  └─────────────┘│      │├───────────┤│
  │              …                │      ││          …          ││
  │   MVS_PutMovieFileInfo(...);   │      │└───────────┘│
  │  ┌─────────────┐│      └─────────────┘
  │  │すでにメモリ上にあるﾗｲﾌﾞﾗﾘ││
  │  │                          ││
  │  │関数が呼び出される        ││
  │  └─────────────┘│
  │              …                │
  │  }                             │
  └────────────────┘

3.4 ダイナミックリンクライブラリモジュールの構造

  ダイナミックリンクライブラリモジュールは、複数のライブラリコードとデータと
リソースデータから構成されるREX形式のファイルであり、ファイル本体(REXヘッダを
除いた部分)のフォーマットは以下のとおりです。

  ┌──────────────┐
  │  DLLヘッダ                 │
  ├──────────────┤
  │  リソース                  │
  ├──────────────┤
  │  ライブラリコード/データ   │
  │                            │
  └──────────────┘
    ▲ダイナミックリンクライブラリモジュールの構造

  DLLヘッダはダイナミックリンクライブラリの版数を示すデータです。現バージョン
のダイナミックリンクマネージャはこの領域を利用していませんが、今後のアプリケ
ーションやインストーラによるダイナミックリンクライブラリの版数チェックの便宜
を図るため、規定しておきます。すべてのダイナミックリンクライブラリモジュール
は、DLLヘッダを、その先頭に埋め込んでおくことを推奨します。
  DLLヘッダは16バイトで、文字列DLL0から始まり以下の構造を持ちます。

 0             3  4    5  6    7  8           11 12             15
┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│44  4C  4C  30│  │  │  │  │00│00│00│00│00│00│00│00│値は16進数
└───────┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
    "DLL0"          ↑      ↑          ↑              ↑
                    │      │          │              └─システムリザーブ
                    │      │          │
                    │      │          └─────────ユーザ用リザーブ
                    │      └──メジャーバージョン
                    │
                    └──────マイナーバージョン

  メジャーバージョンおよびマイナーバージョンは、ダイナミックリンクライブラリ
が固有に決定する内容です。ただし、それぞれ2バイト単位、または合わせて4バイト
で読み出して、値が大きいほど版数が新しいこととします。ユーザ用リザーブは、各
ダイナミックリンクライブラリ開発者が個々に利用できる4バイトの領域です。
  システムリザーブはシステムのために利用するものとして将来用に予約しておく領
域です。ユーザ用リザーブ、システムリザーブともに初期値は0としておきます。

  リソースとライブラリコード/データの順序は任意ですが、現バージョンではダイナ
ミックリンク時に、ダイナミックリンクマネージャはリソースをモジュール先頭から
検索します。

  ダイナミックリンクライブラリモジュールにはスタック領域は含まれません。モジ
ュール作成時にリンカに対して、STACKオプションを指定する必要はありません。

3.5 ダイナミックリンクの注意事項

3.5.1 データの扱い

  ダイナミックリンクライブラリ関数が参照できるデータは、その関数が属するモジ
ュール内で定義している局所変数とスタティック変数に限ります。
  外部にあるグローバル変数を直接参照することはできません。
  ┌─────────────────────┐
  │  /*  ダイナミックリンクライブラリ    */  │
  │  static int flag = 0;        /*  OK  */  │
  │                                          │
  │  open()  { flag = 1;}      /*  OK  */    │
  │  close() { flag = 0;}      /*  OK  */    │
  └─────────────────────┘
    ▲スタティック変数の参照

──────────────────────────────────────
  ┌─────────────────┐┌────────────────┐
  │  extern int global;              ││  int global;                   │
  │                                  ││      …                        │
  │  funcNG(){ global = 1;}          ││      …                        │
  └─────────────────┘└────────────────┘
      ダイナミックリンクライブラリ                  アプリケーション
──────────────────────────────────────
    ▲外部グローバルデータの参照【誤】

──────────────────────────────────────
  ┌─────────────────┐┌────────────────┐
  │  extern void setGlobal(int n);   ││  int global;                   │
  │                                  ││                                │
  │                                  ││                                │
  │  /* 外部グローバルの参照    */   ││  void setGlobal(int n) {       │
  │                                  ││                                │
  │  funcOK(){  setGlobal(1);   }    ││     global = n;                │
  │                                  ││  }                             │
  ├─────────────────┤├────────────────┤
  │  リソース                        ││  リソース                      │
  │                                  ││                                │
  │  EXTERN  setGlobal               ││  PUBLIC  setGlobal             │
  └─────────────────┘└────────────────┘
      ダイナミックリンクライブラリ                  アプリケーション
──────────────────────────────────────
    ▲外部グローバルデータの参照【正】

3.5.2 エラー情報

  _XLD_getError関数によって、ダイナミックリンクマネージャの実行中に発生したエ
ラー情報を取得することができます。ダイナミックリンクライブラリやダイナミック
リンクサポートライブラリを使用するときには必ずエラー情報を取得し、それに応じ
た処理を行うことが必要です。特に、ダイナミックリンクライブラリ実行中にエラー
が発生した場合は、そのダイナミックリンクライブラリの結果が不当であるため、エ
ラーを無視して処理を続行すると障害が発生することがあります。

┌────────────┬───────────────────────┐
│            値          │              エラー内容                      │
├────────────┼───────────────────────┤
│_XLD_ERR_OPENLIB     -1 │ダイナミックリンクライブラリモジュール(ファイ │
│                        │ル)が存在しないか、または読み込むことができな │
│                        │い                                            │
├────────────┼───────────────────────┤
│_XLD_ERR_MALLOC      -2 │ダイナミックリンクライブラリに割り当てるメモリ│
│                        │が確保できない                                │
├────────────┼───────────────────────┤
│_XLD_ERR_LOADLIB     -3 │ダイナミックリンクライブラリがロードできない  │
├────────────┼───────────────────────┤
│_XLD_ERR_NOEXTRSC    -4 │ダイナミックリンクライブラリモジュールに      │
│                        │リソースが存在しない                          │
├────────────┼───────────────────────┤
│_XLD_ERR_NOLIB       -5 │指定のダイナミックリンクライブラリが存在しない│
├────────────┼───────────────────────┤
│_XLD_ERR_LOCKED      -6 │指定のダイナミックリンクライブラリはロック    │
│                        │されている                                    │
├────────────┼───────────────────────┤
│_XLD_ERR_FREEMEM     -7 │メモリを開放することができない                │
├────────────┼───────────────────────┤
│_XLD_ERR_TOOLONGPATH -8 │パス名が長すぎる                              │
├────────────┼───────────────────────┤
│_XLD_ERR_NOLIBINMAIN -9 │指定のライブラリがアプリケーション側に存在しな│
│                        │い                                            │
├────────────┼───────────────────────┤
│_XLD_ERR_FREELIB    -10 │指定のライブラリの占有していたメモリが開放でき│
│                        │ない                                          │
├────────────┼───────────────────────┤
│_XLD_ERR_NOTLINKED  -11 │指定のライブラリはメモリ上にない              │
├────────────┼───────────────────────┤
│_XLD_ERR_ILLPARM    -12 │不法なパラメータ(ポインタなど)が指定されてい  │
│                        │る                                            │
├────────────┼───────────────────────┤
│_XLD_ERR_NOHEADER   -13 │指定のライブラリにDLLヘッダが存在しない       │
└────────────┴───────────────────────┘

4 ダイナミックリンクサポートライブラリ

4.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│_XLD_init                 │ダイナミックリンク機能の初期設定          │
├─────────────┼─────────────────────┤
│_XLD_setMemFunc           │メモリ割り当て/開放関数の登録             │
├─────────────┼─────────────────────┤
│_XLD_callMalloc           │メモリ割り当て関数の呼び出し              │
├─────────────┼─────────────────────┤
│_XLD_callFree             │メモリ開放関数の呼び出し                  │
├─────────────┼─────────────────────┤
│_XLD_setLinkPath          │ダイナミックリンクパスの指定              │
├─────────────┼─────────────────────┤
│_XLD_getLinkPath          │ダイナミックリンクパスの取得              │
├─────────────┼─────────────────────┤
│_XLD_getLinkPath2         │ダイナミックリンクパスの取得2             │
├─────────────┼─────────────────────┤
│_XLD_unlink               │ライブラリの開放                          │
├─────────────┼─────────────────────┤
│_XLD_load                 │ライブラリのロード                        │
├─────────────┼─────────────────────┤
│_XLD_isLinked             │ライブラリのロード状態の検査              │
├─────────────┼─────────────────────┤
│_XLD_lockLib              │ライブラリのロック設定                    │
├─────────────┼─────────────────────┤
│_XLD_unlockLib            │ライブラリのロック解除                    │
├─────────────┼─────────────────────┤
│_XLD_getError             │実行時エラー情報の取得                    │
├─────────────┼─────────────────────┤
│_XLD_clearError           │実行時エラー情報の初期化                  │
├─────────────┼─────────────────────┤
│_XLD_setError             │実行時エラー情報の設定                    │
├─────────────┼─────────────────────┤
│_XLD_setErrorFunc         │ライブラリロード時エラーハンドラの登録    │
├─────────────┼─────────────────────┤
│_XLD_getErrorFunc         │ライブラリロード時エラーハンドラの取得    │
├─────────────┼─────────────────────┤
│_XLD_getLibHeader         │DLLヘッダ情報の取得                       │
└─────────────┴─────────────────────┘

4.2 各関数の解説

-----------------------------------------------------------------------------
._XLD_callFree
メモリ開放関数の呼び出し
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
void    _XLD_callFree(void *ptr);
void    *ptr;   /* 開放するメモリへのポインタ */

- 内容 -
_XLD_setMemFunc関数によってあらかじめ登録してあるアプリケーションのメモリ開放
関数を直接呼び出します。この関数はダイナミックリンクライブラリ側から取得した
アプリケーションメモリの開放を行う場合に使用されます。

- 参照 -
_XLD_callMalloc関数
_XLD_setMemFunc関数

-----------------------------------------------------------------------------
._XLD_callMalloc
メモリ割り当て関数の呼び出し
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
void    *_XLD_callMalloc(size_t size);
size_t  size;   /* 取得するメモリサイズ */

- 内容 -
_XLD_setMemFunc関数によってあらかじめ登録してあるアプリケーションのメモリ割り
当て関数を直接呼び出します。この関数はダイナミックリンクライブラリ側から、メ
モリの取得を行う場合に使用されます。

- 参照 -
_XLD_callFree関数
_XLD_setMemFunc関数

-----------------------------------------------------------------------------
._XLD_clearError
実行時エラー情報の初期化
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
void    _XLD_clearError(void); 

- 内容 -
現在設定されている画面退避領域のアドレスを取得します。
ダイナミックリンクマネージャが設定したアプリケーションエラー情報を初期化しま
す。この関数を実行後、_XLD_getError関数にてエラー情報を取得しようとしても、
再びダイナミックリンクライブラリのエラーが発生するまで0(エラーなし)が返るよう
になります。
  ダイナミックリンクライブラリ内で他のダイナミックリンクライブラリの関数を呼
び出した時にエラーが発生した場合、通常はアプリケーションに処理が戻るまでエラ
ー情報が保存されますが、ダイナミックリンクライブラリ内でエラー対策を施してか
ら処理を戻す場合には、この関数で初期化してアプリケーションにエラー情報を告知
しないようにする必要があります。
  同様のことを行うのに_XLD_setError関数を利用する方法もありますが、明示的にエ
ラー情報を初期化するためにこちらを使用するようにしてください。

- 参照 -
_XLD_getError関数
_XLD_setError関数

-----------------------------------------------------------------------------
._XLD_getError
実行時エラー情報の取得
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
int  _XLD_getError(void); 

- 戻り値 -
ダイナミックリンクマネージャが設定するアプリケーションエラー情報を返します。
エラーが発生しなかった場合には0を返します。

- 内容 -
ダイナミックリンクマネージャの実行中に発生したエラー情報を取得します。この関
数がエラーを返した場合は、たとえば指定のダイナミックリンクライブラリが存在し
なかったり、ライブラリのためのメモリが確保できず、直前に呼び出されたライブラ
リが正常に実行できなかったことを示します。ダイナミックリンクライブラリを呼び
出した直後には、この関数によってエラー情報を調べ、エラーが発生していた場合に
はアプリケーションが適切な処理を行う必要があります。エラー情報については｢3.5
ダイナミックリンクの注意事項 3.5.2 エラー情報｣を参照してください。

- 参照 -
_XLD_clearError関数
_XLD_setError関数

-----------------------------------------------------------------------------
._XLD_getErrorFunc
ライブラリロード時エラーハンドラの取得
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
int (*_XLD_getErrorFunc(void))();

- 戻り値 -
登録済のエラーハンドラへのポインタを返します。エラーハンドラが未登録の場合に
は、-1を返します。

- 内容 -
現在登録されている、ダイナミックリンクライブラリロード時のエラーを検知する関
数(エラーハンドラ)を取得します。
-1が返された場合には、エラーハンドラが未登録であることを示します。

- 参照 -
_XLD_setErrorFunc 関数

-----------------------------------------------------------------------------
._XLD_getLinkPath 
ダイナミックリンクパスの取得
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
char *_XLD_getLinkPath(char *s); 
char *s;    /* リンクパスを取得する領域へのポインタ */

- 戻り値 -
ダイナミックリンクパスを取得した領域のポインタです。引数sに一致します。

- 内容 -
現在設定されているダイナミックリンクライブラリを検索するパス(ダイナミックリン
クパス)を取得します。ダイナミックリンクパスは、_XLD_setLinkPath 関数で設定し
たパスとシステムのデフォルトの検索パスから構成され、各パスが";"記号で区切られ
ています。たとえば、この関数によって文字列"e:\my_path;d:\dll;"が得られた場合
、ダイナミックリンクマネージャはダイナミックリンクライブラリモジュールを検索
するために、まず最初にディレクトリ"e:\my_path"を検索し、このディレクトリに該
当するダイナミックリンクモジュールが存在しなければ次に"d:\dll"ディレクトリ内
を検索することを示します。このうち、"e:\my_path"は_XLD_setLinkPath関数によっ
て設定されたパス名であり、"d:\dll"はシステムのデフォルトの検索パスです。
引数sの指し示す領域には、パス名を取得するのに充分なサイズを確保しておく必要が
あります。

- 参照 -
_XLD_setLinkPath 関数
_XLD_getLinkPath2関数

-----------------------------------------------------------------------------
._XLD_getLinkPath2
ダイナミックリンクパスの取得2
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
char   *_XLD_getLinkPath2(char *s);
char   *s;        /*  リンクパスを取得する領域へのポインタ  */

- 戻り値 -
ダイナミックリンクパスを取得した領域のポインタです。引数sに一致します。

- 内容 -
現在設定されているダイナミックリンクライブラリを検索するパス(ダイナミックリン
クパス)を取得します。_XLD_getLinkPath関数とは異なり、この関数で取得できるパス
は_XLD_setLinkPath関数によって設定されたパスのみになります。システムのデフォ
ルトの検索パスはこの関数で得ることができません。この関数と_XLD_setLinkPath関
数を併用することにより、アプリケーションやライブラリ中でダイナミックリンクパ
スの退避や復元などを行うことができます。引数sの指し示す領域には、パス名を取得
するのに充分なサイズを確保しておく必要があります。

- 参照 -
_XLD_setLinkPath関数
_XLD_getLinkPath関数

-----------------------------------------------------------------------------
._XLD_getLibHeader
DLLヘッダ情報の取得
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
int   _XLD_getLibHeader(char *moduleName, stLibHeader *libHeader); 
char        *moduleName;  /*  モジュール名  */
stLibHeader *libHeader;   /*  DLLﾍｯﾀﾞ情報を取得する領域へのﾎﾟｲﾝﾀ  */

- 戻り値 -
DLLヘッダを取得した場合には、NULLを返します。
DLLヘッダが見つからなかった場合にはエラー情報(負の整数値)を返します。

typedef struct{
    unsigned long  headerID;  /*  DLLヘッダID("DLL0")     */
    unsigned short minorVer;  /*  マイナーバージョン      */
    unsigned short majorVer;  /*  メジャーバージョン      */
    unsigned long  userRsv;   /*  ユーザ用リザーブ        */
    unsigned long  sysRsv;    /*  システムリザーブ        */
}stLibHeader;

DLLヘッダを発見した場合には、この構造体の中にDLLヘッダ情報が格納されます。
DLLヘッダをダイナミックリンクライブラリの規定の位置に発見できなかった場合は、
負の値(_XLD_ERR_NOHEADER)を戻り値として返し、DLLヘッダ情報には何も格納されま
せん。なお、DLLヘッダはダイナミックリンクライブラリ作成者が意図して組み込まな
い限り、ダイナミックリンクライブラリには含まれません。また、ダイナミックリン
クライブラリの規定位置にDLLヘッダがない場合は、DLLヘッダは発見できなかったも
のとみなされます。

-----------------------------------------------------------------------------
._XLD_init
ダイナミックリンク機能の初期設定
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
void *_XLD_init(void *pRsc); 
void *pRsc;  /* リソースデータへのポインタ */ 

- 戻り値 -
リソースデータへのポインタを返します。NULLの場合は指定のポインタの指すデータ
ブロックがリソースデータではないことを示します。

- 内容 -
ダイナミックリンクマネージャにリソースデータのアドレスを通知します。
引数pRscをNULLとしておけば、ダイナミックリンクマネージャがアプリケーションに
スタティックリンクされているリソースデータを検索します。pRscにNULL以外が指定
された場合にはpRscの指すデータブロックがリソースデータかどうかを検査し、リソ
ースデータでない場合にはNULLポインタを返します。検査が正常終了した場合には戻
り値は指定されたポインタと等しくなります。
なお、この関数はTownsシェルアプリケーション中から使用できません。

-----------------------------------------------------------------------------
._XLD_isLinked
ライブラリのロード状態の検査
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
int _XLD_isLinked(int (*func)());
int (*func)();  /* 検査するライブラリ関数へのポインタ */ 

- 戻り値 -
ダイナミックリンクライブラリがメモリ上にロードされているとき非0の値を返します
。ダイナミックリンクライブラリがメモリ上にないかまたは引数が不法なポインタで
ある場合には0を返します。

- 内容 -
指定したダイナミックリンクライブラリがメモリ上にロードされているかどうかを検
査します。非0が返された場合には、ダイナミックリンクライブラリはメモリ上にロー
ドされていることを示します。

-----------------------------------------------------------------------------
._XLD_load
ライブラリのロード
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
void_XLD_load(int (*func)());
int (*func)();  /* ロードするライブラリ関数へのポインタ */

- 内容 -
指定したライブラリ関数をメモリ上にロードします。ロードされたダイナミックリン
クライブラリは実行されません。この関数は、ダイナミックリンクライブラリを実行
するよりも前に、あらかじめロードしておく必要がある場合に用います。

-----------------------------------------------------------------------------
._XLD_lockLib 
ライブラリのロック設定
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
int  _XLD_lockLib(int (*func)()); 
int (*func)();  /* ロックするライブラリ関数へのポインタ */

- 戻り値 -
ライブラリ領域のロックが正常に終了した場合に0を返します。
引数に不法なポインタを指定した場合やライブラリがメモリ上に存在しない場合には
エラー情報(負の整数値)を返します。

- 内容 -
指定したライブラリ関数をロックします。この関数によってロックされたライブラリ
は、_XLD_unlink関数によって開放されません。この関数は、スタティックなデータを
持つライブラリ関数や、割り込みハンドラで使用されるライブラリ関数をロックする
ために使用します。

- 参照 -
_XLD_unlockLib関数

-----------------------------------------------------------------------------
._XLD_setError
実行時エラー情報の設定
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
void    _XLD_setError(int errNo);
int     errNo;        /* 設定するエラー情報 */ 

- 内容 -
アプリケーションエラー情報を任意の値に設定します。この関数を実行後に_XLD_get
Error関数によってエラー情報を取得すると、再びダイナミックリンクライブラリの
呼び出しが発生するまでこの関数で設定した値が返ってくるようになります。
ダイナミックリンクライブラリ内で他のダイナミックリンクライブラリを呼び出した
時にエラーが発生した場合、通常はアプリケーションに処理が戻るまでエラー情報が
保存されますが、ダイナミックリンクライブラリ内でエラー対策を施してから戻る場
合には、この関数で任意のエラーを設定してアプリケーションに告知することができ
ます。エラー情報の初期化にはこの関数を使用することもできますが、明示的にエラ
ー情報を初期化するために_XLD_clearError関数を使用するようにしてください。
設定した値はアプリケーションやダイナミックリンクライブラリが受け取り、エラー
情報に従ったエラー処理が行われるので、使用するには厳重な注意が必要です。

- 参照 -
_XLD_getError関数
_XLD_clearError関数

-----------------------------------------------------------------------------
._XLD_setErrorFunc
ライブラリロード時エラーハンドラの登録
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
void    _XLD_setErrorFunc(int (*errFunc)()); 
int     (*errFunc)();   /*  登録するエラーハンドラへのポインタ  */

- 内容 -
ダイナミックリンクライブラリをロードしてリンクする際にエラーが発生した場合に
呼び出される関数(エラーハンドラ)を登録します。
エラーハンドラが呼び出されるエラーには以下の6種類に限られます。

  ┌─────────────┬──┐
  │            値            │    │
  ├─────────────┼──┤
  │_XLD_ERR_MALLOC           │ -2 │
  ├─────────────┼──┤
  │_XLD_ERR_LOADLIB          │ -3 │
  ├─────────────┼──┤
  │_XLD_ERR_NOEXTRSC         │ -4 │
  ├─────────────┼──┤
  │_XLD_ERR_NOLIB            │ -5 │
  ├─────────────┼──┤
  │_XLD_ERR_TOOLONGPATH      │ -8 │
  ├─────────────┼──┤
  │_XLD_ERR_NOLIBINMAIN      │ -9 │
  └─────────────┴──┘
エラーハンドラには以下の情報がパラメータとして渡されます。受け取った情報をも
とにエラーハンドラ内でエラー対策を行い、再度リンクを行うか、もしくはリンクを
断念して処理を戻すといった対応をとります。

  int errorFunc(int errNo,char *libname,char *modulename,int cc); 
  int errNo;        :エラー情報(_XLD_getError関数と同等)
  char *libname;    :エラーの発生した関数名
  char *modulename; :エラーの発生したライブラリモジュール名
  int cc;           :コンディションコード(エラー処理レベル)

エラーハンドラからの戻り値には、以下の4種のいずれかを指定します。
これによって以後のダイナミックリンクマネージャの処理が決定されます。
  ┌───────────┬─┬────────────────────┐
  │          値          │  │              内容                      │
  ├───────────┼─┼────────────────────┤
  │_XLD_CALL_CONTINUE    │ 0│エラーを無視して処理を続行させる        │
  ├───────────┼─┼────────────────────┤
  │_XLD_CALL_RETRY       │-1│再びリンクを試みる                      │
  ├───────────┼─┼────────────────────┤
  │_XLD_CALL_SYSRETRY    │-2│Townsシェルに対してエラーの対応を要求   │
  ├───────────┼─┼────────────────────┤
  │_XLD_CALL_HALT        │-3│ｱﾌﾟﾘｹｰｼｮﾝの動作の停止(ﾀｽｸｻｽﾍﾟﾝﾄﾞ)を要求 │
  └───────────┴─┴────────────────────┘
このうち、_XLD_CALL_SYSRETRYと_XLD_CALL_HALTはTownsシェルアプリケーションのみ
使用することができます。
エラーハンドラが登録されていない場合は、_XLD_CALL_CONTINUEが指定されたのと同
じ動作を行います。コンディションコードはハンドラの処理レベルを示します。
エラー発生直後にハンドラに入った場合には1が、ハンドラを終了してエラー対策を行
った後に再びエラーが発生した場合には2が入ります。
エラーリカバリーに失敗した場合、結果としてハンドラは2回呼び出されます。

- 参照 -
_XLD_getErrorFunc関数

-----------------------------------------------------------------------------
._XLD_setLinkPath 
ダイナミックリンクパスの指定
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
int  _XLD_setLinkPath(const char *dirname); 
const char *dirname;    /* リンクパスを設定する領域へのポインタ */ 

- 戻り値 -
パスが正しく設定された場合0を返します。指定したパス名がダイナミックリンクマネ
ージャの許容できる長さを超えた場合にはエラーを返します。

- 内容 -
ダイナミックリンクライブラリを最初に検索するディレクトリ名を指定します。この
関数の呼び出し以降、ダイナミックリンクマネージャはリソースに定義されているモ
ジュールをロードするときに、dirnameで指定されたディレクトリパスを最初初に検索
します。もし、dirnameディレクトリパスの中にモジュールが存在しなければ、ダイナ
ミックリンクマネージャはシステムデフォルトのダイナミックリンクライブラリディ
レクトリを検索します。ディレクトリパスは最大63文字まで指定できます。引数に
NULLポインタを指定することにより、指定をデフォルト状態に戻すことができます。

- 参照 -
_XLD_getLinkPath 関数
_XLD_getLinkPath2関数

-----------------------------------------------------------------------------
._XLD_setMemFunc
メモリ割り当て/開放関数の登録
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
void _XLD_setMemFunc(void *(*malloc)(size_t), void (*free)(void *));
void *(*malloc)(size_t);    /* メモリ割り当て関数へのポインタ */
void  (*free)(void*);       /* メモリ開放関数へのポインタ     */

- 内容 -
アプリケーションが使用しているメモリ割り当てや開放関数を登録します。
GUIライブラリを用いている場合には以下のようになります。

  _XLD_setMemFunc(TL_malloc, TL_free);

GUIライブラリを用いていない場合には以下のようになります。

  _XLD_setMemFunc(malloc, free); 

なお、この関数はTownsシェルアプリケーション中から使用できません。

- 参照 -
_XLD_callMalloc関数
_XLD_callFree関数

-----------------------------------------------------------------------------
._XLD_unlink
ライブラリの開放
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
size_t _XLD_unlink(int (*func)());
int(*func)();      /* 開放するライブラリ関数へのポインタ */ 

- 戻り値 -
指定したライブラリが占有していたメモリが開放できた場合にそのサイズをバイト単
位で返します。0の場合はフリー領域が得られなかったことを示します。

- 内容 -
指定したダイナミックリンクライブラリ関数のリンクカウントを減らします。すでに
リンクカウントが0の場合には、ライブラリの占有していたメモリブロックがフリー
領域となります。リンクカウントは、ダイナミックリンクライブラリを参照している
ライブラリの数を示します。戻り値が0の場合は、次のいずれかの原因により、フリー
領域にできなかったことを示します。
  ･指定のライブラリがロックされている
  ･指定のライブラリが、他のダイナミックリンクライブラリから使われている
   (リンクされている)

-----------------------------------------------------------------------------
._XLD_unlockLib 
ライブラリのロック解除
-----------------------------------------------------------------------------

- 定義 -
#include <xld.h>
int _XLD_unlockLib(int (*func)()); 
int (*func)();     /* ロックを解除するライブラリ関数へのポインタ */ 

- 戻り値 -
ライブラリのロック解除が正常に終了した場合に0を返します。
引数に不法なポインタを指定した場合やライブラリがメモリ上に存在しない場合には
エラー情報(負の整数値)を返します。

- 内容 -
_XLD_lockLib関数によって、ロックしたライブラリ関数のロック解除を行います。
これにより、ロック解除されたライブラリは_XLD_unlink関数によって開放することが
できます。

- 参照 -
_XLD_lockLib関数

4.3 サンプルプログラム

┌────────────────────────────────────┐
│  ダイナミックリンクサポートライブラリ  サンプルプログラム              │
│  ■  機能  ■                                                          │
│    ダイナミックリンク機能を使用したグラフィック描画プログラムです      │
└────────────────────────────────────┘
┌────┐
│DLLSMP.C│
└────┘
/*************************************************************
**          ダイナミックリンクサンプルプログラム            **
**************************************************************/
#include    <stdlib.h>
#include    <egb.h>
#include    <mos.h>
#include    <xld.h>

/*****  ダイナミックリンクライブラリのプロトタイプ宣言  *****/
extern int initEGB(char *__gwk, int __mode);
extern void demo_1(char *__gwk, int __mode);

/*****  グローバル変数                                  *****/
char *gwk;          /*  EGB作業領域                     *****/

/****   終了関数                                        *****/
void    end(void)
{
    free(gwk);
    MOS_end();
    exit(0);
}

/*****      メ  イ  ン                                  *****/
void    main(int argc, char **argv)
{
    int mode;       /*  画面モード                          */

    /*  デモ画面モードの設定                                */
    mode = argc == 1 ? 17 : atoi(*++argv);

    /*  ダイナミックリンクの初期設定                        */
    _XLD_init(0);
    _XLD_setMemFunc(malloc, free);

    /*  EGB作業領域の確保                                   */ 
    if ((gwk = malloc(EgbWorkSize)) == NULL)
        end();
    /*  表示系の初期設定                                    */
    /*  (ﾀﾞｲﾅﾐｯｸﾘﾝｸﾗｲﾌﾞﾗﾘの呼び出し)                        */
    if (initEGB(gwk, mode) < 0)
        end();

    /*  デモの起動                                          */
    /*  (ﾀﾞｲﾅﾐｯｸﾘﾝｸﾗｲﾌﾞﾗﾘの呼び出し)                        */
    demo_1(gwk, mode);

    end();
}

┌─────┐
│EGBINIT.C │
└─────┘
/*************************************************************
**          グラフィックスの初期設定                        **
**************************************************************/
#include    <stdlib.h>
#include    <egb.h>
#include    <mos.h>

char *mwk;  /*  マウスBIOS作業領域  */

/*************************************************************

        initEGB ---- グラフィックスの初期設定

        Return   0 = 正常終了
                -1 = マウスBIOS用の作業領域が確保できません

**************************************************************/
int initEGB(char *gwk, int mode)
{
    if ((mwk = malloc(MosWorkSize)) == NULL)
        return -1;

    EGB_init(gwk, EgbWorkSize);
    EGB_resolution(gwk, 0, mode);       /* ページ#0の画面モード */
    EGB_displayPage(gwk, 0, 1);         /* 表示画面モード       */
    EGB_writePage(gwk, 0);              /* 書き込みページ       */
    EGB_colorIGRB(gwk, 0, 0xffffff00);  /* 境界色               */
    EGB_colorIGRB(gwk, 2, 0xff0000ff);  /* 面塗り色             */
    EGB_writeMode(gwk, 4);              /* 描画モード           */
    EGB_paintMode(gwk, 0x22);           /* 面塗りモード         */

    MOS_start(mwk, MosWorkSize);
    MOS_resolution(0, mode);
    MOS_writePage(0);

    return  0;
}

┌───┐
│DEMO.C│
└───┘
/*************************************************************
**  ダイナミックリンクライブラリを使った描画デモプログラム  **
**************************************************************/
#include    <egb.h>
#include    <sidework.h>

typedef unsigned short USHORT;

extern int line(char *gwk, USHORT startX, USHORT startY, USHORT endX, USHORT endY);

void    demo_1(char *gwk, int mode)
{
    USHORT x0, y0;  /*  描画座標                            */
    int dx;         /*  表示画面水平方向ドット数            */
    int dy;         /*  表示画面垂直方向ドット数            */
    int ddx;        /*  表示座標水平方向最大値 (ex. 639)    */
    int ddy;        /*  表示座標垂直方向最大値 (ex. 479)    */
    int colIGRB;    /*  描画色                              */
    int step;       /*  描画色の差分                        */
    /*  表示画面ドット数の取得  */
    EGB_getScrnInfo(mode, NULL, NULL, &dx, &dy, NULL);

    ddx = dx - 1; 
    ddy = dy - 1; 
    step = 0xffffff / (dx + dy);

    for (x0 = 0, colIGRB = 0; x0 < dx; x0++, colIGRB += step) {
        EGB_colorIGRB(gwk, 0, colIGRB);
        line(gwk, x0, 0, ddx - x0, ddy); /* ﾀﾞｲﾅﾐｯｸﾘﾝｸﾗｲﾌﾞﾗﾘ呼び出し */
    }

    for (y0 = 0; y0 < dy; y0++, colIGRB += step) {
        EGB_colorIGRB(gwk, 0, colIGRB);
        line(gwk, 0, ddy - y0, ddx, y0); /* ﾀﾞｲﾅﾐｯｸﾘﾝｸﾗｲﾌﾞﾗﾘ呼び出し */
    }
}

┌───┐
│LINE.C│
└───┘
/*************************************************************
**                直線の描画プログラム                      **
**************************************************************/
#include <stddef.h>   /* NULLの定義 */
#include <egb.h>
#include <mos.h>
typedef unsigned short USHORT;

/*************************************************************

        line ---- 直線の描画

**************************************************************/
int line(char *gwk, USHORT startX, USHORT startY, USHORT endX, USHORT endY)
{
    USHORT para[5];
    int dsp;

    para[0] = 2;
    para[1] = startX;
    para[2] = startY;
    para[3] = endX;
    para[4] = endY;
    MOS_getDisp(&dsp, NULL);
    MOS_disp(0);
    EGB_connect(gwk, (char *)para);
    MOS_disp(dsp);

    return  0;
}

┌─────┐
│DLLSMP.RDF│
└─────┘
extern
    initEGB             EGBinit.dll
    demo_1              demo.dll
end
public
    EGB_init
    EGB_resolution
    EGB_displayPage
    EGB_writePage
    EGB_colorIGRB
    EGB_writeMode
    EGB_paintMode
    EGB_connect
    MOS_start
    MOS_resolution
    MOS_writePage
    MOS_disp
    MOS_getDisp
    EGB_getScrnInfo
    malloc
    printf
end

┌──────┐
│EGBINIT.RDF │
└──────┘
extern
    EGB_init        NUL
    EGB_resolution  NUL
    EGB_displayPage NUL
    EGB_writePage   NUL
    EGB_colorIGRB   NUL
    EGB_writeMode   NUL
    EGB_paintMode   NUL
    MOS_start       NUL
    MOS_resolution  NUL
    MOS_writePage   NUL
    malloc          NUL
end
public
    initEGB
end

┌────┐
│DEMO.RDF│
└────┘
extern
    EGB_colorIGRB   NUL
    line            line.dll
    EGB_getScrnInfo NUL
end
public
    demo_1
end

┌────┐
│LINE.RDF│
└────┘
extern
    MOS_disp        NUL
    MOS_getDisp     NUL
    EGB_connect     NUL
end
public
    line
end

4.4 デバッグ

  ダイナミックリンクライブラリのデバッグ方法を実例を示しながら説明します。

  ここでは、あるアプリケーションプログラムから呼び出されるダイナミックリンク
ライブラリdllFuncを386DEBUGによってデバッグしているものとします。

 1)dllFuncにブレークポイントを設定し、実行します。
┌────────────────────────────────────┐
│  -g dllFunc[RET]                                                       │
│  Breakpoint at 000C:XXXXXXXX ...                                       │
│  EAX= ...                                                              │
│  ESI= ...                                                              │
│  DS=0014  SS=0014 ...                                                  │
│  CS:EIP=000C:XXXXXXXX ...                                              │
│  dllFunc:                                                              │
│  000C:XXXXXXXX 68545B0000     PUSH  Dword Ptr offset ...               │
└────────────────────────────────────┘
   dllFuncで停止したときのインストラクションポインタ値はリソース内のエントリ
   であり、dllFunc関数のエントリではありません。

 2)次にシンボル_XLD_kickoffにブレークポイントを設定し、実行します。
   _XLD_kickoffは、dllFuncに制御が移る1ステップ直前のアドレスとなっています。
┌────────────────────────────────────┐
│  -g _XLD_kickoff[RET]                                                  │
│  Breakpoint at 000C:YYYYYYYY ...                                       │
│  EAX=[不定値] EBX=[不定値] ECX=[リターンアドレス] EDX=[不定値]...      │
│  ESI=[不定値] EDI=[不定値] EBP=[不定値]...                             │
│  DS=0014  SS=0014 ...                                                  │
│  CS:EIP=000C:YYYYYYYY ...                                              │
│  _XLD_kickoff:                                                         │
│  000C:YYYYYYYY FF6214         JMP[EXD+14]                              │
└────────────────────────────────────┘

 3)さらに1ステップ実行を行うと、dllFuncの本体に制御が移ります。
┌────────────────────────────────────┐
│  -t[RET]                                                               │
│  Breakpoint at 000C:ZZZZZZZZ ...                                       │
│  EAX=[不定値] EBX=[不定値] ECX=[リターンアドレス] EDX=[不定値]...      │
│  ESI=[不定値] EDI=[不定値] EBP=[不定値] ...                            │
│  DS=0014  SS=0014 ...                                                  │
│  CS:EIP=000C:ZZZZZZZZ ...                                              │
│ [意味のないシンボル表示]                                               │
│  000C:ZZZZZZZZ 55             PUSH  EBP   ... dllFuncの最初のステップ  │
└────────────────────────────────────┘
   また、このときのECXレジスタの値はdllFuncのリターンアドレスとなっています。
   たとえば、この状態でg ecx[RET]を行うと、ダイナミックリンクライブラリ
   dllFuncの実際の呼び出し元に戻ります。このECXの値はダイナミックリンクライブ
   ラリのデバッグのために設定されているもので、ライブラリの中でその値を保存す
   る必要はありません。
   なお、このときのスタックトップに積まれているリターンアドレスはダイナミック
   リンクマネージャ内のアドレスですので気をつけてください。

            ┌────────────────────────┐
   SS:ESP →│  ダイナミックリンクマネージャへの戻りアドレス  │
            ├────────────────────────┤
            │    ダイナミックリンクライブラリのパラメータ    │
            │                                                │
            〜                      …                        〜
            ├────────────────────────┤
                ▲dllFunc本体に制御が移ったときのスタック

  ┌────────────┐      ┌────────────┐
  │func( ... ) {           │      │    func:               │
  │          …            │      │              …        │
  │          …            │      │         push #b        │
  │          …            │      │         push #a        │
  │   r = dllFunc(a, b);   │または│         call dllFunc   │
  │[ECX] →  …            │      │[ECX] → add  esp,8     │
  │          …            │      │              …        │
  │          …            │      │              …        │
  └────────────┘      └────────────┘
        ▲dllFunc本体に制御が移ったときのECXの値の意味

*****************************************************************************
第10章  ポケットライブラリ
*****************************************************************************

1 ポケットライブラリについて

1.1 概要

  Townsシステムソフトウェア V2.1では、アプリケーションの間でのデータの互換性
を良くするために画像や音声データのためのデータファイルフォーマットが決められ
ています。このため、ひとつのデータファイルを複数のアプリケーションの間で共用
することが可能です。あるアプリケーションで利用するためのデータを、別のアプリ
ケーションによってデータファイルとして作成するということが多く見受けられます
。しかし、ひとつのデータをアプリケーションの間で授受するためだけにデータファ
イルを媒介とし、いちいち各アプリケーションを利用するたびにファイルの書き込み
や読み込みを繰り返すのは煩わしい場合があります。
  そこで、円滑なデータ交換を行うためにデータファイルではなく複数のアプリケー
ションが共有できる一時作業用の領域のようなものがあれば便利です。このため、シ
ステムメモリ(ポケット)を媒介としたデータ交換機能を実現し(この機構をポケット機
構と呼びます)、これによって、複数のアプリケーションの間でのデータ共有の操作性
を向上させ、各アプリケーションの連携をよりいっそう高めます。

┌────────┐        ┌────────┐          ┌───────┐
│┌──────┐│コピー  │┌──────┐├┐ ｺﾋﾟｰ   │┌─────┐│
││   データ   ├┼────→│   データ   │←┼────┼┤ データ   ││
││            │←────┼┤            ├┼┼────→│          ││
│└──────┘│ペースト│└──────┘││ ﾍﾟｰｽﾄ  │└─────┘│
│    アプリ1     │        │  ポケット      ││        │  アプリ2     │
└────────┘        └┬───────┘│        └───────┘
                              │  ポケット      │
                              │      マネージャ│
                              └────────┘
                        ▲図1アプリケーション間のポケット

1.2 ユーザビュー

1.2.1 ユーザインタフェースの拡張

  アプリケーションの編集メニューのアイテムの中にポケットに対するコピーアンド
ペーストというユーザインタフェースを加えることができます。
従来のカット(コピー)アンドペーストはアプリケーションの中だけに閉ざされていた
ため、アプリケーションが持つバッファを利用してアプリケーション固有のデータ構
造によって行われ、他のアプリケーションとの連携はありませんでした。ポケットに
対するコピーアンドペーストは、システムの提供するポケット領域を利用して、ポケ
ット標準データフォーマット(後述)によって行います。

1.2.2 ポケットの寿命

  ポケットデータはシステムがリセットされるか、またはSYSINITコマンドによってシ
ステム領域が開放されるまで有効です。

1.3 ポケット領域とサイズ

  図EXL121R-021

1.3.1 ポケット領域

  ポケット領域はアプリケーションからはどこに存在するかということは意識されず
、仮想的な領域として扱われます。ポケット領域はデータの書き込みによって拡張さ
れていきます。このサイズの上限はポケットバッファのサイズとポケットファイルを
作成するためのディスクの空き容量の合計となります。アプリケーションとポケット
領域との間のデータ転送方法は、指定のデータフォーマットを持つファイルの操作と
類似しており、アプリケーションの持つバッファを介して、可変レコード長で転送す
ることができます。ポケットデータは実際にはメインメモリ上のポケットバッファ(上
図 2)と外部のディスク上の空き領域上のポケットファイル(上図 2)に保持されます。
これらを合わせてポケット領域(上図 2)と呼びます。ポケットマネージャは、アプリ
ケーションから転送されるデータがポケットバッファに収まりきらない場合に、超過
分をポケットファイルに記録します。
┌────────────────────────────────────┐
│   [  ポケット領域のサイズ 1  ] ＝                                      │
│       [  ポケットバッファ(メインメモリ上)  のサイズ 2  ]               │
│     + [  ポケットファイル(ディスクファイル)のサイズ 3  ]               │
└────────────────────────────────────┘

1.3.2 ポケットバッファの指定

  ポケットバッファはデフォルトでは4KBが確保されています。このサイズは変更可能
です。システムデータ定義ファイル(デフォルトでは起動ドライブの"\SYSINIT\SYSINI
T.SYS")内に以下のように指定してください。

    /RSRV 'CLIP' [ポケットバッファのサイズ(4KB単位)]

1.3.3 ポケットファイルの指定

  ポケットファイルを作成するディレクトリは、デフォルトでは起動ドライブの\SCB
ディレクトリ下(なければ自動的に作成する)となっています。ポケットファイルの作
成ディレクトリを決定するための判断手順は下図 3のとおりです。フロッピィディス
クまたは光磁気ディスクまたはネットワークドライブにポケットファイルを作成する
ことはできません。

  図EXL121R-022

  また、環境変数によってポケットファイルのディレクトリのパスを直接指定するこ
とも可能です。ただし、ディレクトリのパス指定に誤りがあった場合はポケットファ
イルを作成することができません。

- 例 -
SET SCB=F:\SCRAP

1.4 ポケットデータ

1.4.1 ポケット標準データフォーマット

  ポケットには、以下に示す形式のデータをひとつ保持することができます。
  これらのデータ形式をポケット標準データフォーマットと呼びます。

  ･ASCII 文字列
  ･TIFF
  ･MS RIFF DIB(デバイス独立ビットマップ:RDIB)
  ･Towns Drawデータ
  ･Towns PCMデータ(SND) 
  ･MS Waveform オーディオファイル(WAVE)
  ･Towns MIDI(EUP) 
  ･MS RIFF MIDI(RMIDI) 
  ･MS Windows ムービーファイル(MMM) 
  ･動画データ(MVE) 

1.5 アプリケーションインタフェース

1.5.1 アプリケーション初期処理

■アプリケーション初期処理手順

  [ ポケットをオープンします ]
  if  ポケットをオープンします  then
    if   ポケットにアプリケーションが扱えるデータ形式があります then 
        [  編集メニューのペースト項目を有効にします ]
    else
        [  編集メニューのペースト項目を無効にします ]
  else
    [ ポケットが無効 ]
┌────────────────────────────────────┐
│  size_t scbSize;  /*   アプリケーションで利用するポケットのサイズ */   │
│  /*  ポケットをオープンします */                                       │
│  if((status =SCB_open()) = 0){                                         │
│      if(SCB_isFormatAvailable( SCBF_TIFF )                             │
│              || SCB_isFormatAvailable( SCBF_RDIB )){                   │
│          ┌──────────────────────┐              │
│          │  編集メニューのペースト項目を有効にします  │              │
│          └──────────────────────┘              │
│      }else{                                                            │
│          ┌──────────────────────┐              │
│          │  編集メニューのペースト項目を無効にします  │              │
│          └──────────────────────┘              │
│      }                                                                 │
│      return TRUE;                                                      │
│  }else{   /* ポケットにデータがないか、またはポケットが無効です */     │
│      return FALSE;                                                     │
│  }                                                                     │
└────────────────────────────────────┘

1.5.2 ポケットデータ転送処理

■カット/コピー処理手順

 1)ポケット内にデータエントリを確保します。
   (データが入っている場合は削除します。)
 2)ポケットにデータを書き込みます。
┌────────────────────────────────────┐
│  SCB_empty();                                                          │
│  if(SCB_write(SCBF_TIFF, buffer, bufSize) == bufSize){                 │
│      ┌───────────────────┐                        │
│      │  書き込み処理が成功しました          │                        │
│      └───────────────────┘                        │
│  }else{                                                                │
│      ┌───────────────────┐                        │
│      │  ポケットがオーバーフローしました    │                        │
│      └───────────────────┘                        │
│  }                                                                     │
└────────────────────────────────────┘

■ペースト処理手順

 1)ポケットからデータを読み出します。
┌────────────────────────────────────┐
│  if(SCB_read(SCBF_TIFF, buffer, bufSize) != 0){                        │
│      ┌───────────────────┐                        │
│      │  読み出し処理が成功しました          │                        │
│      └───────────────────┘                        │
│  }else{                                                                │
│      ┌───────────────────┐                        │
│      │  指定のデータがポケットにありません  │                        │
│      └───────────────────┘                        │
│  }                                                                     │
└────────────────────────────────────┘

2 ポケットライブラリ

2.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│SCB_open                  │ポケットのオープン                        │
├─────────────┼─────────────────────┤
│SCB_close                 │ポケットのクローズ                        │
├─────────────┼─────────────────────┤
│SCB_isFormatAvailable     │ポケットデータの有無の検査                │
├─────────────┼─────────────────────┤
│SCB_empty                 │ポケットデータの削除                      │
├─────────────┼─────────────────────┤
│SCB_write                 │ポケットへのデータの書き込み              │
├─────────────┼─────────────────────┤
│SCB_read                  │ポケットからのデータの読み出し            │
├─────────────┼─────────────────────┤
│SCB_seek                  │ポケットデータポインタの移動              │
└─────────────┴─────────────────────┘

2.2 各関数の解説

-----------------------------------------------------------------------------
.SCB_close 
ポケットのクローズ
-----------------------------------------------------------------------------

- 定義 -
#include <pocket.h> 
void SCB_close(void);

- 内容 -
ポケットのクローズ処理を行います。ポケットライブラリではデータを保護するため
、多重オープンを禁止しています。オープン後、処理が終了したら必ずクローズ処理
を行ってください。何らかのアプリケーションがポケットをオープン状態にしている
間は、他のアプリケーションはポケットをオープンすることができません。

-----------------------------------------------------------------------------
.SCB_empty 
ポケットデータの削除
-----------------------------------------------------------------------------

- 定義 -
#include <pocket.h> 
int SCB_empty(void);

- 戻り値 -
0 :正常終了

- 内容 -
ポケット領域内の全てのデータを削除します。ポケットに既に他のアプリケーション
が入れたデータが入っている状態では、アプリケーションは新たにデータを書き込む
ことができません。データを新たにポケットに書き込む場合には、本関数を使用し、
既存のデータを削除してから書き込みを行ってください。

-----------------------------------------------------------------------------
.SCB_isFormatAvailable 
ポケットデータの有無の検査
-----------------------------------------------------------------------------

- 定義 -
#include <pocket.h> 
int SCB_isFormatAvailable(int dataType);
int dataType;     /*  確認するデータタイプ   */ 

- 戻り値 -
0     :ポケットの中に指定したデータタイプのデータが存在しない
0以外 :データサイズ
       (ポケットの中に指定したデータタイプのデータが存在する)

- 内容 -
ポケットの中に指定したデータタイプのデータが存在するかどうかを検査します。
指定されたデータタイプのデータがあれば保持されているデータのサイズを返し、
ポケット内に指定されたデータタイプのデータがなければ0を返します。

-----------------------------------------------------------------------------
.SCB_open
ポケットのオープン
-----------------------------------------------------------------------------

- 定義 -
#include <pocket.h> 
int SCB_open(void); 

- 戻り値 -
0    :正常終了
負数 :ポケット機能がインストールされていない
      または多重オープンになるため、オープンできない

- 内容 -
SCB_open関数によって、ポケット領域を使用するために必要なセットアップ処理を行
います。正常終了の場合は0を返しますが、ポケット機能がインストールされていない
場合(システムのバージョンが古い場合など)、または多重オープンになる場合には負
の整数が返されます。ポケットはデータ保護のため、多重オープンを禁止しています
。オープン中は他のアプリケーションはポケットにアクセスできないので、処理終了
後には必ずクローズ処理を行ってください。

-----------------------------------------------------------------------------
.SCB_read
ポケットからのデータの読み出し
-----------------------------------------------------------------------------

- 定義 -
#include <pocket.h> 
int SCB_read(int dataType, void *dataBuf, size_t dataSize);
int       dataType;  /*   データのタイプ          */
void     *dataBuf;   /*   データバッファ          */
size_t    dataSize;  /*   転送データのサイズ      */

- 戻り値 -
読み出したデータのサイズ

- 内容 -
データポインタの現在位置からデータを読み出します。

- 注意 -
データ書き込み時、読み出し時にはデータポインタが書き込んだデータサイズ分、
または読み出したデータサイズ分移動します。例えばデータの書き込みを行った直後
にデータ読み込みを行った場合は、データポインタが書き込まれたデータの最後尾を
指しているためデータを読み出すことができません。データの書き込みや読み出し時
には、SCB_seek関数を使用してデータポインタの位置を指定してください。

-----------------------------------------------------------------------------
.SCB_seek
ポケットデータポインタの移動
-----------------------------------------------------------------------------

- 定義 -
#include <pocket.h> 
int SCB_seek(int dataType, long ofs, int from); 
int   dataType;      /*   データのタイプ    */
long  ofs;           /*   移動オフセット    */
int   from;          /*   移動起点          */

- 戻り値 -
0     :正常終了
0以外 :データタイプまたは移動オフセットまたは移動起点の指定が不正

- 内容 -
指定されたデータタイプのポケットデータポインタを、fromで指定した位置からofsバ
イトだけ移動します。ofsは符号付の整数とします。
  ┌──────┬─────────────────────┐
  │    from    │                移動起点                  │
  ├──────┼─────────────────────┤
  │ SCBS_SET   │  ポケットデータの先頭                    │
  │ SCBS_CUR   │  ポケットデータポインタの現在位置        │
  │ SCBS_END   │  ポケットデータの終端                    │
  └──────┴─────────────────────┘

-----------------------------------------------------------------------------
.SCB_write 
ポケットへのデータの書き込み
-----------------------------------------------------------------------------

- 定義 -
#include <pocket.h> 
int SCB_write(int dataType, void *dataBuf, size_t dataSize);
int       dataType;  /*   データタイプ            */
void     *dataBuf;   /*   データバッファ          */
size_t    dataSize;  /*   転送データのサイズ      */

- 戻り値 -
書き込んだデータのサイズ

- 内容 -
データポインタの現在位置から、ポケットへデータを書き込みます。データポインタ
は書き込まれたデータサイズ分後ろに移動します。
0byteデータを書き込んだ場合は書き込み時のデータポインタ位置以降のデータを破棄
し、データ長をデータポインタまでとします。
  ┌────────┬────────────────────────┐
  │    dataType    │                  内        容                  │
  ├────────┼────────────────────────┤
  │  SCBF_CSTR     │  ASCII 文字列                                  │
  │  SCBF_TIFF     │  TIFF                                          │
  │  SCBF_TDRAW    │  Towns Drawデータ                              │
  │  SCBF_RDIB     │  MS RIFF DIB(デバイス独立ビットマップ)         │
  │  SCBF_SND      │  Towns PCMデータ                               │
  │  SCBF_WAVE     │  MS Waveformオーディオファイル                 │
  │  SCBF_EUP      │  Towns MIDI                                    │
  │  SCBF_RMIDI    │  MS RIFF MIDI                                  │
  │  SCBF_MMM      │  MS Windowsムービーファイル                    │
  │  SCBF_MVE      │  動画データ                                    │
  └────────┴────────────────────────┘

- 注意 -
 ･この関数はデフォルトでユーザスタックを約3Kbyte消費します。
  使用にあたっては、十分なスタックを用意してください。
 ･データがすでにポケットに入っている場合は、新たな種類のデータの書き込みを行
  うことはできません。この関数の使用にあたっては、まずSCB_empty関数を使用して
  既存のデータを削除してください。
 ･ユーザアプリ固有データなどでポケットにアクセスしたい場合は、次のデータIDを
  使用してください。その際には、他のアプリケーションの混乱を防ぐために、アプ
  リケーション終了時にアプリケーション固有データをポケット領域に残さないでく
  ださい。

    SCBF_USER       ユーザデータ用ID

2.3 サンプルプログラム

┌────────────────────────────────────┐
│  ポケットライブラリ  サンプルプログラム                                │
│  ■  機能  ■                                                          │
│    SNDデータをポケット領域へ書き込んだ後、読み出して再生します。       │
└────────────────────────────────────┘

/**************************************************************************

    ポケットライブラリ サンプルコーディング A

    ■ 機能 ■
      A:SMP.SNDからデータを読み込みポケット領域に書き込むプログラムです

    ■ 注意 ■
      本サンプルプログラムはTMENU上からダブルクリックで実行してください
      実行前にドライブAのカレントディレクトリに任意のSNDデータファイルを
      SMP.SNDとリネームしてコピーしておいてください
      本サンプルプログラム実行後､SMPB.EXPを実行すると､本サンプルプログラム
      でポケット領域に書き込んだSNDデータを再生します

**************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pocket.h>

#define POCKET_WORK_SIZE    262144
extern  setDisp();
char    *PcmDat[] = {"a:smp.snd"};

void main()
{
    int     ret, dataSize;
    void    *buff;
    FILE    *fp;

  if(!SCB_open()) {   /* ポケットオープン成功 */
        if((buff=malloc(POCKET_WORK_SIZE))!=NULL){
            if((fp=fopen(PcmDat[0],"rb"))!=NULL){
                dataSize=fread(buff,sizeof(char),POCKET_WORK_SIZE,fp);
                fclose(fp);

                setDisp(0,0);

                SCB_empty();
                ret = SCB_write(SCBF_SND,buff,dataSize);
                SCB_seek(SCBF_SND,0,SCBS_SET);
                if(ret!=dataSize){  
                 /*SNDデータが最後までポケットに入りません*/
                  setDisp(0,2);
                    SCB_write(SCBF_SND,buff,0);
                    /* 書き込んだSNDデータをポケットから削除します    */ 
                }
            }else{
                setDisp(0,6); 
            }
            free(buff);
        }
        SCB_close();

    } else {    /* ポケット領域がない､又はポケット領域は現在アクセス中です */
        setDisp(0,1);
    }

}
/**************************************************************************

    ポケットライブラリ サンプルコーディング B

    ■ 機能 ■
       ポケット領域内のsndデータを読み込み､演奏するプログラム

    ■ 注意 ■
      本サンプルプログラムはTMENU上からダブルクリックで実行してください
      実行前にSMPA.EXPを実行する等で､ポケット領域にSNDデータを書き込んでお
      いてください

**************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <snd.h>
#include <pocket.h>

#define SND_WORK_SIZE (16384)
extern  setDisp();

int Play(rate,vol,pan,buff)
int rate;
int vol;
int pan;
char buff[];
{
    int org_note;
    SND_pan_set(71,pan);
    if(rate){
        rate=rate*0x62/1000;
        *(short int*)&buff[24]=rate;
    }
    org_note = buff[28];
    return(SND_pcm_play2(71,org_note,vol,buff));
}

void PlaySND(work,buff)
char *work;
char *buff;
{
    if(!SND_init(work)){

        SND_elevol_mute(0x03);
        SND_pcm_sound_delete(-1);
        SND_pcm_mode_set(1);

        Play(0,127,64,buff);
        while(SND_pcm_status(71));

        SND_pcm_play_stop(71);
        SND_pcm_rec_stop();

        SND_end();
    }

}

void main()
{
    char    *buff;
    char    *work;
    int     mem_size;
    size_t  dataSize;

    mem_size=4;
    mem_size=mem_size*65536;

    if((work=malloc(SND_WORK_SIZE+mem_size))!=NULL){
        buff=work+SND_WORK_SIZE;

        if(SCB_open()==0) { /* ポケットオープン成功 */

            if((dataSize=SCB_isFormatAvailable(SCBF_SND))!=0){
                setDisp(1,3);
                }
                if(SCB_read(SCBF_SND,buff,dataSize)==dataSize){
                    PlaySND(work,buff);
                }else{
                    setDisp(1,5);
            }else{  /* ポケット内にサウンドデータがありません  */
                setDisp(1,4);
            }
            SCB_close();
        }else{
            setDisp(1,1);
        }
        free(work);
    }
}

/**************************************************************************

    ポケットライブラリ サンプルコーディング

    ■ 機能 ■
       メッセージ表示用関数

**************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <egb.h>

#define EGB_WORK_SIZE       1536

char *Choice[] = {
    "Aﾄﾞﾗｲﾌﾞ/SMP.SNDのSNDﾃﾞｰﾀをﾎﾟｹｯﾄｲﾝします",       /* 0 */
    "ﾎﾟｹｯﾄ領域にｱｸｾｽできません",                     /* 1 */
    "ﾎﾟｹｯﾄ領域が足りません",                         /* 2 */
    "ﾎﾟｹｯﾄ内のSNDﾃﾞｰﾀを演奏します",                  /* 3 */
    "ﾎﾟｹｯﾄ内にSNDﾃﾞｰﾀがありません",                  /* 4 */
    "ﾎﾟｹｯﾄ内のSNDﾃﾞｰﾀの読み込みに失敗しました",      /* 5 */
    "Aﾄﾞﾗｲﾌﾞ/SMP.SNDをオープンできません",           /* 6 */
};

char *Title[] = {
    "ﾎﾟｹｯﾄﾗｲﾌﾞﾗﾘ ｻﾝﾌﾟﾙﾌﾟﾛｸﾞﾗﾑ A",                    /* 0 */
    "ﾎﾟｹｯﾄﾗｲﾌﾞﾗﾘ ｻﾝﾌﾟﾙﾌﾟﾛｸﾞﾗﾑ B",                    /* 1 */
};

void setDisp( int tsw, int sw )
{
    char    *work;
    int     page0, page1, writepage;
    char    para[64];

    if((work = malloc(EGB_WORK_SIZE)) != NULL){

        EGB_getResolution( &page0, &page1 );
        page0 = page0 | 0x40 ;
        page1 = page1 | 0x40 ;
        EGB_resolution( work, 0, page0 );
        EGB_resolution( work, 1, page1 );
        writepage = EGB_getWritePage( 0, 0 );
        EGB_writePage( work, writepage );
        EGB_color( work, 2, 0x09 );
        EGB_color( work, 0, 0x0f );
        EGB_paintMode( work, 0x22 );
        WORD(para+0) = WORD(para+2) = 100;
        WORD(para+4) = 450;
        WORD(para+6) = 150;
        EGB_rectangle( work, para );

        strcpy( &para[6], Title[tsw] );
        WORD(para+4) = strlen( Title[tsw] );
        WORD(para+0) = 110;
        WORD(para+2) = 120;
        EGB_sjisString( work, para );

        strcpy( &para[6], Choice[sw] );
        WORD(para+4) = strlen( Choice[sw] );
        WORD(para+0) = 110;
        WORD(para+2) = 140;
        EGB_sjisString( work, para );

        free( work );

    }else{      /* EGBワーク領域の確保に失敗しました */
        exit(0);
    }
}

*****************************************************************************
第11章  サウンドメッセージライブラリ
*****************************************************************************

1 サラウンドメッセージライブラリについて

1.1 概要

  サウンドメッセージライブラリは、TOWNSアプリケーション上でのユーザアクション
、リアクションをより明確化することを目的としたシステム機構です。
  サウンドメッセージとは、TOWNSアプリケーションでの、ボタンのクリック時、確認
/警告ウィンドウの表示時やプログラム処理終了時などに、表示とは別にBEEP/PCM音声
を再生することです。サウンドメッセージのサポートによりユーザアクション、リア
クションの明確化を図り、HCIの向上をその目的としています。

  図EXL121R-023

1.2 サウンドメッセージ機構全体像

  録音は、GEARボイスエディタ、Towns SOUNDなどで行います。再生は、GUIの対応、
サウンドメッセージライブラリ提供により各種アプリなどで行います。設定は、コン
トロールパネルとサウンドメッセージ設定ユーティリティで行います。

  図EXL121R-024

1.2.1 それぞれの役割

 (1)Towns SOUNDなど
    外部からの音声(MIC)、演奏(LINE)、CD音楽などの入力をPCMデータに変換したり
    編集をしてSNDファイル、WAVファイルを出力します。

 (2)サウンドメッセージ設定ユーティリティ
    ユーザの指定どおりサウンドエフェクト番号とSNDファイルやWAVファイルの対応
    表などを作成してMSGファイルとして出力します。

 (3)コントロールパネル
    ユーザ指定によりサウンドメッセージのON/OFF(有効/無効)の設定を行い、MSG管
    理フラグに書き込みます。

 (4)SYSINIT.EXE(メモリ展開ツール)
    MSGデータを展開し、これを常駐させます。

 (5)MSGD(サウンドメッセージ制御情報+PCMデータ)
    サウンドメッセージの各IDごとの制御情報およびPCMデータです。

 (6)SMG(サウンドメッセージ制御ドライバ)
    アプリケーション(ライブラリ)からコールされ、システム状態などを判断してPCM
    データなどを再生します。

 (7)SNDファイル
    PCMデータファイル、サウンドメッセージ設定ユーティリティでMSGファイルにマ
    ージされ、MSGデータになります。

1.3 サウンドメッセージデータID

 ■IDについて
   サウンドメッセージを使用するときはすべてIDによって音を指定します。
   下のID以外もシステムリザーブとなっているので使用しないでください。

┌───┬────────┬───┬───────────────────┐
│項  目│ｻｳﾝﾄﾞﾒｯｾｰｼﾞ ID  │実  値│            備          考            │
├───┼────────┼───┼───────────────────┤
│ｸﾘｯｸ  │SMSG_CLICK      │0x0000│アクティブボタンのクリック時など      │
├───┼────────┼───┼───────────────────┤
│有効  │SMSG_ACTIVATE   │0x0001│ダブルクリック時など                  │
├───┼────────┼───┼───────────────────┤
│無効  │SMSG_INACTIVATE │0x0002│インアクディブボタンのクリック時など  │
├───┼────────┼───┼───────────────────┤
│警告  │SMSG_WARNING    │0x0003│非可逆処理発生時など                  │
├───┼────────┼───┼───────────────────┤
│注目  │SMSG_ATTENTION  │0x0004│確認、選択時など                      │
├───┼────────┼───┼───────────────────┤
│ﾁｬｲﾑ  │SMSG_CHIME      │0x0005│処理終了時など                        │
├───┼────────┼───┼───────────────────┤
│ｴﾗー  │SMSG_ERROR      │0x0006│エラー発生時など                      │
├───┼────────┼───┼───────────────────┤
│効果  │SMSG_EFFECT     │0x0007│他の項目に該当しない場合              │
└───┴────────┴───┴───────────────────┘

1.4 注意事項

 (1)サウンドメッセージインターフェース(smsg.h､smsg.lib)は、サウンドメッセージ
    ドライバを組み込んだシステムでのみ有効であり、サウンドメッセージドライバ
    を組み込まないシステム上では、サウンドメッセージの効果は得られません。
    またサウンドメッセージドライバはFORRBIOSをコールするので、これが登録され
    ていない場合の動作は保証できません。

    実際の組み込み方法を以下に示します。

    1)SYSINIT.SYSに以下のようにメッセージデータを組み込みます。
      (識別タグ"MSGD")

        /SYSR   'FONT' D:\SYSINIT\SYSTEM.FNT
        /DATA   'ICON' D:\SYSINIT\SYSTEM.ICO
        /DATA   'SKBD' D:\SYSINIT\SYSTEM.SKB
        /DATA   'MSGD' D:\SYSINIT\SYSTEM.MSG  ←･････組み込む
  
    2)"AUTOEXEC.BAT"などでNSDDを登録します。

        \HCOPY\COCO_MEM 
        \RUN386 \HCOPY\ADDDRV \HCOPY\FORBIOS.NSD
        \HCOPY\COCO_MEM 
        \RUN386 \HCOPY\ADDDRV \HCOPY\SMSG.NSD 

    3)サウンドメッセージドライバを削除します。
      (識別タグ "SMG") 

        \RUN386 \HCOPY\DELDRV SMG 

 (2)WAV,SND,BEEPの全てのメッセージが鳴るようにするためには､以下の条件が整って
    いなければなりません。

    1)smsg.nsdが常駐している。

    2)下記の文のようにsystem.msgがsysinit.sysに'MSGD'という名前で登録されてい
      る。
        /DATA 'MSGD' d:\sysinit\system.msg

    3)SND_initを行っている。
        char s_work[0x4000];
        SND_init(s_work);

    4)SND_elevol_muteによってミュート回路が解除されている。
        SND_elevol_mute(0x01);

    5)WAV_initを行っている。
        WAV_init();

    6)WAV_makeTableによってWAV用バッファの登録を行っている。
        char ring_buff[0x4000];
        char ctrl_table[64];
        *(int *)ctrl_table = 3;
        ret = WAV_makeTable(ring_buff,ctrl_table);

    7)WAV_setVolumeによって音量が設定されている。
        WAV_setVolume(127,127);

    8)SMSG_openを行っている。
        SMSG_open(s_work);

    9)SMSG_playを行っている。
        SMSG_play(id, mode);

    サンプルプログラムを参考にしてプログラミングしてください。

2 サラウンドメッセージライブラリ

2.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│SMSG_chk                  │サウンドメッセージの存在確認              │
├─────────────┼─────────────────────┤
│SMSG_open                 │サウンドメッセージの初期化                │
├─────────────┼─────────────────────┤
│SMSG_close                │サウンドメッセージの終了                  │
├─────────────┼─────────────────────┤
│SMSG_play                 │サウンドメッセージの再生                  │
├─────────────┼─────────────────────┤
│SMSG_stop                 │サウンドメッセージの強制停止              │
├─────────────┼─────────────────────┤
│SMSG_setMode              │メッセージドライバ再生モードの設定        │
├─────────────┼─────────────────────┤
│SMSG_getMode              │メッセージドライバ再生モードの取得        │
├─────────────┼─────────────────────┤
│SMSG_getInfo              │サウンドメッセージデータの情報取得        │
└─────────────┴─────────────────────┘

2.2 各関数の解説

-----------------------------------------------------------------------------
.SMSG_chk 
サウンドメッセージの存在確認
-----------------------------------------------------------------------------

- 定義 -
#include <smsg.h> 
int    SMSG_chk(void);

- 戻り値 -
0 :サウンドメッセージドライバが常駐していない
1 :サウンドメッセージドライバが常駐している

- 例 -
#include <smsg.h> 
        …
int     ret;

ret =   SMSG_chk();

- 内容 -
メッセージドライバ(SMSG.NSD)がメモリ上に常駐しているかどうかを調べます。

-----------------------------------------------------------------------------
.SMSG_close 
サウンドメッセージの終了
-----------------------------------------------------------------------------

- 定義 -
#include <smsg.h> 
int    SMS_close(void);

- 戻り値 -
 0 :正常終了
-3 :メッセージドライバが未登録

- 例 -
#include <smsg.h> 
          …
int     ret;

ret =   SMSG_close();

- 内容 -
メッセージドライバを終了します。

-----------------------------------------------------------------------------
.SMSG_getInfo 
サウンドメッセージデータの情報取得
-----------------------------------------------------------------------------

- 定義 -
#include <smsg.h> 
int    SMSG_getInfo(int ID);
int    ID;             /*  ｻｳﾝﾄﾞﾒｯｾｰｼﾞ ID */

- 戻り値 -
 0〜7    :BEEPが登録されている
-1       :無音が登録されている
-2       :目的のIDは登録されていない
-3       :メッセージデータまたはメッセージドライバが常駐していない
それ以外 :最上位ビットがoffならSNDデータのオフセットアドレス、onならWAVデータ
          のオフセットアドレス

- 例 -
#include <smsg.h> 
        …
int     info; 

info =  SMSG_getInfo(SMSG_CLICK);

- 内容 -
指定したIDに関する情報を取得します。取得したSNDデータのオフセットアドレスのセ
グメントセレクタ値はSYSINITの関数を使って取得してください。

- 例 -
Seg = mma_allocSeg("MSGD"); 

-----------------------------------------------------------------------------
.SMSG_getMode 
メッセージドライバ再生モードの取得
-----------------------------------------------------------------------------

- 定義 -
#include <smsg.h> 
int    SMSG_getMode(int *mode); 
int     *mode;             /*  ﾒｯｾｰｼﾞﾄﾞﾗｲﾊﾞ再生ﾓｰﾄﾞ  */

- 戻り値 -
 0 :正常終了
-3 :メッセージドライバが未登録

- 例 -
#include <smsg.h> 
        …
int     mode; 
int     ret;

ret =   SMSG_getMode(&mode); 

- 内容 -
再生モードを取得します。

[再生モード]
  0     :サウンドメッセージ再生OFF 
  0以外 :サウンドメッセージ再生ON

-----------------------------------------------------------------------------
.SMSG_open
サウンドメッセージの初期化
-----------------------------------------------------------------------------

- 定義 -
#include <smsg.h> 
int    SMSG_open(char *work  offset); 
char  *work_offset;   /* SND ﾗｲﾌﾞﾗﾘﾜｰｸのｱﾄﾞﾚｽ                   */
                      /* ｱﾌﾟﾘｹｰｼｮﾝ がSND を使用しない場合はNULL */

- 戻り値 -
 0 :正常終了
-3 :メッセージドライバが未登録

- 例 -
#include <smsg.h> 
        …
int     ret;

ret =   SMSG_open(NULL);

- 内容 -
メッセージドライバを初期化します。ワークアドレスがNULLの場合はPCMデータが登録
されていてもBEEPしか鳴りません。
メッセージドライバが登録されていなければ、エラー(-3)を返します。

-----------------------------------------------------------------------------
.SMSG_play
サウンドメッセージの再生
-----------------------------------------------------------------------------

- 定義 -
#include <smsg.h> 
int    SMSG_play(int Id,int mode);
int    Id;               /*  ｻｳﾝﾄﾞﾒｯｾｰｼﾞ ID */
int    mode;             /*  再生モード     */

- 戻り値 -
 0 :正常終了
-3 :メッセージドライバが未登録

- 例 -
#include <smsg.h> 
        …
int     Id,ret; 

Id  =   SMSG_ATTENTION;
ret =   SMSG_play(Id ,0);

- 内容 -
メッセージデータを再生します。

modeによって再生するソースを選択できます。
  mode = 0:設定されているソースどおりに再生します。
  mode = 1:設定にかかわらずBEEPで再生します。
  mode = 2:設定にかかわらずSNDで再生します。
  mode = 3:設定にかかわらずWAVで再生します。

-----------------------------------------------------------------------------
.SMSG_setMode 
メッセージドライバ再生モードの設定
-----------------------------------------------------------------------------

- 定義 -
#include <smsg.h> 
int    SMSG_setMode(int mode);
int    mode;             /*  ﾒｯｾｰｼﾞﾄﾞﾗｲﾊﾞ再生ﾓｰﾄﾞ  */

- 戻り値 -
 0 :正常終了
-3 :メッセージドライバが未登録

- 例 -
#include <smsg.h> 
        …
int     mode; 
int     ret;

ret =   SMSG_setMode(0); 

- 内容 -
再生モードを設定します。これは一時的にMUTEするだけでC-MOSには反映されません。

[再生モード]
  0     :サウンドメッセージ再生OFF 
  0以外 :サウンドメッセージ再生ON

-----------------------------------------------------------------------------
.SMSG_stop
サウンドメッセージの強制停止
-----------------------------------------------------------------------------

- 定義 -
#include <smsg.h> 
int    SMSG_stop(void); 

- 戻り値 -
 0 :正常終了
-3 :メッセージドライバが未登録

- 例 -
#include <smsg.h> 
        …
int     ret;

SMSG_stop(); 

- 内容 -
メッセージデータを強制中断して停止します。アラートボックスのボタンが押された
場合など、メッセージを途中で止めたいときに使用します。

2.3 サンプルプログラム

┌────────────────────────────────────┐
│サウンドメッセージライブラリ  サンプルプログラム                        │
│  ■  機能  ■                                                          │
│引数に対応したサウンドメッセージを発音します。                          │
│アイテム登録で引数(0〜7)を指定するか、もしくはコマンドモードで引数を    │
│指定し、実行してください。終了するときは何かキーを押してください。      │
└────────────────────────────────────┘

#include <stdio.h>
#include <snd.h>
#include <wav.h>
#include <smsg.h>

char s_work[0x4000];
char ring_buff[0x4000];
char ctrl_table[64];

int main(int argc,char **argv)
{
    int     i,id,mode;
    char    c;

    /* 引数のチェック*/
    if(argc < 2)
            exit(1);
    c = *argv[1];
    if((c < '0') || (c > '9'))
            exit(1)
    id = c - '0';
    mode = 0;

    /* サウンド､ウェーブBIOSの初期化 */
    if(SND_init(s_work))
            goto error;
    if(WAV_init())
            goto error;
    *(int *)ctrl_table = 3;
    if(WAV_makeTable(ring_buff,ctrl_table))
            goto error;

    /* サウンド､ウェーブのミュート解除 */
    SND_elevol_mute(0x01);
    WAV_setVolume(127,127);

    /* メッセージドライバの初期化 */
    if(SMSG_open(s_work))
        goto error;

    /* 発音 */
    if(SMSG_play(id, mode))
        goto error;

    /* キーボード入力待ち */
    while(_kbinit()==0);
    SMSG_stop();

    /* 終了処理 */
    WAV_end();
    SND_end();
    exit(0);
error:
    WAV_end();
    SND_end();
    exit(1);
}

*****************************************************************************
第12章  プリンタドライバライブラリ
*****************************************************************************

1 プリンタドライバライブラリについて

1.1 概要

  プリンタドライバライブラリは、プリンタのハードウェア仕様(DPI値や制御コード)
を意識しなくても、簡単にイメージデータをプリンタに印刷させることができるライ
ブラリです。各プリンタの固有情報は、スクリプトファイルという外部ファイルに格
納され、このファイルの内容を書き換えるだけで、プログラムを修正することなく複
数のプリンタに同時対応させることができます。

2 スクリプト情報の構成

  ここでは、スクリプト情報の構成とその内容について解説します。

2.1 構成

 (1)スクリプト情報ファイル(PRINTER.INF) 
    a.スクリプト情報ファイルは、テキスト型のファイルとして提供されます。
    b.スクリプト情報ファイルは、複数のスクリプト情報から構成されます。
    c.スクリプト情報ファイル内の複数のスクリプト情報は、それぞれのプリンタ
      に対応します。
    d.任意のスクリプト情報を指定するために、インデックス番号があります。
    e.インデックス番号は個々のスクリプト情報に対して固有のもので、スクリプ
      ト情報ファイル内の定義順に先頭を0番として通し番号で振られています。
      (0〜31までの32個)
    f.スクリプト情報ファイルは、起動ドライブの"\HCOPY"、または環境変数
      PRNINFで指定したディレクトリの下に存在します。
    g.スクリプト情報ファイルは、市販のテキスト編集プログラムにより変更可能
      です。

 (2)スクリプト情報
    a.プリンタに対するスクリプト情報は、任意長の文字列で記述されています。
    b.スクリプト情報は、一個のプリンタ名定義と複数個の情報定義から構成され
      ます。
    c.スクリプト情報は、最大32個定義できます。
    d.スクリプト情報の定義例を次に示します。

  ┌─────────────────────────────────┐
  │FM-PRINTER|FMPR:   ←  プリンタ名定義       ┐                    │
  │    :MAK = "FUJITSU"  ┐                    │                    │
  │    :MCD = "FM-PR204" │                    │                    │
  │    :DPI = 180        │                    │                    │
  │    :DOT = 24         ├情報定義            ├スクリプト情報の単位│
  │    :INI = "\x1bA"    │                    │                    │
  │      ･               │                    │                    │
  │      ･               │                    │                    │
  │      ･               ┘                    ┘                    │
  │FM-PRINTER|FMPR:   ←  プリンタ名定義       ┐                    │
  │    :MAK = "FUJITSU"  ┐                    │                    │
  │    :MCD = "FM-PR353" │                    │                    │
  │      ･               ├情報定義            ├スクリプト情報の単位│
  │      ･               │                    │                    │
  │      ･               ┘                    ┘                    │
  └─────────────────────────────────┘
    ▲スクリプト情報の定義例

2.2 書式

 (1)基本書式
    a.各定義は一行単位で記述してください。
      同一行に複数の定義、または複数行にまたがる定義はできません。
    b.コメントは、"；"の後からその行の終端の間に記述してください。
    c.以下に示すものが定義可能です。
      ･プリンタ名定義
      ･情報定義─┬文字列定義
                 └数値定義

 (2)プリンタ名定義の書式
    a.プリンタ名定義の書式を以下に示します。
┌────────────────────────────────────┐
│＜プリンタ名＞[|別名]:                                      [；コメント]│
└────────────────────────────────────┘
    b.プリンタ名定義は、行頭より記述します。
    c.プリンタ名定義は、一行で記述します。
    d.別名がある場合は、プリンタ名の直後に"|"を記述し、その後ろに記述します。
    e.プリンタ名および別名は、空白以外で始まる任意の文字列を記述します。
    f.プリンタ名および別名は、それぞれANKで32文字までとします。
    g.プリンタ名定義の例を以下に示します。
┌────────────────────────────────────┐
│FM-PRINTER0|FMPR0:                         ；ポート0のプリンタ          │
└────────────────────────────────────┘

 (3)情報定義の書式
    a.情報定義の書式を以下に示します。
┌────────────────────────────────────┐
│  :＜検索キー名＞  ＝  ＜データ＞                           [；コメント]│
└────────────────────────────────────┘
    b.情報定義は、行頭より空白またはタブを一つ以上記述したあとに記述します。
    c.検索キー名は、":"の直後から定義してください。
    d.同一行に複数個の情報定義はできません。
    e.複数行にまたがる定義はできません。
    f.検索キーの長さは、ANK換算で32文字までとします。

 (4)情報定義1(文字列定義)の書式
    a.文字列定義の書式を以下に示します。
┌────────────────────────────────────┐
│  :＜検索キー名＞  ＝   "文字列"                            [；コメント]│
└────────────────────────────────────┘
    b.ANK文字を検索キー名として使用する場合は、以下に示す制限があります。
     ･先頭が英文字で始まる英文字と数字から構成される文字列
    c.文字列の定義は、C言語の表記に準じた記述とします。("文字列")
      ただし%dなどは使用できません。
    d.文字列定義の例を以下に示します。
┌────────────────────────────────────┐
│  :MAKER = "富士通"                                                     │
│  :INI   = "\x1bA"              ; ESC + 'A'                             │
└────────────────────────────────────┘

 (5)情報定義2(数値定義)の書式
    a.数値定義の書式を以下に示します。
┌────────────────────────────────────┐
│  :＜検索キー名＞  ＝  数値                                 [；コメント]│
└────────────────────────────────────┘
    b.ANK文字を検索キー名として使用する場合は、以下に示す制限があります。
     ･先頭が英文字で始まる英文字と数字から構成される文字列
    c.数値の記述は、C言語の表記に準じた記述とします。(最大値は、2^32 - 1)
    d."，"により複数の定義が可能です。
    e.数値定義の例を以下に示します。
┌────────────────────────────────────┐
│  :AAA   = 128                   ;  10進数                              │
│  :BBB   = 070                   ;   8進数                              │
│  :CCC   = 0x1a                  ;  16進数                              │
│  :DDD   = 0x1a,0x1b,0x1c,0x1d   ;  複数の定義                          │
└────────────────────────────────────┘

2.3 検索キーの書式

 (1)プリンタ情報
┌─────────────┬───────────────────┐
│        キ  ー  名        │            機          能            │
├─────────────┼───────────────────┤
│MAKER                     │プリンタのメーカー名の指定            │
├─────────────┼───────────────────┤
│PRINTER                   │プリンタの機種名の指定                │
├─────────────┼───────────────────┤
│TYPE                      │プリンタの種別の指定                  │
├─────────────┼───────────────────┤
│DPI                       │プリンタの画素密度の指定              │
├─────────────┼───────────────────┤
│DOT                       │一行の縦ドット数の指定                │
├─────────────┼───────────────────┤
│ANKWIDTH                  │ANK文字の横幅ドット数の指定           │
├─────────────┼───────────────────┤
│ANKHEIGHT                 │ANK文字の縦幅ドット数の指定           │
├─────────────┼───────────────────┤
│MAXWIDTH                  │横方向の最大ドット数の指定            │
├─────────────┼───────────────────┤
│SHEET                     │用紙種別の指定                        │
├─────────────┼───────────────────┤
│FEED                      │プリンタの紙送り方式の指定            │
├─────────────┼───────────────────┤
│COLOR                     │プリンタのカラー種別の指定            │
├─────────────┼───────────────────┤
│COLORSEQ                  │カラー印刷の順序の指定                │
├─────────────┼───────────────────┤
│BIOS                      │プリンタ制御方式の指定                │
├─────────────┼───────────────────┤
│PORT                      │プリンタのポートの指定                │
├─────────────┼───────────────────┤
│IMAGE                     │イメージ印刷方式の指定                │
├─────────────┼───────────────────┤
│IMG_TYPE                  │イメージデータの出力形式の指定        │
├─────────────┼───────────────────┤
│SEQ_TYPE                  │オーダのシーケンス種別の指定          │
└─────────────┴───────────────────┘

┌───────────────────────────────────┐
│MAKER  ＝  ＜ "文字列" ＞                                             │
└───────────────────────────────────┘
- 内容 -
プリンタのメーカー名を指定します。

- 例 -
:MAKER ="富士通"

┌───────────────────────────────────┐
│PRINTER  ＝  ＜ "文字列" ＞                                           │
└───────────────────────────────────┘
- 内容 -
プリンタの機種名を指定します。

- 例 -
:PRINTER ="FMPR-204"

┌───────────────────────────────────┐
│TYPE  ＝  ＜数値＞                                                    │
└───────────────────────────────────┘
- 内容 -
プリンタの種別を指定します。数値とプリンタ種別の関係は以下のとおりです。
省略時はドットインパクトプリンタと見なされます。
    1     :ドットインパクトプリンタ(デフォルト)
    2     :熱転写プリンタ
    3     :レーザービームプリンタ
    4     :インク(バブル)ジェットプリンタ
   その他 :リザーブ

- 例 -
:TYPE = 1     ; ドットインパクトプリンタ

┌───────────────────────────────────┐
│DPI  ＝  ＜数値＞                                                     │
└───────────────────────────────────┘
- 内容 -
プリンタの画素密度をドット/インチ(dpi)で指定します。
省略時は180dpiと見なされます。

- 例 -
:DPI = 180   ; 180dpi プリンタ

┌───────────────────────────────────┐
│DOT  ＝  ＜数値＞                                                     │
└───────────────────────────────────┘
- 内容 -
一行の縦ドット数を指定します。一行の印刷動作を行うドット数として使用します。
通常は、プリンタのピン数に一致します。省略時は24dotと見なされます。

- 例 -
:DOT = 24    ; 24pinプリンタ

┌───────────────────────────────────┐
│ANKWIDTH  ＝  ＜数値＞                                                │
└───────────────────────────────────┘
- 内容 -
ANK文字の横幅ドット数を指定します。
文字桁よりドット数を計算する場合に使用します。
省略時は24dotと見なされます。

- 例 -
:ANKWIDTH = 24    ; 24dot 

┌───────────────────────────────────┐
│ANKHEIGHT  ＝  ＜数値＞                                               │
└───────────────────────────────────┘
- 内容 -
ANK文字の縦幅ドット数を指定します。
文字行よりドット数を計算する場合に使用します。
省略時は24dotと見なされます。

- 例 -
:ANKHEIGHT = 24    ; 24dot

┌───────────────────────────────────┐
│MAXWIDTH  ＝  ＜数値＞                                                │
└───────────────────────────────────┘
- 内容 -
印刷可能な横方向の最大ドット数を指定します。
この値は印刷範囲のチェックに使用します。
通常は印刷可能域の横幅と画素密度より算出可能です。
省略時は印刷範囲のチェックを行いません。

- 例 -
:MAXWIDTH = 1024

┌───────────────────────────────────┐
│SHEET  ＝  ＜数値＞                                                   │
└───────────────────────────────────┘
- 内容 -
用紙種別を指定します。数値と用紙種別の関係は以下のとおりです。
省略時は連帳用紙と見なされます。
    1      :連帳用紙(デフォルト)
    2      :単票用紙
    その他 :リザーブ

- 例 -
:SHEET = 1     ;連帳用紙

┌───────────────────────────────────┐
│FEED  ＝  ＜数値＞                                                    │
└───────────────────────────────────┘
- 内容 -
プリンタの紙送り方式を指定します。数値と紙送り方式の関係は以下のとおりです。
用紙種別が単票の場合に使用し、カットシートフィーダを使用する場合は2:自動を指
定してください。省略時は手動と見なされます。
    1      :手動(デフォルト)
    2      :自動
    その他 :リザーブ

- 例 -
:FEED = 1     ;手動

┌───────────────────────────────────┐
│COLOR  ＝  ＜数値＞                                                   │
└───────────────────────────────────┘
- 内容 -
プリンタのカラー種別を指定します。数値とカラー種別の関係は以下のとおりです。
省略時は単色(モノクロ)プリンタと見なされます。
    1      :単色(モノクロ)プリンタ(デフォルト)
    2      :3色カラープリンタ
    3      :4色カラープリンタ
    その他 :リザーブ

- 例 -
:COLOR = 1     ; 単色(モノクロ)プリンタ

┌───────────────────────────────────┐
│COLORSEQ  ＝  ＜ "文字列" ＞                                          │
└───────────────────────────────────┘
- 内容 -
カラー印刷の順序を指定します。印刷する色の順序に対応する文字を定義します。
カラー種別がカラープリンタのときに使用します。モノクロプリンタ時は定義不要で
す。省略時は"YMSB"が定義されたものと見なされ、下記以外の文字を記述した場合は
、その文字は無視されます。
    黄色     :Y
    マゼンダ :M
    シアン   :C
    黒色     :B

- 例 -
:COLORSEQ = "YMCB"

┌───────────────────────────────────┐
│BIOS  ＝  ＜数値＞                                                    │
└───────────────────────────────────┘
- 内容 -
プリンタ制御方式を指定します。
数値とプリンタ制御方式の関係は以下のとおりです。
省略時はセントロニクス系と見なされます。
    1      :セントロニクス系(デフォルト)
    2      :SCSI系
    その他 :リザーブ

- 例 -
:BIOS  = 1

┌───────────────────────────────────┐
│PORT  ＝  ＜数値＞                                                    │
└───────────────────────────────────┘
- 内容 -
プリンタのポートを指定します。
セントロニクス系の場合は、ポート番号を指定します。
SCSI系の場合は、ID番号を指定します。省略時は"0"と見なされます。

- 例 -
:PORT  = 0

┌───────────────────────────────────┐
│IMAGE  ＝  ＜数値＞                                                   │
└───────────────────────────────────┘
- 内容 -
イメージ印刷方式を指定します。
数値とイメージ印刷方式の関係は以下のとおりです。
省略時はFMシーケンス1と見なされます。
    1      :FMシーケンス1(行単位のイメージ印刷)(デフォルト)
    2      :FMシーケンス2(矩形単位のイメージ印刷)
    3      :ESC/Pシーケンス
    その他 :リザーブ

- 例 -
:IMAGE = 1    ; FMシーケンス1

┌───────────────────────────────────┐
│IMG_TYPE  ＝  ＜数値＞                                                │
└───────────────────────────────────┘
- 内容 -
イメージデータの出力形式を指定します。
数値と出力形式の関係は以下のとおりです。
省略時は、イメージ印刷方式(IMAGE)の指定値により設定します。
    1    :行単位1(byteのMSBが、上位のピンに対応します。)(デフォルト)
    2    :矩形単位
    3    :行単位2(byteのLSBが、上位のピンに対応します。)
    IMAGE = 1は、IMG_TYPE = 1と同じ
    IMAGE = 2は、IMG_TYPE = 2と同じ
    IMAGE = 3は、IMG_TYPE = 1と同じ

- 例 -
:IMG_TYPE = 1    ; 行単位出力

┌───────────────────────────────────┐
│SEQ_TYPE  ＝  ＜数値＞                                                │
└───────────────────────────────────┘
- 内容 -
オーダのシーケンス種別を指定します。
数値とシーケンス種別の関係は以下のとおりです。
省略時はイメージ印刷方式(IMAGE)の指定値により設定します。
    1    :FMシーケンス(デフォルト)
    2    :ESC/Pシーケンス
    IMAGE = 1は、SEQ_TYPE = 1と同じ
    IMAGE = 2は、SEQ_TYPE = 1と同じ
    IMAGE = 3は、SEQ_TYPE = 2と同じ

- 例 -
:SEQ_TYPE = 1    ; FMシーケンス

 (2)プリンタの制御シーケンス
┌───────────┬──────────────────────┐
│      関  数  名      │              機          能                │
├───────────┼──────────────────────┤
│SEQ_RESET             │プリンタのリセットコマンドの指定            │
├───────────┼──────────────────────┤
│SEQ_FEED              │プリンタの用紙吸入コマンドの指定            │
├───────────┼──────────────────────┤
│SEQ_YELLOW            │プリンタの印刷色指定コマンドの指定(黄)      │
├───────────┼──────────────────────┤
│SEQ_MAJENDA           │プリンタの印刷色指定コマンドの指定(ﾏｾﾞﾝﾀﾞ)  │
├───────────┼──────────────────────┤
│SEQ_CYAN              │プリンタの印刷色指定コマンドの指定(ｼｱﾝ)     │
├───────────┼──────────────────────┤
│SEQ_BLACK             │プリンタの印刷色指定コマンドの指定(黒)      │
└───────────┴──────────────────────┘

┌────────────────────────────────────┐
│SEQ_RESET  ＝  ＜ "文字列" ＞                                           │
└────────────────────────────────────┘
- 内容 -
プリンタのリセットコマンドを指定します。
プリンタドライバ内でプリンタをリセットするときに使用します。

- 例 -
:SEQ_RESET = "\x1c]"    ;  RBS (CEX+]) 

┌────────────────────────────────────┐
│SEQ_FEED  ＝  ＜ "文字列" ＞                                            │
└────────────────────────────────────┘
- 内容 -
プリンタの用紙吸入コマンドを指定します。
用紙種別が単票で紙送り方式が自動の場合に必要です。

- 例 -
:SEQ_FEED = "\x1bQ0 ["    ;  CSF (ESC+Q+0+ + [)

┌────────────────────────────────────┐
│SEQ_YELLOW   ＝  ＜ "文字列" ＞                                         │
│SEQ_MAJENDA  ＝  ＜ "文字列" ＞                                         │
│SEQ_CYAN     ＝  ＜ "文字列" ＞                                         │
│SEQ_BLACK    ＝  ＜ "文字列" ＞                                         │
└────────────────────────────────────┘
- 内容 -
プリンタの印刷色指定コマンドを指定します。
プリンタ種別がカラープリンタのときに必要です。

- 例 -
:SEQ_YELLOW = "\x1b[33m"    ; SGR (ESC+[+3+3+m)
:SEQ_MAJENDA= "\x1b[35m"    ; SGR (ESC+[+3+5+m)
:SEQ_CYAN   = "\x1b[36m"    ; SGR (ESC+[+3+6+m)
:SEQ_BLACK  = "\x1b[30m"    ; SGR (ESC+[+3+0+m)

 (3)色調整情報
┌─────────────┬───────────────────┐
│        関  数  名        │            機          能            │
├─────────────┼───────────────────┤
│MASKP                     │一次マスキング情報の指定              │
├─────────────┼───────────────────┤
│UCOLOR                    │下面除去情報の指定                    │
├─────────────┼───────────────────┤
│DIZAX                     │網点パターンの横(ｘ)サイズの指定      │
├─────────────┼───────────────────┤
│DIZAY                     │網点パターンの縦(ｙ)サイズの指定      │
├─────────────┼───────────────────┤
│DIZAP                     │網点パターンの指定                    │
├─────────────┼───────────────────┤
│GRAY                      │グレースケール変換テーブルの指定      │
└─────────────┴───────────────────┘

┌────────────────────────────────────┐
│MASKP  ＝  ＜数値, 数値, ････, 数値＞                                   │
└────────────────────────────────────┘
- 内容 -
一次マスキング情報を指定します。
プリンタ種別がカラープリンタのときに必要です。
12個(48Byte)の数値データを定義してください。

- 例 -
:MASKP = 0x00000000,0x00000000, 〜 ,0x000ff000 ;

┌────────────────────────────────────┐
│UCOLOR  ＝  ＜数値＞                                                    │
└────────────────────────────────────┘
- 内容 -
下面除去情報を指定します。プリンタ種別が4色カラープリンタのときに必要です。
定義有効範囲は0〜100です。

- 例 -
:UCOLOR = 0 ; 

┌────────────────────────────────────┐
│DIZAX  ＝  ＜数値＞                                                     │
└────────────────────────────────────┘
- 内容 -
網点パターンの横(x)サイズを指定します。

- 例 -
:DIZAX = 4 ;

┌────────────────────────────────────┐
│DIZAY  ＝  ＜数値＞                                                     │
└────────────────────────────────────┘
- 内容 -
網点パターンの縦(y)サイズを指定します。

- 例 -
:DIZAY = 4 ;

┌────────────────────────────────────┐
│DIZAP  ＝  ＜数値, 数値, ･･, 数値＞                                     │
└────────────────────────────────────┘
- 内容 -
網点パターンを指定します。

- 例 -
:DIZAP = 0xd07080e0,〜,0xff7080f0 ; 

┌────────────────────────────────────┐
│GRAY  ＝  ＜数値, 数値, ･･, 数値＞                                      │
└────────────────────────────────────┘
- 内容 -
グレースケール変換テーブルを指定します。グレースケール変換処理で必要です。
256Byte分の定義が必要です。

- 例 -
:GRAY = 0x30201000,〜,0xfffefdfc ; 

3 プリンタ用API

3.1 ヘッダファイル

  プリンタ用APIで使用する構造体および値の宣言を以下に示します。
  "bprdev.h"に定義されています。

 (1)作業領域情報

    typedef struct
        {
        void           *BuffAddr;  作業領域のアドレス
        unsigned int    BuffSize;  作業領域のサイズ( バイト数 )
        }BPR_Buff; 
    
    typedef struct
        {
        BPR_Buff      Work1;  パレット用作業領域の情報
        BPR_Buff      Work2;  データ変換用内部作業領域の情報
        BPR_Buff      Work3;  データ変換用出力作業領域の情報
        BPR_Buff      Work4;  データ変換用情報保持領域の情報
        BPR_Buff      Work5;  印刷用作業領域の情報
        }BPR_Work; 

  a.パレット用作業領域
    TBIOS形式のパレットをデータ変換用のパレットに変換するための領域です。
    印刷するビットマップの種別により異なります。

  b.データ変換用内部作業領域/データ変換用出力作業領域
    データ変換機能で使用する作業領域です。

  c.データ変換用情報保持領域
    データ変換機能で使用する以下の情報を保持するための領域です。
    プリンタに依存します。
      ･グレースケール変換情報
      ･ディザパターン情報
      ･一次マスキング係数情報

  d.印刷用作業領域
    シーケンス制御で使用する作業領域です。

 (2)出力要求情報

    typedef struct
       {
        unsigned short  BitType;       ビットマップ種別
        unsigned short  Density;       ビットマップの画素密度
        unsigned int    Width;         ビットマップのサイズ( 横ドット数 )
        unsigned int    Height;        ビットマップのサイズ( 縦ドット数 )
        void           *Palette;       パレット情報へのアドレス
        unsigned short  ColorType;     印刷色種別
        unsigned short  Reverse;       反転印刷種別
        unsigned short  TopSpace;      印刷開始位置( 上マージン )
        unsigned short  LeftSpace;     印刷開始位置( 左マージン )
        unsigned short  rsv[4];        システム予約
        }BPR_Info; 

  a.ビットマップ種別
    印刷するビットマップの種別を指定します。
      BPR_MONO     1    モノクロ(2色)
      BPR_16       2    4096色中16色
      BPR_256      3    16M色中256色
      BPR_32K      4    32K色
      BPR_16M      5    16M色

  b.ビットマップの画素密度
    印刷するビットマップの画素密度を指定します。
    プリンタの画素密度ではありません。

  c.ビットマップのサイズ
    印刷するビットマップのサイズ(縦、横)をドット数で指定します。
    9999ドットまで指定可能です。

  d.パレット情報へのアドレス
    TBIOS形式のパレット情報へのアドレスを指定します。不要時はNULLを指定してく
    ださい。ビットマップ種別が以下のときに有効です。
      BPR_16       2    4096色中16色
      BPR_256      3    16M色中256色

  e.印刷色種別(ビットマップ種別がモノクロ以外のときに有効)
    印刷色を指定します。(カラープリンタ時に有効)
      BPR_DEFAULT  0    プリンタに依存する
      BPR_MONO     1    モノクロ印刷
      BPR_COLOR    2    カラー印刷

  f.反転印刷種別(ビットマップ種別がモノクロのときに有効)
    印刷色を指定します。
      BPR_NORMAL   1    通常の印刷
      BPR_REVERSE  2    反転印刷

  g.印刷開始位置
    印刷開始位置を用紙の印刷可能域の左上からのドット数で指定します。
    単位系変換関数により各単位からドット数を算出可能です。

  h.rsvシステム予約
    必ず0を設定してください。

 (3)異常詳細情報
    外部変数名unsigned int BPRDEVERRに設定されています。

  a.スクリプト情報アクセス異常時
      BPR_ACCESS     0x11   ファイルのアクセスに失敗しました
      BPR_NOFILE     0x12   ファイルが見つかりません
      BPR_NODATA     0x13   スクリプト情報がありません
      BPR_NOKEY      0x14   情報が未定義です
      BPR_FORMAT     0x15   定義形式が異常です
      BPR_RANGE      0x16   定義値が範囲外です
      BPR_SPLERR     0x1f   その他の異常です

  b.プリンタ出力異常時
      BPR_NOTREADY   0x21   ノットレデイ
      BPR_NOTPAPER   0x22   紙切れ
      BPR_PRNERR     0x2f   その他の異常

  c.その他の異常時
      BPR_CALLSEQ    0x91   呼び出し順序の異常
      BPR_PARAM      0x92   入力パラメータの異常
      BPR_ETCERR     0x9f   その他の異常

  d.エラー種別のマスク
      BPR_SPLMASK    0x10   スクリプト情報異常
      BPR_PRNMASK    0x20   プリンタ異常
      BPR_ETCMASK    0x90   その他の異常

 (4)その他
  a.スクリプト情報アクセス用作業領域の最小値
      BPR_BUFFSIZE

3.2 入力データの形式

 (1)16色ビットマップデータの形式
  a.1ピクセルが4bitのデータ形式で1byteに2ピクセル設定されます。
  b.1ラインの終端はダブル･ワード(4byte)境界となります。
  c.1ラインのピクセル数が8の整数倍でない場合フィラを設定します。
  d.1ラインのサイズ(バイト数)は以下の式で算出可能です。
        Line =  ((( 横ピクセル数+7) ÷8) ×8) ÷2  
  e.全体のサイズ(バイト数)は以下の式で算出可能です。
        Total=  縦ピクセル数 × 1ラインのサイズ(バイト数)
  f.本形式の場合は別にパレット情報が必要となります。
  g.横(n+1)ピクセル、縦(m+1)ピクセルの形式を次に示します。

  7  6  5  4  3  2  1  0
┌─────┬─────┐          ┐
│(1 , 0 )  │( 0 , 0 ) │+0        │(x,y) :ビットマップの左上を(x=0,y=0) 
├─────┼─────┤          │
│( 3 , 0 ) │( 2 , 0 ) │+1        │       としたときの各ピクセル情報
├─────┼─────┤          │
│( 5 , 0 ) │( 4 , 0 ) │+2        │
├─────┼─────┤          │
│( 7 , 0 ) │( 6 , 0 ) │+3        │
├─────┼─────┤          │
│( 9 , 0 ) │( 8 , 0 ) │+4        │
├─────┼─────┤          │
〜          〜          〜          ├0ライン目のデータ
├─────┼─────┤          │
│(n-8, 0 ) │(n-9, 0 ) │+(Line-5) │ 注意 ピクセル数が8の整数倍でない場合
├─────┼─────┤          │      のフィラ
│(n-6, 0 ) │(n-7, 0 ) │+(Line-4) │
├─────┼─────┤          │
│(n-4, 0 ) │(n-5, 0 ) │+(Line-3) │             横ピクセル数が133 の場合
├─────┼─────┤          │                                          │(n-2, 0 ) │(n-3, 0 ) │+(Line-2) │            ├─────┼─────┤
├─────┼─────┤          │            │(129, y ) │(128, y ) │
│( n , 0 ) │(n-1, 0 ) │+(Line-1) │            ├─────┼─────┤
├─────┼─────┤          ┘            │(131, y ) │(130, y ) │
│( 1 , 1 ) │( 0 , 1 ) │+Line                   ├─────┼─────┤
├─────┼─────┤                        │    ＊    │(132, y ) │
〜          〜          〜                        ├─────┼─────┤
├─────┼─────┤                        │    ＊    │    ＊    │
│( n ,m-1) │(n-1,m-1) │                        ├─────┼─────┤
├─────┼─────┤          ┐
│( 1 , m ) │( 0 , m ) │+(M*Line) │
├─────┼─────┤          │
│( 3 , m ) │( 2 , m ) │          │
├─────┼─────┤          │
│( 5 , m ) │( 4 , m ) │          │
├─────┼─────┤          │
│( 7 , m ) │( 6 , m ) │          │
├─────┼─────┤          │
│( 9 , m ) │( 8 , m ) │          │
├─────┼─────┤          │
〜          〜          〜          ├ｍライン目のデータ
├─────┼─────┤          │
│(n-8, m ) │(n-9, m ) │+(Total-5)│
├─────┼─────┤          │
│(n-6, m ) │(n-7, m ) │+(Total-4)│
├─────┼─────┤          │
│(n-4, m ) │(n-5, m ) │+(Total-3)│
├─────┼─────┤          │
│(n-2, m ) │(n-3, m ) │+(Total-2)│
├─────┼─────┤          │
│( n , m ) │(n-1, m ) │+(Total-1)│
└─────┴─────┘          ┘
  ▲16色ビットマップデータの形式

 (2)256色ビットマップデータの形式
  a.1ピクセルが8bitのデータ形式で1byteに1ピクセル設定されます。
  b.1ラインの終端はバイト境界となります。
  c.1ラインのサイズ(バイト数)は横ピクセル数に等しい大きさです。
        Line =  横ピクセル数
  d.全体のサイズ(バイト数)は以下の式で算出可能です。
        Total=  縦ピクセル数 × 1ラインのサイズ(バイト数)
  e.この形式の場合は別にパレット情報が必要となります。
  f.横(n+1)ピクセル、縦(m+1)ピクセルの形式を以下に示します。

  7  6  5  4  3  2  1  0
┌───────────┐          ┐
│       ( 0 , 0 )      │+0        │(x,y) :ビットマップの左上を(x=0,y=0) 
├───────────┤          │       としたときの各ピクセル情報
│       ( 1 , 0 )      │+1        │
├───────────┤          │
〜                      〜          ├0ライン目のデータ
├───────────┤          │
│      ( n-1 , 0 )     │+(n-1)    │
├───────────┤          │
│       ( n , 0 )      │+n        │
├───────────┤          ┘
│       ( 1 , 1 )      │+(n+1)
├───────────┤
〜                      〜
├───────────┤
│     ( n-1 , m-1 )    │+((Line*(m-1))+(n-1)) 
├───────────┤          ┐
│       ( 0 , m )      │+(Line*m) │
├───────────┤          │
│       ( 1 , m )      │          │
├───────────┤          │
〜                      〜          ├ｍライン目のデータ
├───────────┤          │
│      ( n-1 , m )     │          │
├───────────┤          │
│       ( n , m )      │+(Total-1)│
└───────────┘          ┘
  ▲256色ビットマップデータの形式

 (3)32K色ビットマップデータの形式
  a.1ピクセルが15bitのデータ形式で2byteに1ピクセル設定されます。
  b.1ラインの終端はワード(2Byte)境界となります。
  c.1ラインのサイズ(バイト数)は以下の式で算出可能です。
        Line =  横ピクセル数 × 2
  d.全体のサイズ(バイト数)は以下の式で算出可能です。
        Total=  縦ピクセル数 × 1ラインのサイズ(バイト数)
  e.この形式の場合はパレット情報は不要です。
  f.横(n+1)ピクセル、縦(m+1)ピクセルの形式を以下に示します。

  15                   0
┌───────────┐          ┐
│       ( 0 , 0 )      │+0        │(x,y) :ビットマップの左上を(x=0,y=0) 
├───────────┤          │       としたときの各ピクセル情報
│       ( 1 , 0 )      │+2        │
├───────────┤          │
〜                      〜          ├0ライン目のデータ
├───────────┤          │
│      ( n-1 , 0 )     │+((n-1)*2)│    ピクセル情報の構成
├───────────┤          │
│       ( n , 0 )      │+2n       │     15  14･･10  09･･05  04･･00
├───────────┤          ┘  ┌─┬────┬────┬────┐
│       ( 1 , 1 )      │+((n+1)*2)    │×│   Ｇ   │   Ｒ   │   Ｂ   │
├───────────┤              └─┴────┴────┴────┘
〜                      〜                      ×:不定値
├───────────┤
│     ( n-1 , m-1 )    │                      Ｇ:緑色の値(0〜31)
├───────────┤          ┐
│       ( 0 , m )      │+(Line*m) │          Ｒ:赤色の値(0〜31)
├───────────┤          │
│       ( 1 , m )      │          │          Ｂ:青色の値(0〜31)
├───────────┤          │
〜                      〜          ├ｍライン目のデータ
├───────────┤          │
│      ( n-1 , m )     │          │
├───────────┤          │
│       ( n , m )      │+(Total-1)│
└───────────┘          ┘
  ▲32K色ビットマップデータの形式

 (4)16M色ビットマップデータの形式
  a.1ピクセルが32bitのデータ形式で4byteに1ピクセル設定されます。
  b.1ラインの終端はダブル･ワード(4Byte)境界となります。
  c.1ラインのサイズ(バイト数)は以下の式で算出可能です。
        Line =  横ピクセル数 × 4
  d.全体のサイズ(バイト数)は以下の式で算出可能です。
        Total=  縦ピクセル数 × 1ラインのサイズ(バイト数)
  e.この形式の場合パレット情報は不要です。
  f.横(n+1)ピクセル、縦(m+1)ピクセルの形式を以下に示します。

  31                   0
┌───────────┐          ┐
│       ( 0 , 0 )      │+0        │(x,y) :ビットマップの左上を(x=0,y=0) 
├───────────┤          │       としたときの各ピクセル情報
│       ( 1 , 0 )      │+2        │
├───────────┤          │
〜                      〜          ├0ライン目のデータ
├───────────┤          │
│      ( n-1 , 0 )     │+((n-1)*2)│
├───────────┤          │    ピクセル情報の構成
│       ( n , 0 )      │+2n       │        7              0
├───────────┤          ┘      ┌────────┐
│       ( 1 , 1 )      │+((n+1)*2)        │       Ｒ       │+0
├───────────┤                  ├────────┤
〜                      〜                  │       Ｇ       │+1
├───────────┤                  ├────────┤
│     ( n-1 , m-1 )    │                  │       Ｂ       │+2
├───────────┤          ┐      ├────────┤
│       ( 0 , m )      │+(Line*m) │      │       ×       │+3
├───────────┤          │      └────────┘
│       ( 1 , m )      │          │
├───────────┤          │
〜                      〜          ├ｍライン目のデータ
├───────────┤          │
│      ( n-1 , m )     │          │
├───────────┤          │
│       ( n , m )      │+(Total-1)│
└───────────┘          ┘
  ▲16M色ビットマップデータの形式

3.3 プリンタインタフェース関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│BPR_Select                │プリンタの選択                            │
├─────────────┼─────────────────────┤
│BPR_GetSize               │作業領域サイズの取得                      │
├─────────────┼─────────────────────┤
│BPR_SetFunc               │印刷中止判別関数の登録                    │
├─────────────┼─────────────────────┤
│BPR_inch2dot              │単位系の変換( インチ→ドット数 )          │
├─────────────┼─────────────────────┤
│BPR_mm2dot                │単位系の変換( ミリメートル→ドット数 )    │
├─────────────┼─────────────────────┤
│BPR_char2dot              │単位系の変換( 桁数/ANK文字→ドット数 )    │
├─────────────┼─────────────────────┤
│BPR_line2dot              │単位系の変換( 行数/ANK文字→ドット数 )    │
├─────────────┼─────────────────────┤
│BPR_dot2inch              │単位系の変換( ドット数→インチ )          │
├─────────────┼─────────────────────┤
│BPR_dot2mm                │単位系の変換( ドット数→ミリメートル )    │
├─────────────┼─────────────────────┤
│BPR_dot2char              │単位系の変換( ドット数→桁数 )            │
├─────────────┼─────────────────────┤
│BPR_dot2line              │単位系の変換( ドット数→行数 )            │
├─────────────┼─────────────────────┤
│BPR_Start                 │印刷の開始                                │
├─────────────┼─────────────────────┤
│BPR_Print                 │印刷の実行                                │
├─────────────┼─────────────────────┤
│BPR_End                   │印刷の終了                                │
└─────────────┴─────────────────────┘

 (1)実行順序
  a.BPR_Select関数は、その他の関数の使用に先立って必ず実行してください。
  b.BPR_GetSize関数は、BPR_Select関数とBPR_Start関数の間で使用してください。
  c.BPR_SetFunc関数は、BPR_Select関数とBPR_Start関数の間で使用してください。
  d.BPR_Start関数とBPR_End関数は、必ず対で使用してください。BPR_Start関数で
    異常終了した場合は、BPR_End関数を使用する必要はありません。
  e.BPR_Print関数は、BPR_Start関数とBPR_End関数の間で使用してください。
  f.BPR_xx2xx関数は、BPR_Select関数のあとであればどの時点でも使用可能です。
    通常BPR_Start関数の前で使用します。
  g.API関数の実行順序は以下のとおりです。
     1)プリンタの選択(BPR_Select 関数) 
       2)作業領域サイズの取得(BPR_GetSize 関数) 
     ( 2)印刷中止判別関数の登録(BPR_SetFunc 関数) ) 
       2)単位系の変換(BPR_xx2xx)
       2)印刷の開始(BPR_Start 関数) 
           3)印刷の実行(BPR_Print 関数) 
                  〜
           3)印刷の実行(BPR_Print 関数) 
     2)印刷の終了(BPR_End 関数) 

 (2)異常終了
  a.API関数が異常終了した場合はマクロBPRDEVERRにその詳細内容を設定します。
  b.外部関数BPRDEVERRの設定内容は｢3.1 ヘッダファイル (3)異常詳細情報｣
    を参照してください。

3.4 各関数の解説

-----------------------------------------------------------------------------
.BPR_char2dot
単位系の変換(桁数/ANK文字→ドット数)
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_char2dot(unsigned int ch);
unsigned int  ch;     /*  変換する値をANK文字の桁数で指定します   */ 
                      /*  ( 有効範囲  0〜1000 )                   */ 

- 戻り値 -
 n :変換結果のドット数(少数点以下は切り捨て)
-1 :異常終了

- 内容 -
指定された桁数(ANK文字単位)をプリンタ上の印刷ドット数に変換します。
戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.BPR_dot2char
単位系の変換(ドット→桁数)
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_dot2char(unsigned int dot);
unsigned int  dot;  /*  変換するドット数を指定します   */ 
                    /*  ( 有効範囲  0〜10000 )         */ 

- 戻り値 -
 n :変換結果の値
-1 :異常終了

- 内容 -
指定された印刷ドット数を桁数(ANK文字単位)に変換します。
戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.BPR_dot2inch
単位系の変換(ドット数→インチ)
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_dot2inch(unsigned int dot); 
unsigned int  dot;  /*  変換するドット数を指定します   */ 
                    /*  ( 有効範囲  0〜10000 )         */ 

- 戻り値 -
 n :変換結果の値
-1 :異常終了

- 内容 -
指定された印刷ドット数を1/10インチ単位の値に変換します。
戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.BPR_dot2line
単位系の変換(ドット数→行数)
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_dot2line(unsigned int dot);
unsigned int  dot;  /*  変換するドット数を指定します   */ 
                    /*    ( 有効範囲  0〜10000 )       */ 

- 戻り値 -
n :変換結果の値

- 内容 -
指定された印刷ドット数を行数(ANK文字単位)に変換します。
戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.BPR_dot2mm
単位系の変換(ドット数→ミリメートル)
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_dot2mm(unsigned int dot);
unsigned int  dot;  /*  変換するドット数を指定します   */ 
                    /*  ( 有効範囲  0〜10000 )         */ 

- 戻り値 -
 n :変換結果の値
-1 :異常終了

- 内容 -
指定された印刷ドット数をミリメートル単位の値に変換します。
戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.BPR_End 
印刷の終了
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_End(void);

- 戻り値 -
 0 :正常終了
-1 :異常終了

- 内容 -
作業領域に展開されたビットマップデータの未出力分をプリンタに出力します。
プリンタの終了コマンドをプリンタに出力します。
戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.BPR_GetSize 
作業領域サイズの取得
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_GetSize(BPR_Work *work);
BPR_Work   *work;   /*  作業領域情報へのアドレス */ 

- 戻り値 -
 0 :正常終了
-1 :異常終了

- 内容 -
BPR_Select関数により指定した出力要求情報に従って、プリンタドライバで使用する
各作業領域の必要最低限のサイズを算出し、workで示す領域に返します。
  ･戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。
  ･以下のメンバーに設定を行います。
    - パレット用作業領域のサイズ(ビットマップ種別により変化します)
    - データ変換用内部作業領域のサイズ
    - データ変換用出力作業領域のサイズ
    - データ変換用情報保持作業領域のサイズ
    - 印刷用作業領域のサイズ
  ･この関数は必要最低限の領域サイズの通知を行う関数であり、領域の獲得は行いま
   せん。領域の獲得は各自で行ってください。

-----------------------------------------------------------------------------
.BPR_inch2dot
単位系の変換(インチ→ドット数)
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_inch2dot(unsigned int inch);
unsigned int  inch;   /*  変換する値を1/10インチで指定します */ 
                      /*  ( 有効範囲  0〜1000 )              */ 

- 戻り値 -
 n :変換結果のドット数(少数点以下は切り捨て)
-1 :異常終了

- 内容 -
指定された長さ(1/10インチ単位)をプリンタ上の印刷ドット数に変換します。
戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.BPR_line2dot
単位系の変換(行数/ANK文字→ドット数)
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_line2dot(unsigned int line);
unsigned int  line;   /*  変換する値をANK文字の行数で指定します */
                      /*  ( 有効範囲  0〜1000 )                 */

- 戻り値 -
 n :変換結果のドット数(少数点以下は切り捨て)
-1 :異常終了

- 内容 -
指定された行数(ANK文字単位)をプリンタ上の印刷ドット数に変換します。
戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.BPR_mm2dot
単位系の変換(ミリメートル→ドット数)
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_mm2dot(unsigned int mm);
unsigned int  mm;     /*  変換する値をミリメートルで指定します */ 
                      /*  ( 有効範囲  0〜1000 )                */ 

- 戻り値 -
 n :変換結果のドット数(少数点以下は切り捨て)
-1 :異常終了

- 内容 -
指定された長さ(ミリメートル単位)をプリンタ上の印刷ドット数に変換します。
戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.BPR_Print 
印刷の実行
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_Print(unsigned line, void *buff); 
unsigned int  line;   /*  印刷するビットマップの行数   */ 
void   *buff;         /*  ビットマップ情報へのアドレス */ 

- 戻り値 -
 1 :中止要求により終了
 0 :正常終了
-1 :異常終了

- 内容 -
今回指定されたビットマップデータを出力します。
  ･戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。
  ･ビットマップデータの形式は｢3.2 入力データの形式｣を参照してください。
  ･指定するビットマップデータはライン単位で設定してください。

-----------------------------------------------------------------------------
.BPR_Select
プリンタの選択
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_Select(unsigned short num, BPR_Into *into, BPR_Buff *buff);
unsigned short num;   /*  プリンタの選択番号                  */
                      /* (0:システム選択 or Ｎ:個別選択  )    */
BPR_Info     *info;   /*  出力要求情報のアドレス              */
BPR_Buff     *buff;   /*  スクリプト情報アクセス用作業領域情報
                          のアドレス                          */

- 戻り値 -
 0 :正常終了
-1 :異常終了

- 内容 -
プリンタドライバに対して出力プリンタの指定を行います。
出力要求情報に従って内部情報を初期化します。
  ･プリンタの選択番号は、0(システム選択)固定です。
  ･出力要求情報の設定方法は、｢3.1 ヘッダファイル (2)出力要求情報｣を参照してく
   ださい。

出力要求情報の印刷開始位置(TopSpace､LeftSpace)は、この時点で指定する必要はあ
りません。(BPR_Start関数で指定してください)
  ･戻り値が異常終了の場合BPRDEVERRに異常詳細情報を設定します。
  ･この関数は以降の関数を使用する前に必ず実行してください。
  ･指定した作業領域は内部の作業用として使用するため内容を変更しないでください
   。
  ･指定した作業領域はBPR_End関数を実行するまで解放しないでください。
  ･スクリプト情報アクセス用作業領域のサイズの最小値はBPR_BUFFSIZEで定義されて
   います。
  ･作業領域のサイズが大きいほど性能は向上します。

-----------------------------------------------------------------------------
.BPR_SetFunc 
印刷中止判別関数の登録
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_SetFunc((*func)()); 
int   (*func)();  /*  印刷中止判別関数のアドレス     */ 

- 戻り値 -
 0 :正常終了
-1 :異常終了

- 内容 -
印刷中止判別関数を登録します。この登録関数の戻り値が-1の場合は印刷処理を中止
します。未登録の場合は中止判別は行いません。
戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.BPR_Start 
印刷の開始
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   BPR_Start(unsigned int top, unsigned int left, BPR_Work *work);
unsigned int  top;  /*  印刷開始位置( 行 )をドット数で指定します */ 
unsigned int  left; /*  印刷開始位置( 桁 )をドット数で指定します */ 
BPR_Work  *work;    /*  作業領域情報へのアドレス                 */ 

- 戻り値 -
 0 :正常終了
-1 :異常終了

- 内容 -
BPR_Select関数により指定した出力要求情報に従ってプリンタを初期化します。
指定された内部処理用の作業領域情報を保持します。
  ･戻り値が異常終了の場合はBPRDEVERRに異常詳細情報を設定します。
  ･指定した作業領域は、内部の作業用として使用するため内容を変更しないでくださ
   い。
  ･指定した作業領域はBPR_End関数を実行するまで解放しないでください。
  ･作業領域のサイズが大きいほど性能は向上します。

3.5 サンプルプログラム

  サンプルプログラムは、指定したTIFFの内容をプリンタに印刷するものです。
  実行にあたっては、あらかじめ『システム設定』でプリンタ機種を設定しておいて
ください。プログラムの実行方法は、コマンドモードを起動したのち以下のコマンド
を入力します。
┌────────────────────────────────────┐
│x:RUN386 y:TIFPRN1.EXP TIFFファイル名 開始行 終了行 カラー指定 拡大指定 │
└────────────────────────────────────┘
  ファイル名:印刷したいTIFFファイルのファイル名をフルパス形式で指定します。
  開始行    :TIFFファイル内の実際に印刷を開始する行を指定します。
  終了行    :TIFFファイル内で印刷を終了する行を指定します。
  カラー指定:カラープリンタのときのみ有効で、強制的にモノクロ印刷をさせると
             きに指定します。
               0=モノクロ印刷
               1=カラー印刷
  拡大指定  :32768色TIFFデータが指定されたときのみ有効で、4倍拡大印刷をさせ
             るときに指定します。
               0=通常印刷
               1=拡大印刷

┌────────────────────────────────────┐
│  プリンタドライバライブラリ  サンプルプログラム   1                    │
│  ■  機能  ■                                                          │
│    指定されたＴIＦＦの内容をプリンタに印刷します。                     │
└────────────────────────────────────┘

/* TIFFファイルを印刷するプログラム(PRINTER.DLLを使用)  */

#include <stdio.h>
#include <stdlib.h>
#include <tifflib.h>
#include <bprdev.h>
#include <xld.h>

/* ライブラリから呼ばれる，バッファに対する操作の関数です */ 
/* ユーザ側で用意して，登録しておいてください             */ 
int read_data() ;
int put_data() ;
void wait(void);

static int  start_line;
static int  end_line;
static int  now_line;
static char palt[ 256*8+4 ];
static FILE *fp;
static int  x,y;
static int  bpp;
static char *lbp,*dbp,*cbuf,*obuf;

main(ac,av)
    unsigned int    ac;
             char   **av;
  {
    int                     rc;
    BPR_Info      info;
    BPR_Buff      buff;
    BPR_Work      work;
    char          work1[BPR_BUFFSIZE];
    int           lbsize,dbsize,d_line ;
    int           comp,fill ;
    long          strip, clut, dw ;
    int           color;

    _XLD_init(0);
    _XLD_setMemFunc( malloc, free );

    memset(&info.rsv,'\0',sizeof(info.rsv));
    printf("\n");
    if( ac < 4 )
    {
        printf("\n");
        printf("%s FileName StartLine EndLine Type Mags Mode1 \n",av[0]);
        printf("    FileName ---> TIFF file Name\n");
        printf("    StartLine --> Print Start Line Number\n");
        printf("    EndLine ----> Print End Line Number( Start < End )\n");
        printf("    Type -------> Print Color Type (0:Mono 1:Color)\n");
        printf("    Mags -------> Expand Mode (0:OFF 1:ON)\n");
        wait();
        return  0;
    }

    start_line = atoi(av[2]);
    end_line   = atoi(av[3]);
    color      = 0;
    if( ac>=5 )
    {
        color = atoi(av[4]);
    }
    if( start_line > end_line )
    {
        printf("ERROR!! --> 印刷開始行が印刷終了行より大きい\n");
        wait();
        return  0;
    }

    d_line = 3;                 /* バッファ中の行数           */ 
    lbsize = 4 * 1024 * d_line; /* それぞれのバッファのサイズ */ 
    dbsize = 4 * 1024 * d_line; /*                            */ 
    lbp = malloc( lbsize ) ;    /* ロードバッファ             */ 
    dbp = malloc( dbsize ) ;    /* 展開バッファ               */ 
    cbuf= malloc( 16 * 1024 ) ; /* 圧縮伸長用作業バッファ     */ 
    obuf= malloc( dbsize );     /* 印刷用バッファ             */ 
    if( (fp = fopen( av[1], "rb" )) == NULL ) /* ファイルオープン */ 
    {
        printf("ERROR!! --> TIFFファイルオープンエラー\n");
        wait();
        return   -1;
    }
    fread( lbp, 1, lbsize, fp ) ;   /* 最初のデータロード */
    
    /* ヘッダの解析 */
    if( TIFF_getHead( lbp, lbsize ) < 0 )
    {
        printf("ERROR!! --> TIFFヘッダ異常\n");
        wait();
        return   -1;
    }
    /* タグの内容のチェック */
    if( ( bpp = TIFF_checkMode( &x,&y,&comp,&fill,&strip,&clut )) < 0 ) 
    {
        printf("ERROR!! --> TIFFタグ異常\n");
        wait();
        return   -1;
    }
    /* バッファ操作関数の登録 */
    TIFF_setLoadFunc(  put_data, read_data ) ;

    dw = x ;
    if( bpp == 4)                  /* 16色はバウンダリの調整をします */ 
    {
        dw = ((dw+7)/8)*8;
    }
    /* パレットの設定 */
    if( clut != 0 )
    {
        TIFF_getPal( palt ) ;
    }

    if( bpp == 1 )
    {
        info.Density = 90;
        printf("  2値データ  x = %d   y = %d \n",x,y);
        info.BitType = BPR_MONO;
    }
    else if( bpp == 4 )
    {
        info.Density = 90;
        printf("  16色データ  x = %d   y = %d \n",x,y);
        info.BitType = BPR_16;

        info.Palette = palt;
    }
    else if( bpp == 8 )
    {
        info.Density = 90;
        printf("  256色データ  x = %d   y = %d \n",x,y);
        info.BitType = BPR_256;
        info.Palette = palt;
    }
    else if( bpp == 16 )
    {
        info.Density = 90;
        if( ac>=6 )
        {
            if( *(av[5]) == '1' )
            info.Density = 45;
        }
        printf("  32Ｋ色データ  x = %d   y = %d \n",x,y);
        info.BitType = BPR_32K;
    }
    else if( bpp == 24 )
    {
        info.Density = 90;
        printf("  16Ｍ色データ  x = %d   y = %d \n",x,y);
        info.BitType = BPR_16M;
    }
    else
    {
        printf("ERROR!! --> TIFFファイルの形式が違います\n");
        wait();
        return  0;
    }
    info.Width   = x;
    info.Height  = end_line - start_line;
    if( color == 1 )
        info.ColorType = BPR_COLOR;
    else
        info.ColorType = BPR_MONO;
    info.Reverse = BPR_NORMAL;
    buff.BuffSize = BPR_BUFFSIZE;
    buff.BuffAddr = work1;

    rc = BPR_Select( 0,&info,&buff );
    if( rc < 0 )
    {
        printf("--BPR_Select ERROR!!  %x--\n",BPRDEVERR);
        wait();
        return  0;
    }
    rc = BPR_GetSize( &work );
    if( rc < 0 )
    {
        printf("--BPR_GetSize  ERROR!! %x--\n",BPRDEVERR);
        wait();

        return  0;
    }
    if( work.Work1.BuffSize != 0 )
        work.Work1.BuffAddr = malloc( work.Work1.BuffSize );
    work.Work2.BuffAddr = malloc( work.Work2.BuffSize );
    work.Work3.BuffAddr = malloc( work.Work3.BuffSize );
    work.Work4.BuffAddr = malloc( work.Work4.BuffSize );
    work.Work5.BuffAddr = malloc( work.Work5.BuffSize );

    rc = BPR_Start( 180,24,&work );
    if( rc < 0 )
    {
        printf("--BPR_Start ERROR!! %x--\n",BPRDEVERR);
        wait();
        return  0;
    }
    now_line = 0;
    TIFF_loadImage(bpp,x,y,strip,fill,comp,dbp,dw,d_line,cbuf ) ;
    rc = BPR_End();
    if( rc < 0 )
        printf("--BPR_End ERROR!! %x--\n",BPRDEVERR);
    wait();
    return  0;
}

/* バッファにデータをロードします                   */
/*    ファイルからロードする場合は freadを使います  */
read_data( bp, size )
char *bp ;
int size ;
{
    fread( bp, 1, size, fp ) ;
    return 0 ;
}

/* 展開されたものを印刷します */
put_data( buf, lofs, lines )
char *buf ;
int lofs, lines ;
{
    int i,j,max,rc;

/*-- 展開されたTIFFデータを出力バッファに複写します -------------*/
    switch(bpp)
    {
        case 1: /*-- 2値 ----------------------*/
            max = ((x+7)/8) * lines;
            i=j=0;
            while(i<max)
                obuf[j++] = buf[i++];
            break;
        case 4: /*-- 16色 --------------------*/
            max = (((x+7)/8)*4) * lines;
            i=j=0;
            while(i<max)
                obuf[j++] = buf[i++];
            break;
        case 8: /*-- 256色 ------------------*/
            max = x * lines;
            i=j=0;
            while(i<max)
                obuf[j++] = buf[i++];
            break;
        case 16:/*-- 32Ｋ色 ------------------*/
            max = x * 2 * lines;
            i=j=0;
            while(i<max)
                obuf[j++] = buf[i++];
            break;
        case 24:/*-- 16Ｍ値 ------------------*/
            max = x * 3 * lines;
            i=j=0;
            while(i<max)
            {
                obuf[j++] = buf[i++];
                obuf[j++] = buf[i++];
                obuf[j++] = buf[i++];
                obuf[j++] = 0;
            }
            break;
        deault:
            printf("TIFFのデータ種別が異常\n");
            return  -1;
    }
    if( now_line >= start_line )
    {
        rc = BPR_Print(lines,obuf);
        if( rc < 0 )
        {
            printf("--BPR_Print ERROR!! %x--\n",BPRDEVERR);
            wait();
            return  -1;
        }
    }
    now_line += lines;
    if( now_line > end_line )
        return  -1;
    return 0 ;
}
void wait(void)
{
    printf("任意のキーを押して下さい...");
    getchar();
    return;
}

4 スクリプト情報アクセス機能

  ここでは、スクリプト情報をアクセスするための機能について解説します。

4.1 概要

  スクリプト情報アクセス機能には以下のものがあります。
    (1)アクセス開始宣言
    (2)プリンタの指定
    (3)キー情報の取り出し

 (1)アクセス開始宣言
  a.スクリプト情報をアクセスするための宣言を行います。
  b.スクリプト情報アクセス機能ルーチンに対して以下の指定を行います。
    ･スクリプト情報ファイル名の指定
    ･スクリプト情報アクセス機能で使用する作業領域のアドレスとサイズの指定

 (2)プリンタの指定
  a.(1)のアクセス開始宣言で指定したスクリプト情報ファイル内のどのスクリプ
    ト情報を使用するかをインデックス番号で指定します。
  b.インデックス番号はスクリプト情報ファイル内の各スクリプト情報に振られ
    た通し番号です。

 (3)キー情報の取り出し
  a.スクリプト情報に記述されているキー情報を取り出します。

4.2 ヘッダファイル

  スクリプト情報アクセス機能で使用する構造体及び値の宣言を以下に示します。
  "bprdev.h"に定義されています。

 (1)異常詳細情報
    外部変数名unsigned int LPTSPLERRに設定されます。

  a.スクリプト情報アクセス異常時
      LPT_ACCESS     0x11   ファイルのアクセスに失敗しました
      LPT_NOFILE     0x12   ファイルが見つかりません
      LPT_NODATA     0x13   スクリプト情報がありません
      LPT_NOKEY      0x14   必要情報が未定義です
      LPT_FORMAT     0x15   定義形式が異常です
      LPT_SPLERR     0x1f   その他の異常です

  b.その他の異常時
      LPT_CALLSEQ    0x91   呼び出し順序の異常
      LPT_PARAM      0x92   入力パラメータの異常
      LPT_ETCERR     0x9f   その他の異常

  c.エラー種別のマスク
      LPT_SPLMASK    0x10   スクリプト情報異常
      LPT_ETCMASK    0x90   その他の異常

4.3 LPTインタフェース関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│LPT_Init                  │アクセス開始宣言                          │
├─────────────┼─────────────────────┤
│LPT_Select                │プリンタの指定                            │
├─────────────┼─────────────────────┤
│LPT_GetKey                │定義情報の取り出し                        │
└─────────────┴─────────────────────┘

 (1)実行順序
  a.LPT_Init関数はその他の関数の使用に先立って必ず実行してください。
  b.以下のアクセス関数はLPT_Select関数実行後に使用してください。
      - LPT_GetKey関数
  c.スクリプト情報アクセス関数の実行順序は、以下のとおりです。
     1)アクセス開始宣言(LPT_Init関数) 
       2)プリンタ指定(LPT_Select関数) 
          3)アクセス関数
              ･
              ･
          3)アクセス関数
       2)プリンタ指定(LPT_Select関数) 
              ･
       2)プリンタ指定(LPT_Select関数) 
          3)アクセス関数
     1)アクセス開始宣言(LPT_Init関数) 

 (2)異常終了
  a.スクリプト情報アクセス関数が異常終了した場合はint型のマクロLPTSPLERRにそ
    の詳細内容を設定します。
  b.設定される値は｢4.2 ヘッダファイル｣を参照してください。

4.4 各関数の解説

-----------------------------------------------------------------------------
.LPT_GetKey
定義情報の取り出し
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   LPT_GetKey(char *keyword, void *buff);
char  *keyword;  /* 検索キー( 情報名 )の文字列のアドレス */ 
void  *buff;     /* 検索結果情報の設定領域へのアドレス   */ 
                 /* NULL時は返却しません                 */ 

- 戻り値 -
 n :設定情報のバイト数(*buffに設定した情報のサイズ) 
-1 :異常終了

- 内容 -
指定された検索キー対応の定義情報を指定領域に設定します。
返却域のアドレスにNULLを指定した場合は定義情報のバイト数のみ返却します。
定義情報が文字列の場合は、終端にはNULLは設定されません。
定義情報が値の場合は設定域にダブルワードで設定します。

  aaa = "\x1b\x00aa"
  bbb = "bb"
  ccc = 256 
  ddd = aaa,bbb 

                      ┌─┬─┬─┬─┬─〜─┐
  aaa の設定内容      │1b│00│41│41│      │          戻り値 4
                      └─┴─┴─┴─┴─〜─┘
                      ┌─┬─┬─┬─┬─〜─┐
  ccc の設定内容      │00│01│00│00│      │          戻り値 4
                      └─┴─┴─┴─┴─〜─┘
                      ┌─┬─┬─┬─┬─┬─┬─〜─┐
  ddd の設定内容      │1b│00│41│41│42│42│      │  戻り値 6
                      └─┴─┴─┴─┴─┴─┴─〜─┘

  ･戻り値が異常終了の場合はLPTSPLERRに異常詳細情報を設定します。
  ･検索キーの文字列はNULL終端とします。
  ･設定域の大きさは充分確保しておいてください。

-----------------------------------------------------------------------------
.LPT_Init
アクセス開始宣言
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   LPT_Init(cher *frome, void *work, unsigned int size); 
char *fname;          /*  スクリプト情報ファイル名            */
                      /*  ( フルパス名  NULL終端 )のアドレス  */
void *work;           /*  作業領域のアドレス                  */
unsigned int  size;   /*  作業領域の大きさ                    */
                      /*  (バイト数/最小値 LPT_BUFFSIZE )     */

- 戻り値 -
 n :スクリプト情報の定義数(0 ≦ n)
-1 :異常終了

- 内容 -
スクリプト情報のアクセス管理情報の初期化を行います。また、スクリプト情報ファ
イルの存在を検査し、定義されているスクリプト情報の数を抽出します。
  ･戻り値が異常終了の場合はLPTSPLERRに異常詳細情報を設定します。
  ･作業領域のバイト数が大きいほどスクリプト情報のアクセス関数の性能は向上しま
   す。
  ･スクリプト情報ファイル名はNULL終端としてください。
  ･この関数はスクリプト情報のアクセスに先立って実行してください。

-----------------------------------------------------------------------------
.LPT_Select
プリンタの指定
-----------------------------------------------------------------------------

- 定義 -
#include <bprdev.h> 
int   LPT_Select(unsigned short index); 
unsigned short  index;    /*  スクリプト情報のインデックス番号 */ 

- 戻り値 -
 0 :正常終了
-1 :異常終了

- 内容 -
アクセス機能に対して使用するプリンタを指定します。
指定されたインデックス番号対応のスクリプト情報の管理情報を設定します。
戻り値が異常終了の場合はLPTSPLERRに異常詳細情報を設定します。


5 IPU用API部

  ここでは、IPU(PIXEL JET)用API部の機能について解説します。

5.1 概要

  IPU用API部の機能には以下のものがあります。
   (1)IPUプリンタの選択
   (2)作業領域サイズの取得
   (3)単位系の変換
   (4)ビットマップ印刷の開始
   (5)ビットマップ印刷の実行
   (6)ビットマップ印刷の終了

 (1)IPUプリンタの選択
  a.プリンタドライバに対して出力するプリンタを指定します。
  b.プリンタドライバを使用するに先立って必ず実行する必要があります。

 (2)作業領域サイズの取得
  a.プリンタドライバが必要とする各作業領域の必要最低限のサイズを取得します。
  b.この関数により取得したサイズのメモリを確保する必要があります。

 (3)単位系の変換
  a.現在選択中のプリンタに対応する単位系の変換を行います。

 (4)ビットマップ印刷の開始
  a.プリンタドライバに対して作業領域を指定します。
  b.現在選択中のプリンタを初期化します。

 (5)ビットマップ印刷の実行
  a.プリンタドライバに対してビットマップデータを出力します。
  b.ビットマップデータの形式は｢3.4 プリンタインタフェース関数一覧｣を参照して
    ください。

 (6)ビットマップ印刷の終了
  a.プリンタドライバに対して印刷の終了指示を行います。

5.2 ヘッダファイル

  IPU用APIで使用する構造体及び値の宣言を以下に示します。
  "ipudev.h"に定義されています。

 (1)作業領域情報

    typedef struct
       {
        void           *BuffAddr;  作業領域のアドレス
        unsigned int    BuffSize;  作業領域のサイズ( バイト数 )
        }IPU_Buff; 

  a.作業領域のアドレス
    獲得した作業領域の先頭アドレスを管理します。

  b.作業領域のサイズ
    獲得した作業領域のサイズをバイト数で管理します。

 (2)出力要求情報

    typedef struct
       {
        unsigned short  BitType;       ビットマップ種別
        unsigned short  Density;       ビットマップの画素密度
        unsigned short  Width;         ビットマップのサイズ( 横ドット数 )
        unsigned short  Height;        ビットマップのサイズ( 縦ドット数 )
        void           *Palette;       パレット情報へのアドレス
        unsigned short  rsv[26];       システム予約
        }IPU_Info; 

  a.ビットマップ種別
    印刷するビットマップの種別を指定します。
      IPU_MONO     1    モノクロ(2色)
      IPU_16       2    4096色中16色
      IPU_256      3    16M色中256色
      IPU_32K      4    32K色
      IPU_16M      5    16M色

  b.ビットマップの画素密度
    印刷するビットマップの画素密度を指定します。
    プリンタの画素密度ではありません。

  c.ビットマップのサイズ
    印刷するビットマップのサイズ(縦、横)をドット数で指定します。
    指定可能な範囲は以下のとおりです。
      横のサイズ  IPU_MIN_WIDTH  ≦ Width  ≦ IPU_MAX_WIDTH 
      縦のサイズ  IPU_MIN_HEIGHT ≦ Height ≦ IPU_MAX_HEIGHT

  d.パレット情報へのアドレス
    TBIOS形式のパレット情報へのアドレスを指定します。不要時はNULLを指定してく
    ださい。ビットマップ種別が以下のときは必ず指定してください。
      IPU_16       2    4096色中16色
      IPU_256      3    16M色中256色

  e.rsvシステム予約
    必ず0を設定してください。

 (3)異常詳細情報
    マクロIPUDEVERRに設定されます。

  a.SCSIアクセス異常時
      IPU_BUSBUSY    0x31   SCSIバスビジー
      IPU_NOTCON     0x32   SCSIに接続されていません
      IPU_SCSIERR    0x3F   その他のSCSI異常

  b.プリンタ出力異常時
      IPU_NOTREADY   0x41   ノットレディ
      IPU_NOTPAPER   0x42   紙切れ/ インク切れ
      IPU_IPUBUSY    0x43   IPU 使用中
      IPU_NOIPU      0x44   IPU がない/IPU以外
      IPU_IPUERR     0x4f   その他のIPU 異常

  c.その他の異常時
      IPU_CALLSEQ    0x91   呼び出し順序の異常
      IPU_PARAM      0x92   入力パラメータの異常
      IPU_NOMEM      0x93   リアル空間メモリが確保できません
      IPU_ETCERR     0x9f   その他の異常

  d.エラー種別のマスク
      IPU_SCSMASK    0x30   SCSI異常
      IPU_IPUMASK    0x40   IPU異常
      IPU_ETCMASK    0x90   その他の異常

5.3 IPUインタフェース関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│IPU_BjSelect              │プリンタの選択                            │
├─────────────┼─────────────────────┤
│IPU_BjStart               │印刷の開始                                │
├─────────────┼─────────────────────┤
│IPU_BjPrint               │印刷の実行                                │
├─────────────┼─────────────────────┤
│IPU_BjEnd                 │印刷の終了                                │
├─────────────┼─────────────────────┤
│IPU_BjGetSize             │作業領域サイズの取得                      │
├─────────────┼─────────────────────┤
│IPU_inch2dot              │単位系の変換( インチ→ドット数 )          │
├─────────────┼─────────────────────┤
│IPU_mm2dot                │単位系の変換( ミリメートル→ドット数 )    │
├─────────────┼─────────────────────┤
│IPU_char2dot              │単位系の変換( 桁数/ANK文字→ドット数 )    │
├─────────────┼─────────────────────┤
│IPU_line2dot              │単位系の変換( 行数/ANK文字→ドット数 )    │
├─────────────┼─────────────────────┤
│IPU_dot2inch              │単位系の変換( ドット数→インチ )          │
├─────────────┼─────────────────────┤
│IPU_dot2mm                │単位系の変換( ドット数→ミリメートル )    │
├─────────────┼─────────────────────┤
│IPU_dot2char              │単位系の変換( ドット数→桁数/ANK文字 )    │
├─────────────┼─────────────────────┤
│IPU_dot2line              │単位系の変換( ドット数→行数/ANK文字 )    │
└─────────────┴─────────────────────┘

 (1)実行順序
  a.IPU_BjGetSize関数、IPU_xx2xx関数はIPU-BjSelect関数以前で実行します。
  b.IPU_BjSelect関数は以下の関数の使用に先立って必ず実行してください。
    ･ビットマップ印刷の開始   (IPU_BjStart関数) 
    ･ビットマップ印刷の実行   (IPU_BjPrint関数) 
    ･ビットマップ印刷の終了   (IPU_BjEnd関数) 
  c.IPU_BjStart関数とIPU_BjEnd関数は必ず対で使用してください。
    IPU_BjStart関数で異常終了した場合はIPU_BjEnd関数を使用する必要はありま
    せん。
  d.IPU_BjPrint関数はIPU_BjStart関数とIPU_BjEnd関数の間で使用してください。
  e.API関数の実行順序は以下のとおりです。
     1)作業領域サイズの取得(IPU_BjGetSize関数) 
     1)単位系の変換(IPU_xx2xx)
     1)プリンタの選択 (IPU_BjSelect関数) 
         2)印刷の開始(IPU_BjStart関数) 
           3)印刷の実行(IPU_BjPrint関数) 
                      〜
           3)印刷の実行(IPU_BjPrint関数) 
         2)印刷の終了(IPU_BjEnd関数) 

 (2)異常終了
  a.API関数が異常終了した場合、マクロIPUDEVERRにその詳細内容を設定します。
  b.外部変数IPUDEVERRの設定内容は｢5.2 ヘッダファイル 3)異常詳細情報｣を参照し
    てください。

5.4 各関数の解説

-----------------------------------------------------------------------------
.IPU_BjEnd
印刷の終了
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_BjEnd(void);

- 戻り値 -
 0 :正常終了
-1 :異常終了

- 内容 -
作業領域に展開されたビットマップデータの未出力分をプリンタに出力します。
プリンタの終了コマンドをプリンタに出力します。
戻り値が異常終了の場合はIPUDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.IPU_BjGetSize 
作業領域サイズの取得
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_BjGetSize(unsigned short type, unsigned short width); 
unsigned short type;  /*  ビットマップ種別                      */
unsigned short width; /*  ビットマップの横サイズ( ドット数 )    */

- 戻り値 -
 n :必要な作業領域のサイズ(バイト数)
-1 :異常終了

- 内容 -
入力情報により指定したビットマップ情報に従ってプリンタドライバで使用します。
各作業領域の必要最低限のサイズを算出し返します。
  ･戻り値が異常終了の場合はIPUDEVERRに異常詳細情報を設定します。
  ･この関数は必要最低限の領域サイズの通知を行う関数であり、領域の獲得は行いま
   せん。領域の獲得は各自で行ってください。

-----------------------------------------------------------------------------
.IPU_BjPrint 
印刷の実行
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_BjPrint(unsigned int line, void *buff); 
unsigned int  line;   /*  印刷するビットマップの行数    */
void *buff;           /*  ビットマップ情報へのアドレス  */

- 戻り値 -
 0 :正常終了
-1 :異常終了

- 内容 -
今回指定されたビットマップデータを出力します。
  ･戻り値が異常終了の場合はIPUDEVERRに異常詳細情報を設定します。
  ･ビットマップデータの形式は、｢3.4 プリンタインタフェース関数一覧｣を参照して
   ください。
  ･指定するビットマップデータはライン単位で設定してください。

-----------------------------------------------------------------------------
.IPU_BjSelect
プリンタの選択
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_BjSelect(unsigned short num, IPU_Info *info, IPU_Buff *buff);
unsigned short num; /*  プリンタの選択番号                    */
                    /*   (0:システム選択 or Ｎ:個別選択  )    */
IPU_Info   *info;   /*  出力要求情報のアドレス                */
IPU_Buff   *buff;   /*  出力処理用作業領域情報のアドレス      */

- 戻り値 -
 0 :正常終了
-1 :異常終了

- 内容 -
IPUドライバに対して出力プリンタの指定を行います。
出力要求情報に従って内部情報を初期化します。
  ･プリンタの選択番号は当面0(システム選択)固定とします。
  ･出力要求情報の設定方法は｢5.2 ヘッダファイル｣を参照してください。
  ･戻り値が異常終了の場合はIPUDEVERRに異常詳細情報を設定します。
  ･この関数は以降の関数を使用する前に必ず実行してください。
  ･指定した作業領域は内部の作業用として使用するため内容を変更しないでください
   。
  ･指定した作業領域はIPU_End関数を実行するまで解放しないでください。

-----------------------------------------------------------------------------
.IPU_BjStart 
印刷の開始
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_BjStart(unsigned int top, unsigned int left); 
unsigned int  top;  /*  印刷開始位置( 行 )をドット数で指定します  */
unsigned int  left; /*  印刷開始位置( 桁 )をドット数で指定します  */

- 戻り値 -
 0 :正常終了
-1 :異常終了

- 内容 -
IPU_BjSelect関数により指定した出力要求情報に従ってIPUを初期化します。
戻り値が異常終了の場合はIPUDEVERRに異常詳細情報を設定します。

-----------------------------------------------------------------------------
.IPU_char2dot
単位系の変換(桁数/ANK文字→ドット数)
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_char2dot(unsigned int ch);
unsigned int  ch; /*  変換する値をANK文字の桁数で指定します  */
                  /*  ( 有効範囲  0〜1000 )                  */

- 戻り値 -
 n :変換結果のドット数(少数点以下は切り捨て)
-1 :異常終了

- 内容 -
指定された桁数(ANK文字単位)をプリンタ上の印刷ドット数に変換します。

-----------------------------------------------------------------------------
.IPU_dot2char
単位系の変換(ドット数→桁数/ANK文字)
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_dot2char(unsigned int dot);
unsigned int  dot;  /*  変換するドット数を指定します    */
                    /* (有効範囲  0〜10000 )            */

- 戻り値 -
 n :変換結果の値
-1 :異常終了

- 内容 -
指定された印刷ドット数を桁数(ANK文字単位)に変換します。

-----------------------------------------------------------------------------
.IPU_dot2inch
単位系の変換(ドット数→インチ)
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_dot2inch(unsigned int dot); 
unsigned int  dot;  /*  変換するドット数を指定します    */
                    /*  ( 有効範囲  0〜10000 )          */

- 戻り値 -
 n :変換結果の値
-1 :異常終了

- 内容 -
指定された印刷ドット数を1/10インチ単位の値に変換します。

-----------------------------------------------------------------------------
.IPU_dot2line
単位系の変換(ドット数→行数/ANK文字)
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_dot2line(unsigned int dot);
unsigned int  dot;  /*  変換するドット数を指定します    */
                    /*  ( 有効範囲  0〜10000 )          */

- 戻り値 -
 n :変換結果の値
-1 :異常終了

- 内容 -
指定された印刷ドット数を行数(ANK文字単位)に変換します。

-----------------------------------------------------------------------------
.IPU_dot2mm
単位系の変換(ドット数→ミリメートル)
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_dot2mm(unsigned int dot);
unsigned int  dot;  /*  変換するドット数を指定します    */
                    /*  ( 有効範囲  0〜10000 )          */

- 戻り値 -
 n :変換結果の値
-1 :異常終了

- 内容 -
指定された印刷ドット数をミリメートル単位の値に変換します。

-----------------------------------------------------------------------------
.IPU_inch2dot
単位系の変換(インチ→ドット数)
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_inch2dot(unsigned int inch);
unsigned int  inch;   /*  変換する値を1/10インチで指定します  */
                      /*  ( 有効範囲  0〜1000 )               */

- 戻り値 -
 n :変換結果のドット数(少数点以下は切り捨て)
-1 :異常終了

- 内容 -
指定された長さ(1/10インチ単位)をプリンタ上の印刷ドット数に変換します。

-----------------------------------------------------------------------------
.IPU_line2dot
単位系の変換(行数/ANK文字→ドット数)
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_line2dot(unsigned int line);
unsigned int  line; /*  変換する値をANK文字の行数で指定します  */
                    /*  ( 有効範囲  0〜1000 )                  */

- 戻り値 -
 n :変換結果のドット数(少数点以下は切り捨て)
-1 :異常終了

- 内容 -
指定された行数(ANK文字単位)をプリンタ上の印刷ドット数に変換します。

-----------------------------------------------------------------------------
.IPU_mm2dot
単位系の変換(ミリメートル→ドット数)
-----------------------------------------------------------------------------

- 定義 -
#include <ipudev.h> 
int   IPU_mm2dot(unsigned int mm);
unsigned int  mm;     /*  変換する値をミリメートルで指定します  */
                      /*  ( 有効範囲  0〜1000 )                 */

- 戻り値 -
 n :変換結果のドット数(少数点以下は切り捨て)
-1 :異常終了

- 内容 -
指定された長さ(ミリメートル単位)をプリンタ上の印刷ドット数に変換します。


5.5 サンプルプログラム

  サンプルプログラムは、指定したTIFFの内容をプリンタに印刷するものです。
  実行にあたっては、あらかじめ『システム設定』でプリンタ機種を設定しておいて
ください。プログラムの実行方法は、コマンドモードを起動したのち以下のコマンド
を入力します。
┌────────────────────────────────────┐
│ x:RUN386 y:TIFPRN2.EXP TIFFファイル名                                  │
└────────────────────────────────────┘
  ファイル名:印刷したいTIFFファイルのファイル名をフルパス形式で指定します。

┌────────────────────────────────────┐
│  プリンタドライバライブラリ  サンプルプログラム   2                    │
│  ■  機能  ■                                                          │
│    指定されたＴIＦＦの内容をプリンタに印刷します。                     │
└────────────────────────────────────┘

/* TIFFファイルを印刷するプログラム(PRINTER.DLLを使用) */

#include <stdio.h>
#include <stdlib.h>

#include <tifflib.h>
#include <ipudev.h>
#include <xld.h>

/* ライブラリから呼ばれる，バッファに対する操作の関数 */
/* ユーザ側で用意して，登録しておく                   */
int read_data() ;
int put_data() ;
void wait(void);

static int  start_line;
static int  end_line;
static int  now_line;
static char palt[ 256*8+4 ];
static FILE *fp;
static int  x,y;
static int  bpp;
static char *lbp,*dbp,*cbuf,*obuf;

main(ac,av)
    unsigned int    ac;
             char   **av;

{
    int             rc;
    IPU_Info      info;
    IPU_Buff      buff;
    int             lbsize,dbsize,d_line ;
    int             comp,fill ;
    long            strip, clut, dw ;

    _XLD_init(0);
    _XLD_setMemFunc( malloc, free );

    printf("\n");

    d_line = 3;                 /* バッファ中の行数           */
    lbsize = 4 * 1024 * d_line; /* それぞれのバッファのサイズ */
    dbsize = 4 * 1024 * d_line; /*                            */
    lbp = malloc( lbsize ) ;    /* ロードバッファ             */
    dbp = malloc( dbsize ) ;    /* 展開バッファ               */
    cbuf= malloc( 16 * 1024 ) ; /* 圧縮伸長用作業バッファ     */
    obuf= malloc( dbsize );     /* 印刷用バッファ             */
    if( (fp = fopen( av[1], "rb" )) == NULL ) /* ファイルオープン */
    {
        printf("ERROR!! --> TIFFファイルオープンエラー\n");
        wait();
        return   -1;
    }
    fread( lbp, 1, lbsize, fp ) ;   /* 最初のデータロード */

    /* ヘッダの解析 */
    if( TIFF_getHead( lbp, lbsize ) < 0 )
    {
        printf("ERROR!! --> TIFFヘッダ異常\n");
        wait();
        return   -1;
    }
    /* タグの内容のチェック */
    if( ( bpp = TIFF_checkMode( &x,&y,&comp,&fill,&strip,&clut )) < 0 )
    {
        printf("ERROR!! --> TIFFタグ異常\n");
        wait();
        return   -1;
    }
    /* バッファ操作関数の登録 */
    TIFF_setLoadFunc(  put_data, read_data ) ;

    dw = x ;
    if( bpp == 4)                /* 16色はバウンダリの調整をする */
    {
        dw = ((dw+7)/8)*8;
    }

    /* パレットの設定 */
    if( clut != 0 )
    {
        TIFF_getPal( palt ) ;
    }

    if( bpp == 1 )
    {
        info.Density = 90;
        printf("  2値データ  x = %d   y = %d \n",x,y);
        info.BitType = IPU_MONO;
    }
    else if( bpp == 4 )
    {
        info.Density = 90;
        printf("  16色データ  x = %d   y = %d \n",x,y);
        info.BitType = IPU_16;
        info.Palette = palt;
    }
    else if( bpp == 8 )
    {
        info.Density = 90;
        printf("  256色データ  x = %d   y = %d \n",x,y);
        info.BitType = IPU_256;
        info.Palette = palt;
    }
    else if( bpp == 16 )
    {
        info.Density = 90;
        printf("  32Ｋ色データ  x = %d   y = %d \n",x,y);
        info.BitType = IPU_32K;
    }
    else if( bpp == 24 )
    {
        info.Density = 90;
        printf("  16Ｍ色データ  x = %d   y = %d \n",x,y);
        info.BitType = IPU_16M;
    }
    else
    {
        printf("ERROR!! --> TIFFファイルの形式が違う\n");
        wait();
        return  0;
    }
    start_line = 0;
    end_line   = y - 1;
    info.Width   = x;
    info.Height  = y;
    buff.BuffSize = IPU_BjGetSize(info.BitType,x);
    buff.BuffAddr = malloc( buff.BuffSize );
printf("-----IPU_BjSelect is RUN-------\n");
    rc = IPU_BjSelect( 0,&info,&buff );
    if( rc < 0 )
    {
        printf("--IPU_BjSelect ERROR!!  %x--\n",IPUDEVERR);
        wait();
        return  0;
    }
    printf("-----IPU_BjStart is RUN-------\n");
    rc = IPU_BjStart( 180,24 );
    if( rc < 0 )
    {
        printf("--IPU_BjStart ERROR!! %x--\n",IPUDEVERR);
        wait();
        return  0;
    }
    now_line = 0;
    printf("-----IPU_BjPrint is RUN-------\n");
    TIFF_loadImage(bpp,x,y,strip,fill,comp,dbp,dw,d_line,cbuf ) ;
    printf("-----IPU_BjEnd is RUN----------\n");
    rc = IPU_BjEnd();
    if( rc < 0 )
        printf("--IPU_BjEnd ERROR!! %x--\n",IPUDEVERR);
    wait();

    return  0;
}

/* バッファにデータをロードする                    */
/*    ファイルからロードする場合は freadだけでよい */ 
read_data( bp, size )
char *bp ;
int size ;
{
    fread( bp, 1, size, fp ) ;
    return 0 ;
}

/* 展開されたものを印刷する  */
put_data( buf, lofs, lines )
char *buf ;
int lofs, lines ;
{
    int     i,j,max,rc;

/*-- 展開されたTIFFデータを出力バッファに複写する -------------*/
    switch(bpp)
    {
        case 1: /*-- 2値 ----------------------*/
            max = ((x+7)/8) * lines;
            i=j=0;
            while(i<max)
                obuf[j++] = buf[i++];
            break;
        case 4: /*-- 16色 --------------------*/
            max = (((x+7)/8)*4) * lines;
            i=j=0;
            while(i<max)
                obuf[j++] = buf[i++];
            break;
        case 8: /*-- 256色 ------------------*/
            max = x * lines;
            i=j=0;
            while(i<max)
                obuf[j++] = buf[i++];
            break;
        case 16:/*-- 32Ｋ色 ------------------*/
            max = x * 2 * lines;
            i=j=0;
            while(i<max)
                obuf[j++] = buf[i++];
            break;
        case 24:/*-- 16Ｍ値 ------------------*/
            max = x * 3 * lines;
            i=j=0;
            while(i<max)
            {
                obuf[j++] = buf[i++];
                obuf[j++] = buf[i++];
                obuf[j++] = buf[i++];
                obuf[j++] = 0;
            }
            break;
        deault:
            printf("TIFFのデータ種別が変\n");
            return  -1;
    }
    if( now_line >= start_line )
    {
        rc = IPU_BjPrint(lines,obuf);
        if( rc < 0 )
        {
            printf("--IPU_BjPrint ERROR!! %x--\n",IPUDEVERR);
            wait();
            return  -1;
        }
    }
    now_line += lines;
    if( now_line > end_line )
        return  -1;
    return 0 ;
}
void wait(void)
{
    printf("任意のキーを押して下さい...");
    getchar();
    return;
}

*****************************************************************************
第13章  拡張フォント管理ライブラリ
*****************************************************************************

1 拡張フォント管理ライブラリについて

1.1 概要

  拡張フォント管理ライブラリは、アプリケーションに文字イメージやアウトライン
データ、フォント情報を提供します。このライブラリではFM TOWNS/IIシリーズの内蔵
ROMフォントやTownsシステムソフトウェアに添付の各種ドットフォント、別売のベク
トル文字パターンやベクトル文字パターンIIの各書体を使用することができます。
  また、このライブラリは、ダイナミックリンクライブラリとして提供します。ダイ
ナミックリンクライブラリをアプリケーションで利用する方法については｢第9章  ダ
イナミックリンクサポートライブラリ｣を参照してください。

1.2 注意事項

  このライブラリにてベクトル文字パターンまたはベクトル文字パターンIIを利用さ
せる場合にはICカードスロットに挿入してください。

1.3 著作権に関する注意

 (1)このライブラリを使用して取得した文字イメージおよびアウトラインデータは、
    各書体製品との使用権契約上、認められる範囲において使用することができます
    。

 (2)このライブラリを使用し、有償で頒布を目的とするアプリケーションや営利目的
    で使用するアプリケーションを作成される場合、文字イメージやアウトラインデ
    ータの全部または一部を、他のデータ集として作成する機能は提供しないでくだ
    さい。ただし、絵の一部またはデータの一部として、文字イメージや、アウトラ
    インデータが使用される場合はその限りではありません。

1.4 基本操作フロー

 (1)全体の処理手順概要

            ┌─────────────┐
            │  アプリケーション起動    │
            └──────┬──────┘
            ┌──────┴──────┐┐
            │  拡張フォント管理初期化  ││
            └──────┬──────┘│｢拡張ﾌｫﾝﾄ管理起動までの処理手順｣
            ┌──────┴──────┐│
            │      キャッシュ起動      ││ を参照してください。
            │                          ││
            │      初期化              ││
            └──────┬──────┘┘
            ┌──────┴──────┐
            │                          │  ｢論理フォント設定の処理手順｣
            │    論理フォントの設定    │
            │                          │   を参照してください。
            └──────┬──────┘
┌───────────→│
│          ┌──────┴──────┐  ｢ﾌｫﾝﾄ選択までの処理手順｣と
│          │                          │
│          │      フォント選択        │  ｢ﾌｫﾝﾄ名からﾌｫﾝﾄ選択の手順｣
│          │                          │
│          └──────┬──────┘  を参照してください。
│  ┌─────────→│
│  │      ┌──────┴──────┐
│  │      │                          │  ｢修飾機能設定までの処理手順｣
│  │      │  修飾機能パラメータ設定  │
│  │      │                          │  を参照してください。
│  │      └──────┬──────┘
│  │  ┌───────→│
│  │  │  ┌──────┴──────┐┐
│  │  │  │    文字イメージ取得      ││
│  │  │  └─────────────┘│ ｢文字ｲﾒｰｼﾞ取得･描画の処理手順｣
│  │  │  ┌─────────────┐│
│  │  │  │      文字の画面描画      ││ を参照してください。
│  │  │  └──────┬──────┘┘
└─┴─┴────────┤
            ┌──────┴──────┐
            │                          │   ｢論理フォント解除の処理手順｣
            │    論理フォントの解除    │
            │                          │   を参照してください。
            └──────┬──────┘
            ┌──────┴──────┐┐
            │      キャッシュ終了      ││
            └──────┬──────┘│ ｢拡張ﾌｫﾝﾄ管理終了の処理手順｣
            ┌──────┴──────┐│
            │  拡張フォント管理の終了  ││ を参照してください。
            └──────┬──────┘┘
            ┌──────┴──────┐
            │  アプリケーション終了    │
            └─────────────┘

 (2)拡張フォント管理起動までの処理手順

            ┌─────────────┐
            │   アプリケーション起動   │
            └──────┬──────┘
                          〜
拡張フォント管理初期化開始〜
            ┌──────┴──────┐
            │  拡張ﾌｫﾝﾄ管理ﾜｰｸｻｲｽﾞ取得 │
            │                          │
            │〈FTM_GetWorkSize     〉  │
            └──────┬──────┘
            ┌──────┴──────┐  拡張ﾌｫﾝﾄ管理ﾜｰｸｻｲｽﾞ取得
            │                          │
            │拡張フォント管理ワーク取得│  で得た大きさのメモリを
            │                          │
            └──────┬──────┘  確保してください。
            ┌──────┴──────┐
            │  拡張ﾌｫﾝﾄ管理初期化処理  │  メモリ取得、解放関数を
            │                          │
            │〈FTM_Open            〉  │  設定してください。
            └──────┬──────┘
            ┌──────┴──────┐┐
            │  キャッシュ領域取得      ││
            │                          ││
            │  ｷｬｯｼｭのﾊﾟﾗﾒｰﾀ作成       ││
            └──────┬──────┘│キャッシュ機能を使用する
            ┌──────┴──────┐│
            │  キャッシュ領域の初期化  ││場合のみ必要です。
            │                          ││
            │〈FTM_InitCache       〉  ││
            └──────┬──────┘│
            ┌──────┴──────┐│
            │  キャッシュ管理起動      ││
            │                          ││
            │〈FTM_OpenCache       〉  ││
            └──────┬──────┘┘
拡張フォント管理初期化終了〜
                          〜
                          〜

 (3)論理フォント設定の処理手順

                          〜
論理フォント設定開始      〜
            ┌──────┴──────┐
            │論理フォント領域サイズ取得│
            │                          │
            │〈FTM_GetLogicWorkSize〉  │
            └──────┬──────┘
            ┌──────┴──────┐  論理フォント領域サイズ取
            │                          │
            │  論理フォント領域取得    │  得で得た大きさのメモリを
            │                          │
            └──────┬──────┘  確保してください。
            ┌──────┴──────┐
            │    論理フォントの設定    │
            │                          │
            │〈FTM_SetLogicFont    〉  │
            └──────┬──────┘
論理フォント設定終了      〜
                          〜

 (4)フォント選択までの処理手順

                          〜
フォント選択開始          〜
            ┌──────┴──────┐
            │  フォント一覧サイズ取得  │
            │                          │
            │〈FTM_GetFontTableSize〉  │
            └──────┬──────┘
            ┌──────┴──────┐  ﾌｫﾝﾄ一覧ｻｲｽﾞ取得関数で得た
            │                          │
            │  フォント一覧領域の取得  │  大きさのメモリを確保してく
            │                          │
            └──────┬──────┘  ださい。
            ┌──────┴──────┐
            │  フォント一覧の取得      │
            │                          │  ﾌｫﾝﾄ一覧と個数を返します。
            │〈FTM_GetFontTable    〉  │
            └──────┬──────┘
            ┌──────┴──────┐  ﾌｫﾝﾄ一覧を画面に表示し、ｱﾌﾟﾘｹ
            │  フォント一覧の画面表示  │
            │                          │  ｰｼｮﾝを操作している人に書体を
            │  とオペレータによる選択  │
            └──────┬──────┘  選択させ、ﾌｫﾝﾄNoを記録します。
フォント選択終了          〜
                          〜
            ┌──────┴──────┐
            │                          │  フォント一覧が不要になったら
            │  フォント一覧領域の解放  │
            │                          │  ｱﾌﾟﾘｹｰｼｮﾝでメモリ解放します。
            └──────┬──────┘
                          〜
                          〜

 (5)フォント名からフォント選択の手順

                          〜
フォントNo取得開始        〜
            ┌──────┴──────┐
            │                          │  フォント名を指定します。
            │    フォント情報設定      │
            │                          │ ( FTM_INFO型で定義します。) 
            └──────┬──────┘
            ┌──────┴──────┐
            │  フォントNoの取得        │
            │                          │
            │〈FTM_GetFontNo       〉  │
            └──────┬──────┘
フォントNo取得終了        〜
                          〜

 (6)修飾機能設定までの処理手順

                            〜
  修飾ﾊﾟﾗﾒｰﾀの設定開始      〜
            ┌┌──────┴──────┐  使用したい修飾機能別にﾊﾟﾗﾒｰﾀを
            ││                          │  作成します。
            ││                          │ (FTM_ATRROTATION 型で定義します)
            ││                          │ (FTM_ATRSLOPE    型    〃      )
            ││  修飾機能別のﾊﾟﾗﾒｰﾀ作成  │ (FTM_ATRSHADOW   型    〃      )
            ││                          │ (FTM_ATRBORDER   型    〃      )
            ││                          │ (FTM_ATROUTLINE  型    〃      )
            ││                          │ (FTM_ATRSOLID    型    〃      )
            ││                          │ (FTM_ATRPERS     型    〃      )
必要に応じて│└──────┬──────┘ (FTM_ATRFIELD    型    〃      )
設定します  │┌──────┴──────┐
            ││  修飾機能別のﾊﾟﾗﾒｰﾀ設定  │
            ││〈FTM_SetAtrRotation  〉  │  使用しない修飾機能のﾊﾟﾗﾒｰﾀは作
            ││〈FTM_SetAtrSlope     〉  │  成、または設定する必要はありま
            ││〈FTM_SetAtrShadow    〉  │  せん｡
            ││〈FTM_SetAtrBorder    〉  │
            ││〈FTM_SetAtrOutline   〉  │
            ││〈FTM_SetAtrSolid     〉  │
            ││〈FTM_SetAtrPers      〉  │
            ││〈FTM_SetAtrField     〉  │
            └└──────┬──────┘
              ┌──────┴──────┐  ｻｲｽﾞ 、ﾌｫﾝﾄNo、修飾機能の有無を
              │  修飾機能のﾊﾟﾗﾒｰﾀ作成    │  ビットで定義します。
              │                          │ (FTM_ATR型で定義します) 
              └──────┬──────┘
              ┌──────┴──────┐  このｱﾄﾘﾋﾞｭｰﾄは必ず設定してくだ
              │  修飾機能のﾊﾟﾗﾒｰﾀ設定    │  さい。また、修飾機能を使うと設
              │〈FTM_SetAtr          〉  │  定した場合は修飾機能個別のﾊﾟﾗﾒ
              └──────┬──────┘  ｰﾀも設定してください。
  修飾ﾊﾟﾗﾒｰﾀの設定終了      〜
                            〜

    - 注意 -
    これらの修飾パラメータは論理フォントに対して定義することになります。

 (7)文字イメージ取得･描画の処理手順

                              〜
    文字イメージ取得･描画開始〜
                ┌──────┴──────┐どの情報が返されるかは文字修飾
                │  フォントサイズの取得    │の設定状況により変化します。
                │〈FTM_GetFontSize     〉  │サイズ情報の領域は解放しないで
                └──────┬──────┘ください。
                ┌──────┴──────┐
                │  必要イメージ領域取得    │フォントサイズ取得で返された分
                │                          │の領域を確保してください。
                └──────┬──────┘
                ┌──────┴──────┐
                │  ｲﾒｰｼﾞ領域ｵﾌｾｯﾄ設定      │フォントサイズ取得した FTM_SIZE
                │                          │構造体内のｲﾒｰｼﾞ領域ｵﾌｾｯﾄに、確
                └──────┬──────┘保したｲﾒｰｼﾞ領域のｱﾄﾞﾚｽをｾｯﾄしま
┌─────────────→│              す。
│              ┌──────┴──────┐
│              │  フォントイメージ取得    │
│              │〈FTM_GetFontImage    〉  │
│              └──────┬──────┘
│          ┌───────→│              取得したイメージを画面に描画し
│          │  ┌──────┴──────┐ます。イメージは修飾機能の設定
│プレーン数│  │    イメージの画面描画    │により複数のプレーンに分割され
│      だけ│  │                          │ています。よって複数回に分けて
│          │  └──────┬──────┘描画が必要です。
│          └────────┤              プレーン色テーブルを参照して描
└──────────────┤              画してください。詳細については
                              │              、イメージ描画方法を参照してく
                              │              ださい。
                ┌──────┴──────┐不必要になったイメージ領域を解
                │    イメージ領域解放      │放します。
                │                          │
                └──────┬──────┘
     文字イメージ取得･描画終了〜
                              〜

    - 注意 -
    イメージ領域サイズがわかっていてもフォントサイズの取得関数でイメージ領域
    サイズを取得してください。それは、フォントイメージ取得関数がフォントサイ
    ズ取得関数で設定されたイメージ領域サイズを参照するためです。

    - アドバイス -
    フォントNo、文字サイズ、各修飾パラメータが同一で文字コードのみが異なる場
    合、フォントイメージの取得とイメージの画面描画処理を連続して行うことがで
    きます。

 (8)論理フォント解除の処理手順

                          〜
論理フォント解除処理の開始〜
            ┌──────┴──────┐
            │    論理フォントの解除    │
            │                          │
            │〈FTM_ResetLogicFont  〉  │
            └──────┬──────┘
            ┌──────┴──────┐
            │  論理フォント領域解放    │
            └──────┬──────┘
論理フォント解除終了      〜
                          〜

 (9)拡張フォント管理終了の処理手順

拡張フォント管理終了処理の〜
                      開始〜
            ┌──────┴──────┐┐
            │  キャッシュ管理の終了    ││
            │〈FTM_CloseCache      〉  ││キャッシュ機能を使用する場合のみ
            └──────┬──────┘│必要です。
            ┌──────┴──────┐│
            │    キャッシュ領域解放    ││
            │                          ││
            └──────┬──────┘┘
            ┌──────┴──────┐
            │呼び出しダイナミックリンク│  拡張フォント管理で呼び出したダイ
            │ライブラリの解放          │  ナミックリンクライブラリを解放し
            │〈FTM_FreeDLL         〉  │  ます。なお、この関数は初期化後か
            └──────┬──────┘  ら終了までの間で使用可能です。
            ┌──────┴──────┐
            │拡張フォント管理終了処理  │  拡張フォント管理で独自に取得した
            │〈FTM_Close             〉│  メモリ領域やファイルハンドルを解
            └──────┬──────┘  放します。必ず実行してください。
            ┌──────┴──────┐
            │拡張フォント管理ワーク解放│
            │                          │
            └──────┬──────┘
            ┌──────┴──────┐
            │  ﾀﾞｲﾅﾐｯｸﾘﾝｸﾗｲﾌﾞﾗﾘの解放  │  以降、拡張フォント管理を利用しな
            └──────┬──────┘  い場合は、拡張フォントライブラリ
拡張フォント管理終了処理の〜                を解放することにより、メモリを有
                      終了〜                効に利用できます。
            ┌──────┴──────┐
            │  アプリケーション終了    │
            └─────────────┘

 (10)アウトラインデータ取得の手順

アウトラインデータ取得開始〜
                          〜
            ┌──────┴──────┐
            │  フォントサイズの取得    │･サイズ情報の領域は解放しないで
            │〈 FTM_GetFontSize     〉 │ ください。
            └──────┬──────┘
            ┌──────┴──────┐
            │  必要アウトラインデータ  │･フォントサイズ取得で返された分
            │          領域取得        │ の領域を確保してください。
            └──────┬──────┘
            ┌──────┴──────┐･フォントサイズ取得した FTM_
            │  アウトラインデータ領域  │ SIZE型構造体内のｱｳﾄﾗｲﾝﾃﾞｰﾀ領域
            │      オフセット設定      │ ｵﾌｾｯﾄ に、確保したｱｳﾄﾗｲﾝﾃﾞｰﾀ領
            └──────┬──────┘ 域のｱﾄﾞﾚｽをセットします。
          ┌──────→│
          │┌──────┴──────┐
          ││  アウトラインデータ取得  │
          ││〈 FTM_GetFontOutline  〉 │
          │└──────┬──────┘
          │              │
          │┌──────┴──────┐･取得されたアウトラインデータ形
          ││  アプリケーションでの    │ 式については｢1.8   アウトラト
          ││  アウトラインデータ加工  │ ンデータの利用方法について｣を
          │└──────┬──────┘ 参照願います。
          └───────┤
            ┌──────┴──────┐
            │アウトラインデータ領域解放│･不必要になったアウトラインデー
            │                          │ タ領域を解放します。
            └──────┬──────┘
アウトラインデータ取得終了〜
                          〜

    - 注意 -
    アウトラインデータ領域サイズがわかっていても、フォントサイズの取得関数で
    アウトラインデータ領域サイズを取得してください。それはアウトラインデータ
    取得関数が、フォントサイズ取得関数で設定されたアウトラインデータ領域サイ
    ズを参照するためです。

    - アドバイス -
    フォントNo、文字サイズ、各修飾パラメータが同一で文字コードのみが異なる場
    合、アウトラインデータ取得とアプリケーションでのアウトラインデータ加工処
    理を連続して行うことができます。

1.5 アプリケーション開発時の注意事項

 (1)初期化処理で登録されたメモリ取得関数を利用してアプリケーションに提供する
    パラメータ領域や内部のパラメータ管理領域を取得し、保持します。
    これらの領域は終了処理で解放されます。(アプリケーションに渡すパラメータ領
    域のうち、アプリケーションにて解放する必要があるものもあります。)

 (2)メモリ取得･解放関数はユーザが作成したものを登録することも可能です。
    ただし、High C標準ライブラリのmalloc関数、free関数と同じインターフェース
    であることが条件です。ユーザが作成した関数を使用することにより、メモリの
    使用状況を監視したり、一定限度以上のメモリ使用を抑制したりすることができ
    ます。ただし、メモリ使用を抑制すると、フォントイメージ取得機能などが使用
    不可能となる場合があります。

 (3)論理フォントは複数設定することが可能です。
    なお、論理フォント別に論理フォント用ワークを取得してください。

 (4)拡張フォント管理ライブラリを使用するアプリケーションは、以下のリソースラ
    イブラリ(SDL形式)をリンカによってアプリケーションにリンクする必要がありま
    す。SDL形式のリソース定義ファイルはライブラリと同じようにリンクしてくださ
    い。リソースライブラリについては、｢第9章  ダイナミックリンクサポートライ
    ブラリ｣を参照してください。

      FTM.SDL :  拡張フォント管理ライブラリ用リソースライブラリ

    なお、拡張ライブラリI V2.1L20の拡張ベクトルフォントライブラリを使用してい
    て、拡張フォント管理ライブラリに変更する場合、リソース定義ファイルの作成
    およびリンク方法が変更されましたので以下の項目について注意してください。

    ◇リソース定義ファイルの作成とリンク方法の変更
      今回提供しましたダイナミックリンクサポートライブラリより複数のリソース
      定義ファイルをリンク可能となりました。これによりリソース定義ファイルを
      一本化する必要がなくなり、各ライブラリが提供するリソース定義ファイルま
      たはリソースライブラリをリンクするだけで良くなります。しかし、すでにテ
      キスト形式(RDF形式)のリソース定義ファイルを作成している、リソースライブ
      ラリ(SDL形式)が提供されていない場合などは、既存のリソース定義ファイルを
      使用する必要があります。そのような場合は次のように対応してください。

    1)拡張フォント管理ライブラリ以外のダイナミックリンクライブラリは使用しな
      い場合。

      拡張フォント管理ライブラリ用リソースライブラリ(SDL形式)を使用してくださ
      い。拡張ベクトルフォントライブラリ用に作成したリソース定義ファイル(RDF
      形式)は必要ありません。

    2)拡張フォント管理ライブラリ以外のダイナミックリンクライブラリと併用する
      場合で、さらに、そのダイナミックリンクライブラリのリソースライブラリ
      (SDL形式)が提供されている場合。

      拡張フォント管理ライブラリおよび他のダイナミックリンクライブラリとも提
      供されているリソースライブラリ(SDL形式)を使用してリンクしてください。

    3)拡張フォント管理ライブラリ以外のダイナミックリンクライブラリと併用する
      場合で、さらに、そのダイナミックリンクライブラリのリソースライブラリ
      (SDL形式)が提供されていない場合。

      既に作成済のテキスト形式(RDF形式)のリソース定義ファイル内には拡張ベクト
      ルフォントライブラリを使用するための定義と他のダイナミックリンクライブ
      ラリを使用するための定義が混在していると思います。この中より拡張ベクト
      ルフォントライブラリに関係する定義を削除します。extern関数定義は該当す
      る全関数を削除します。public関数定義は拡張フォント管理ライブラリが必要
      としている関数を他のダイナミックリンクライブラリで必要としていないこと
      を確認して、該当する関数を削除します。(削除する関数は｢拡張フォント管理
      ライブラリのリソース定義内容｣を参照してください。)
      このテキスト形式(RDF形式)のリソース定義ファイルを使用して、オブジェクト
      形式(RCO形式)のリソース定義ファイルを再作成し、拡張フォント管理ライブラ
      リ用リソースライブラリ(SDL形式)と合わせてリンクします。

    4)テキスト形式(RDF形式)のリソース定義ファイルを使用する場合。

      拡張ベクトルフォントライブラリと同じようにテキスト形式(RDF形式)のリソー
      ス定義ファイルを作成し、オグジェクト形式(RCO形式)のリソース定義ファイル
      に変換してリンクすることで使用可能です。しかし、機能拡張などにより定義
      内容が変更されていく可能性がありますので、今後はリソースライブラリ(SDL
      形式)を使用することをお薦めします。

【拡張フォント管理ライブラリのリソース定義内容】

 extern
   FTM_GetWorkSize        FTM.DLL  ┐              ┐
   FTM_Open               FTM.DLL  │              │
   FTM_Close              FTM.DLL  │              │
   FTM_InitCache          FTM.DLL  │              │
   FTM_OpenCache          FTM.DLL  │              │
   FTM_CloseCache         FTM.DLL  │              │
   FTM_GetLogicWorkSize   FTM.DLL  │              │
   FTM_SetLogicFont       FTM.DLL  │              │
   FTM_ResetLogicFont     FTM.DLL  │              │
   FTM_GetFontTableSize   FTM.DLL  │拡張ベクトル  │
   FTM_GetFontTable       FTM.DLL  │フォントライブ│
   FTM_GetFontInfo        FTM.DLL  ├ラリおよび、  │
   FTM_GetFontNo          FTM.DLL  │拡張フォント  │アプリケーションより利用
   FTM_GetFontSize        FTM.DLL  │管理ライブラリ│する関数を定義します。
   FTM_GetFontImage       FTM.DLL  │共通関数      │使用する関数は必ず定義す
   FTM_SetAtr             FTM.DLL  │              ├る必要があります。未使用
   FTM_SetAtrRotation     FTM.DLL  │              │の関数につていは定義する
   FTM_SetAtrSlope        FTM.DLL  │              │必要はありません。
   FTM_SetAtrShadow       FTM.DLL  │              │
   FTM_SetAtrBorder       FTM.DLL  │              │
   FTM_SetAtrOutline      FTM.DLL  │              │
   FTM_SetAtrSolid        FTM.DLL  │              │
   FTM_SetAtrPers         FTM.DLL  │              │
   FTM_FreeDLL            FTM.DLL  ┘              │
   FTM_GetFontTableSize2  FTM.DLL  ┐              │
   FTM_GetFontTable2      FTM.DLL  │拡張フォント  │
   FTM_GetFontInfo2       FTM.DLL  ├管理ライブラリ│
   FTM_GetFontOutline     FTM.DLL  │より追加関数  │
   FTM_SetAtrField        FTM.DLL  ┘              ┘
end 

 public
                         ┐              ┐
                         │              │
    strncpy              │拡張ベクトル  │
    strncmp              │フォントライブ│
    strcat               │ラリおよび、  │
     _mwcmp              ├拡張フォント  │
     _mwgetds            │管理ライブラリ│このライブラリからアプリケーション
    mma_allocSeg         │の両方で必要と│側に要求する関数です。この内容は必
    mma_freeSeg          │する関数      │ずアプリケーション用リソース定義フ
                         │              ├ァイル内に記述されている必要があり
                         │              │ます。また、これらの関数はアプリケ
                         ┘              │ーションにリンクされる必要がありま
     _XLD_setLinkPath    ┐拡張ベクトル  │す。
     _XLD_getLinkPath    │フォントライブ│
     _XLD_load           │ラリのみ必要と│
     _XLD_unlink         ├する関数(拡張 │
     _XLD_isLinked       │フォント管理ラ│
     _XLD_lockLib        │イブラリでは定│
     _XLD_unlockLib      │義しないでくだ│
     _XLD_getError       ┘さい。)       ┘
 end 

 (5)フォントNo(フォント種の識別番号)はTownsｼｽﾃﾑｿﾌﾄｳｪｱのシステム設定状態により
    異なります。そのため、フォントNoを記録したテキストファイルをシステム状態
    の異なるTOWNS/IIにて使用すると異なる文字が表示される場合があります。
    このような事を避けるためフォントNoは記録せず、フォント名を記録してくださ
    い。フォント名はシステムの状態に関係なく同一です。

1.6 イメージ描画方法

  イメージ領域は修飾指定がない場合は1枚のイメージ領域で構成されます。この場合
はベクトル展開ライブラリと同様に、グラフィックライブラリの任意文字表示関数な
どにより描画可能です。しかし、修飾機能2の下記の機能を使用した場合は複数のイメ
ージ領域が必要となります。この各イメージ領域をプレーンと呼び、複数のプレーン
を必要とする場合は後記のような処理が必要です。なお、各プレーンは連続してメモ
リ上に確保してください。

    複数プレーン      :  修飾機能2  立体変換、  縁取り
    必要な修飾機能    :              輪郭、      影付

 (1)イメージのプレーン構造

    図EXL121R-025

 (2)描画処理の方法
    イメージの先頭プレーンより順番にプレーン数分だけ描画を繰り返してください
    。各プレーンは画面上の同一位置に描画します。このとき描画色はプレーン色テ
    ーブルを参照してください。プレーン色テーブルには修飾パラメータで指定した
    色がプレーンに対応した並びで格納されています。また、描画モードはPSETで描
    画してください。これは各プレーンで重なる領域が発生するため、透過色などで
    描画すると正しく描画されません。
    プレーン色テーブルには各修飾パラメータで設定した色が格納されていますが、
    各修飾パラメータで設定する色は色識別番号以外でも可能です。指定する色の管
    理はアプリケーションで行ってください。

1.7 プロポーショナル文字の制御

  このライブラリは、ベクトル文字パターンIIのプロポーショナル英文字に対応して
います。プロポーショナル英文字を綺麗に表示するためには次のような処理をする必
要があります。

 (1)イメージの形式

    図EXL121R-026

 (2)処理内容

  1)プロポーショナル文字かどうか判断して、プロポーショナル文字なら次項の描画
    位置の調整を行います。なお、通常の半角文字と同じように使用することも可能
    です。
    ･フォント一覧(FTM_TABLE型)の付属情報形式またはフォントサイズ情報(FTM_SIZE
     型) の付属情報形式により判断します。

  2)文字イメージ取得時に文字幅とベースライン位置を取得し、文字の描画位置を調
    整します。
    ･フォントサイズ情報(FTM_SIZE型)のプロポーショナル情報1(文字幅)により取得
     可能です。また、文字幅とベースライン位置は修飾指定で設定した文字サイズに
     対してのドット数として返してきます。
    ･描画位置の調整

     〔横方向〕  ((文字サイズＸ/2)の切り捨て  文字幅)/2の切り捨て
                 上記の値だけ、文字を左に描画します。

                ･修飾をしている場合は修飾により増えるドットも考慮する必要が
                 あります。修飾で増えるドット数はフォントサイズ情報の左上･
                 右下の座標より求めることが可能です。

     〔縦方向〕  ベースライン位置ドット数
                 上記の値だけ、文字を下に描画します。

                ･行間には注意してください。また、この調整は日本語のベースラ
                 インと合わせるために行うものです。この処理をしないとプロポ
                 ーショナル文字が浮いて見えます。

1.8 アウトラインデータの利用方法について

  ベクトルフォント(アウトラインフォント)の中にはアウトラインデータを取得でき
る書体があります。アウトラインデータが取得できるフォント種の判別方法と取得･
表示方法について説明します。

 (1)取得可能フォント種の判別

  1)フォント一覧による判別
    フォント一覧の取得(FTM_GetFontTable関数)でフォント一覧(FTM_TABLE型)を取得
    し、各フォントの提供可能データ形式のアウトラインデータ形式ビットにより判
    別します。

  2)フォントファイル情報による判別
    フォント情報の取得(FTM_GetFontInfo関数)でフォントファイル情報(FTM_INFO型)
    を取得し、提供可能データ形式のアウトラインデータ形式ビットにより判別しま
    す。

 (2)取得･表示方法

  1)アウトラインデータの取得
   ･文字イメージ取得と同様の手順で初期設定を行います。
   ･文字イメージ取得(FTM_GetFontImage関数)のかわりにアウトラインデータの取得
    (FTM_GetFontOutline関数)を実行します。ただし、用意する
    メモリ領域サイズは全イメージ領域バイト数の替わりにアウトラインデータ領域
    バイト数を参照して、メモリ領域アドレスはイメージ領域オフセットではなく、
    アウトラインデータ領域オフセットに設定してください。

  2)アウトラインデータの画面への表示
   ･アウトラインデータのデータ構造で示す、区切りマーク後の座標数から次の区切
    りマークの前までをHigh Cグラフィックライブラリの連続線分(EGB_connect関数)
    のパラメータとして指定することにより、輪郭の一つが描けます。
   ･輪郭数だけ前記の操作を繰り返すことにより1文字分の輪郭が描けます。

 (3)アウトラインデータ(直線形式)のデータ構造
    アウトラインデータ取得(FTM_GetFontOutline関数)にて取得したアウトラインデ
    ータは以下の形式になります。

┌─┬────────┐
│Ｗ│サイズＸ        ├──┐
├─┼────────┤    ├──文字サイズ
│Ｗ│サイズＹ        ├──┘
├─┼────────┤
│Ｗ│輪郭数          ├─────文字を構成する輪郭の数
├─┼────────┤                                ┐
│Ｗ│区切りﾏｰｸ(8000H)├─────輪郭データの先頭を意味│
├─┼────────┤          する。                │
│Ｗ│座標数M         ├─────輪郭を構成する座標数  │
├─┼────────┤        (輪郭の頂点数は1引く)   │
│SW│座標Ｘ1         ├──┐              ┐          │
├─┼────────┤    ├──開始座標  │          │
│SW│座標Ｙ1         ├──┘              │          │
├─┼────────┤                    │          │
│SW│座標Ｘ2         ├──┐              │開始座標か│
├─┼────────┤    ├──第二座標  │ら第二座標├第一輪郭分ブロック
│SW│座標Ｙ2         ├──┘              │を結び、第│(このブロックが輪
├─┼────────┤                    │二座標から│ 郭数分繰り返され
〜  〜                〜                    ├次の座標を│ る)
┌─┬────────┐                    │結ぶ事を繰│
│SW│座標ＸM-1       ├──┐              │り返すこと│
├─┼────────┤    ├──Ｍ-1座標  │で輪郭を描│
│SW│座標ＹM-1       ├──┘              │くことがで│
├─┼────────┤                    │きます。  │
│SW│座標ＸM         ├──┐              │          │
├─┼────────┤    ├──Ｍ座標    │          │
│SW│座標ＹM         ├──┘(開始座標     │          │
├─┼────────┤          と同じ値) ┘          ┤
│Ｗ│区切りﾏｰｸ(8000H)│                                │
├─┼────────┤                                │
│Ｗ│座標数N         │                                │
├─┼────────┤                                │
│SW│座標Ｘ1         │                                │
├─┼────────┤                                │
│SW│座標Ｙ1         │                                ├第二輪郭分ブロック
├─┼────────┤                                │
〜  〜                〜                                │
┌─┬────────┐                                │
│SW│座標ＸN         │                                │
├─┼────────┤                                │
│SW│座標ＹN         │                                │
├─┼────────┤─┬─                          ┘
│Ｗ│区切りﾏｰｸ(8000H)│  │  これ以降、第三輪郭以後のブロックが続きます。
├─┼────────┤  │
│Ｗ│座標数L         │  │
├─┼────────┤  │
〜  〜                〜  〜
├─┼────────┤  │
│SW│座標ＸL         │  │
├─┼────────┤  │
│SW│座標ＹL         │  ↓
├─┼────────┤
│Ｗ│終了ﾏｰｸ  (FFFFH)│─────文字データ終了を意味する
└─┴────────┘

  - 注意 -
  1)文字は単一または複数の輪郭により構成されます。
    構成される輪郭数はデータ構造内の輪郭数を参照してください。
 
  2)各輪郭は第一番目の座標(座標Ｘ1 , 座標Ｙ1 )よりスタートし、中間座標を経由
    して最終的に第一番目の座標と同じ座標(座標ＸM , 座標ＹM )に戻ります。
    よって、輪郭の頂点数は座標数より1引く値になります。
 
  3)同一フォント種、同一文字でも文字サイズにより各輪郭の座標数が変わる場合が
    あります。基本的に大きい文字の方が座標数が多くなります。
    また、フォント種や文字が異なれば座標数や輪郭数は違います。

  4)各輪郭の座標は座標順に直線で結ぶことで一つの輪郭を表現します。
    また、全輪郭を同一座標系で描くことで、文字全体の輪郭を表現します。
 
  5)文字サイズが小さい場合などは各輪郭どうしの座標が重なる場合があります。
    また、1輪郭内の座標でも重複する場合があります。
 
  6)文字の外側輪郭は時計回りとなり、文字の内側輪郭(クリ抜き)は反時計回りとな
    ります。

    図EXL121R-027

      文字の外側輪郭(Ａ、Ｂ、Ｃ、Ｄ、Ｅ)は時計回りで座標がつながる。
      文字の内側輪郭(Ｆ、Ｇ、Ｈ、I、Ｊ)は反時計回りで座標がつながる。

  7)各座標は重なる場合があります。
    また、文字の太さが存在しない場合があります。
      Ｃ  Ａ
        │        座標(Ａ、Ｂ、Ｃ)で一つの輪郭を構成する場合があります。
        │      この場合、座標ＡとＣは同一となり、線は最小限度の太さとな
        │      ります。
        Ｂ

  8)修飾は反映されません。つねに無修飾のアウトラインデータが取得されます。

1.9 キャッシュ機能について

  ベクトル文字などは展開に時間がかかるため、一度展開した文字をキャッシュメモ
リに保管し、再度必要になったとき、キャッシュメモリより取り出すことにより、性
能を上げるための機能です。

■メモリ見積もり
  必要とする性能、格納される文字数によって、大きく異なりますが、数十KBから数
  百KBほど必要です。また、最高1MBを限度としてください。

1.10 構造体

  構造体の各項目の説明は、｢1.11 構造体の共通項目詳細説明｣を参照してください。
なお、各構造体で固有の項目は構造体のあとに記述します。
┌─────────────────────────┐
│  FTM_ATR型                           修飾指定    │
└─────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│SW│フォントＮＯ              │fontNo              │
├─┼─────────────┼──────────┤
│SW│文字サイズＸ              │sizeX               │
├─┼─────────────┼──────────┤
│SW│文字サイズＹ              │sizeY               │
├─┼─────────────┼──────────┤
│Ｗ│出力データ形式            │outData             │
├─┼─────────────┼──────────┤
│Ｗ│修飾機能1                 │atr1                │
├─┼─────────────┼──────────┤
│Ｗ│修飾機能2                 │atr2                │
├─┼─────────────┼──────────┤
│Ｗ│修飾機能3                 │atr3                │
├─┼─────────────┼──────────┤
│Ｄ│文字色                    │color               │
└─┴─────────────┴──────────┘

  - 注意 -
  修飾機能1と修飾機能2を合わせて使用した場合は、出力結果が異常となる場合があ
  ります。


┌──────────────────────────┐
│    FTM_ATRROTATION                   回転修飾指定  │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│Ｗ│モード                    │mode                │
├─┼─────────────┼──────────┤
│Ｗ│回転角度                  │rotationAng         │
└─┴─────────────┴──────────┘

〔モード〕
      15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│Ｗ│ 0   0   0   0   0   0   0   0   0   0   0   0   0   0   0    │
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┬┘
                                                                  │
        0:その場回転  ←─────────────────────┘

  - 注意 -
  その場回転は90度単位の回転のみです。


┌──────────────────────────┐
│    FTM_ATRSLOPE                      斜体修飾指定  │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│Ｗ│モード                    │mode                │
├─┼─────────────┼──────────┤
│Ｗ│斜体角度                  │slopeAng            │
└─┴─────────────┴──────────┘

〔モード〕
      15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│Ｗ│ 0   0   0   0   0   0   0   0   0   0   0   0   0   0        │
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┬┴┬┘
                                                              │  │
          00:右斜体  01:下斜体  ←──────────────┴─┘
          10:左斜体  11:上斜体

  - 注意 -
  [斜体角度]0、15、30、45のみ指定可能です。


┌──────────────────────────┐
│    FTM_ATRSHADOW                     影付修飾指定  │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│SW│影の相対位置X             │shadowX             │
├─┼─────────────┼──────────┤
│SW│影の相対位置Y             │shadowY             │
├─┼─────────────┼──────────┤
│Ｄ│影の色                    │shadowCol           │
└─┴─────────────┴──────────┘

  - 注意 -
  立体文字、輪郭修飾指定時は、影付修飾は無効となります。


┌──────────────────────────┐
│    FTM_ATRBORDER                   縁取り修飾指定  │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｗ│縁のドット数              │borderDot           │
├─┼─────────────┼──────────┤
│Ｄ│縁の色                    │borderCol           │
└─┴─────────────┴──────────┘


┌──────────────────────────┐
│    FTM_ATROUTLINE                    輪郭修飾指定  │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｗ│輪郭1のドット数           │outlineDot1         │
├─┼─────────────┼──────────┤
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｄ│輪郭の色1                 │outlineCol1         │
├─┼─────────────┼──────────┤
│Ｄ│(リザーブ)                │(リザーブ)          │'0'固定
└─┴─────────────┴──────────┘


┌──────────────────────────┐
│    FTM_ATRSOLID                  立体文字修飾指定  │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│Ｗ│モード                    │mode                │
├─┼─────────────┼──────────┤
│SW│立体化相対X座標           │posX                │
├─┼─────────────┼──────────┤
│SW│立体化相対Y座標           │posY                │
├─┼─────────────┼──────────┤
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｂ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｂ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｂ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｂ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｂ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｂ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｂ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｂ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｄ│立体色1(側面色)           │solidCol1           │
├─┼─────────────┼──────────┤
│Ｄ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｄ│(リザーブ)                │(リザーブ)          │'0'固定
└─┴─────────────┴──────────┘

〔モード〕
      15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│Ｗ│ 0   0   0   0   0   0   0   0   0   0   0   0   0   0        │
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┬┴┬┘
                                                              │  │
          00:平行移動    01:一点収束  ←───────────┴─┘

〔立体化Ｘ座標〕    平行移動時  :  移動量
                    一点収束時  :  収束点座標


┌──────────────────────────┐
│    FTM_ATRPERS                   透視変換修飾指定  │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│SW│点AのX座標                │lupX                │
├─┼─────────────┼──────────┤
│SW│点AのY座標                │lupY                │
├─┼─────────────┼──────────┤
│SW│点BのX座標                │rupX                │
├─┼─────────────┼──────────┤
│SW│点BのY座標                │rupY                │
├─┼─────────────┼──────────┤
│SW│点CのX座標                │rdwX                │
├─┼─────────────┼──────────┤
│SW│点CのY座標                │rdwY                │
├─┼─────────────┼──────────┤
│SW│点DのX座標                │ldwX                │
├─┼─────────────┼──────────┤
│SW│点DのY座標                │ldwY                │
└─┴─────────────┴──────────┘

  図EXL121R-028

  - 注意 -
  A、B、C、Dの4点の一番小さい座標値が0になるようにセットしてください。
  また、AB、BC、CD、DA間の線が重なるような設定はしないでください。
  A、B、C、Dの4点の座標値が同じになるようにはセットしないでください。
  透視変換修飾指定時は回転、斜体、影付、縁取り、輪郭、立体文字の各修飾機能は
  無効になります。


┌──────────────────────────┐
│    FTM_ATRFIELD            領域･クリップ修飾指定   │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│Ｗ│モード                    │mode                │
├─┼─────────────┼──────────┤
│SW│領域横ドット数            │fieldX              │
├─┼─────────────┼──────────┤
│SW│領域縦ドット数            │fieldY              │
├─┼─────────────┼──────────┤
│SW│文字左上座標X             │posX                │
├─┼─────────────┼──────────┤
│SW│文字左上座標Y             │posY                │
├─┼─────────────┼──────────┤
│SW│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│SW│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│SW│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│SW│(リザーブ)                │(リザーブ)          │'0'固定
└─┴─────────────┴──────────┘

  - 注意 -
  領域の左上が基準点(0,0)となります。文字左上座標X,Yは基準点に対して設定して
  ください。

〔モード〕
      15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│Ｗ│ 0   0   0   0   0   0   0   0   0   0   0   0   0   0   0    │
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┬┘
                                                                  │
          0:クリップ無し  1:クリップ有り  ←───────────┘

  - 注意 -
  クリップ有りは指定できません。


┌──────────────────────────┐
│    FTM_SIZE型        フォントサイズ情報･付属情報   │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│SW│左上横座標X               │lupX                │
├─┼─────────────┼──────────┤
│SW│左上縦座標Y               │lupY                │
├─┼─────────────┼──────────┤
│SW│右下横座標X               │rdwX                │
├─┼─────────────┼──────────┤
│SW│右下縦座標Y               │rdwY                │
├─┼─────────────┼──────────┤
│Ｂ│1画素のビット数           │bit                 │
├─┼─────────────┼──────────┤
│Ｂ│プレーン数                │planeCnt            │
├─┼─────────────┼──────────┤
│Ｄ│プレーン色テーブルｵﾌｾｯﾄ   │planeTblOff         │
├─┼─────────────┼──────────┤
│Ｄ│全イメージ領域バイト数    │imageSize           │
├─┼─────────────┼──────────┤
│Ｄ│1ﾌﾟﾚｰﾝ ｲﾒｰｼﾞ領域ﾊﾞｲﾄ数    │planeSize           │
├─┼─────────────┼──────────┤
│Ｄ│1ﾗｲﾝ   ｲﾒｰｼﾞ領域ﾊﾞｲﾄ数    │lineSize            │
├─┼─────────────┼──────────┤
│Ｄ│イメージ領域オフセット    │imageOff            │
├─┼─────────────┼──────────┤
│Ｄ│ｱｳﾄﾗｲﾝﾃﾞｰﾀ領域ﾊﾞｲﾄ数      │outlineSize         │
├─┼─────────────┼──────────┤
│Ｄ│ｱｳﾄﾗｲﾝﾃﾞｰﾀ領域ｵﾌｾｯﾄ       │outlineOff          │
├─┼─────────────┼──────────┤
│Ｗ│付属情報形式              │atrFlag             │
├─┼─────────────┼──────────┤
│Ｄ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｗ│ﾌﾟﾛﾎﾟｰｼｮﾅﾙ情報1(文字幅)   │propolSize          │
├─┼─────────────┼──────────┤
│Ｗ│ﾌﾟﾛﾎﾟｰｼｮﾅﾙ情報1(ﾍﾞｰｽﾗｲﾝ)  │propolBase          │
└─┴─────────────┴──────────┘

  - 注意 -
  プロポーショナル情報1はプロポーショナル文字の場合のみ有効です。

〔プレーン色テーブル〕
┌─┬─────────────┐
│Ｄ│プレーン1の色             │
├─┼─────────────┤
│Ｄ│プレーン2の色             │
├─┼─────────────┤
〜  〜                          〜
├─┼─────────────┤
│Ｄ│プレーンnの色             │
└─┴─────────────┘

  - 注意 -
  このテーブルの色は、各修飾構造体の色をイメージのプレーン順に並び変えたもの
  です。色の内容はアプリケーション管理となります。アプリケーションの画面モー
  ドによって色番号、パレット番号、その他任意の番号を指定してください。

 〔左上横座標Ｘ、左上縦座標Ｙ、右下横座標Ｘ、右下縦座標Ｙ〕
   イメージ領域の論理座標を表します。
   イメージ領域の先頭アドレスが左上の座標に一致します。
   通常、文字サイズX、Yのみ指定した場合、左上は(0、0)となり右下は必ず0以上の
   値をとります。縁取りや輪郭修飾を指定すると文字が大きい分、左上の座標は0以
   下の値となり、右下の座標は大きくなります。透視変換指定をした場合はA、B、
   C、Dの四点の一番小さい値が0になるようにします。

  図EXL121R-029

  - 注意 -
  点線部分が文字の実体で、実線部分は縁取りにより膨らむ部分を表しています。

┌──────────────────────────┐
│    FTM_TABLE                     フォント一覧情報  │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│SW│フォントNo                │fontNo              │
├─┼─────────────┼──────────┤
│34│フォント名                │fontName            │
├─┼─────────────┼──────────┤
│Ｗ│分類形式                  │familyType          │
├─┼─────────────┼──────────┤
│Ｗ│サポート文字              │supportCode         │
├─┼─────────────┼──────────┤
│Ｗ│データ形式                │dataType            │
├─┼─────────────┼──────────┤
│Ｗ│提供可能データ形式        │outType             │
├─┼─────────────┼──────────┤
│Ｗ│付属情報形式              │atrFlag             │
├─┼─────────────┼──────────┤
│SW│基本文字サイズＸ          │sizeX               │
├─┼─────────────┼──────────┤
│SW│基本文字サイズＹ          │sizeY               │
├─┼─────────────┼──────────┤
│Ｗ│修飾機能1                 │atr1                │
├─┼─────────────┼──────────┤
│Ｗ│修飾機能2                 │atr2                │
├─┼─────────────┼──────────┤
│Ｗ│修飾機能3                 │atr3                │
├─┼─────────────┼──────────┤
│Ｗ│フォント格納媒体          │media               │
└─┴─────────────┴──────────┘

  - 注意 -
  フォント名は34バイトですが実際には32バイト分のみ収まります。
  残り2バイトはNULL文字が収まります。

┌──────────────────────────┐
│    FTM_INFO型                フォントファイル情報  │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│SW│フォントNo                │fontNo              │
├─┼─────────────┼──────────┤
│34│フォント名                │fontName            │
├─┼─────────────┼──────────┤
│Ｗ│分類形式                  │familyType          │
├─┼─────────────┼──────────┤
│Ｗ│サポート文字              │supportCode         │
├─┼─────────────┼──────────┤
│Ｗ│データ形式                │dataType            │
├─┼─────────────┼──────────┤
│Ｗ│提供可能データ形式        │outType             │
├─┼─────────────┼──────────┤
│Ｗ│付属情報形式              │atrFlag             │
├─┼─────────────┼──────────┤
│SW│基本文字サイズX           │sizeX               │
├─┼─────────────┼──────────┤
│SW│基本文字サイズY           │sizeY               │
├─┼─────────────┼──────────┤
│Ｗ│修飾機能1                 │atr1                │
├─┼─────────────┼──────────┤
│Ｗ│修飾機能2                 │atr2                │
├─┼─────────────┼──────────┤
│Ｗ│修飾機能3                 │atr3                │
├─┼─────────────┼──────────┤
│Ｗ│フォント格納媒体          │media               │
├─┼─────────────┼──────────┤
│Ｄ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│12│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｗ│フォント構成ファイル数    │fileCnt             │
├─┼─────────────┼──────────┤
│66│ﾌｫﾝﾄﾌｧｲﾙ格納ﾄﾞﾗｲﾌﾞ､ﾊﾟｽ名  │pathName            │
└─┴─────────────┴──────────┘

┌──────────────────────────┐
│    FTM_CACHE                       キャッシュ情報  │
└──────────────────────────┘
《構造体》
┌─┬─────────────┬──────────┐
│Ｄ│キャッシュ領域アドレス    │cacheOff            │
├─┼─────────────┼──────────┤
│Ｄ│キャッシュ領域サイズ      │cacheSize           │
├─┼─────────────┼──────────┤
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
├─┼─────────────┼──────────┤
│Ｗ│(リザーブ)                │(リザーブ)          │'0'固定
└─┴─────────────┴──────────┘

1.11 構造体の共通項目詳細説明

 (1)フォントNo(short int) 
    アプリケーションで文字を要求するときにフォント種を指定する番号です
    (フォントID)。

    この番号はTownsシステムソフトウェアのシステム設定状態により異なる可能性が
    あるために、この番号を固定としたアプリケーションは作成しないでください。

 (2)フォント名(全角 16桁)(半角 32桁)ただし，必要な領域は34バイトです。
    アプリケーションからのフォント一覧要求時に提示する日本語名です。
    ユーザはこの名称でフォントの区別をつけます。

    日本語名はシステム内でダブリがないものとし、また、機械別ただし、必要に設
    定されることはないものとします。アプリケーションはこの日本語名を保存しま
    す。再生などで文字を要求するときは、フォント一覧より同じ日本語名を持つフ
    ォントNoを使用するか、日本語名を指定し、フォントNoを返す関数をコールして
    、取得されるフォントNoを使用します。

 (3)分類区分(short int) 
    フォントの一般的分類です。(明朝体系、ゴシック体系、丸ゴシック体、毛筆体、
    まるもじ系のように区別します。)

        15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │Ｗ│ 0   0   0   0   0   0   0   0   0   0                        │
  └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┬┴┬┴┬┴┬┴┬┴┬┘
      分類名    (一般的文字種)                  │  │  │  │  │  │
      まるもじ系(まるもじ)←──────────┘  │  │  │  │  │
      教科書体系(教科書)←─────────────┘  │  │  │  │
      毛筆体系  (楷書、行書、江戸文字)←────────┘  │  │  │
         丸ｺﾞｼｯｸ体系(中丸･中太丸･太丸･丸ｺﾞｼｯｸ、まるもじ)←─┘  │  │
         ｺﾞｼｯｸ体系  (中･中太･太･ｺﾞｼｯｸ)←────────────┘  │
         明朝体系  (中･中太･太･明朝、教科書)←───────────┘
  
 (4)サポート文字コード(short int ) 
    フォントファイルでサポートしている文字コードの種類の名称です。
  
        15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │Ｗ│ 0   0   0   0   0   0   0   0   0   0                        │
  └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┬┴┬┴┬┴┬┴┬┴┬┘
    欧文文字  ←────────────────┘  │  │  │  │  │
      全角漢字(第二水準)←─────────────┘  │  │  │  │
      全角漢字(第一水準)←───────────────┘  │  │  │
    全角非漢字  ←─────────────────────┘  │  │
        半角文字(ＪIＳ8ビット)←────────────────┘  │
    アスキー文字  ←────────────────────────┘

 (5)データ形式または入力可能ﾃﾞｰﾀ形式(short int ) 
    フォントの情報格納形式などより分類した名称です。
    (ドット形式、ベクトル形式)

    アプリケーションが必要とする文字サイズに適切な文字種を探そうとした場合に
    拡縮自在のベクトル文字かどうかを判定するときに使用します。

        15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │Ｗ│ 0   0   0   0   0   0   0   0   0   0   0   0   0   0        │
  └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┬┴┬┘
      ベクトル形式(アウトライン形式)←─────────────┘  │
    ドットイメージ形式  ←─────────────────────┘

 (6)提供可能ﾃﾞｰﾀ形式または出力データ形式出力可能ﾃﾞｰﾀ形式(short int)
    文字本体の情報提供できる形式です。
    (ドットイメージ形式、アウトラインデータ形式)

    イメージ、アウトラインデータ座標など要求可能な情報形態を知ることが可能に
    なります。

          15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
    │Ｗ│ 0   0   0   0   0   0   0       0   0   0   0   0   0   0    │
    └─┴─┴─┴─┴─┴─┴─┴─┴┬┴─┴─┴─┴─┴─┴─┴─┴┬┘
    アウトラインデータ形式(直線形式)←┘                              │
                             ドットイメージ形式(2値〔1ﾋﾞｯﾄﾋﾟｸｾﾙ〕)←─┘

 (7)付属情報形式(short int) 
    フォントの付属情報の形式です。

    フォントの位置などを制御するための付属情報などに、どのような情報があるか
    を示しています。

        15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │Ｗ│ 0   0   0   0   0   0   0   0   0   0   0   0   0   0   0    │
  └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┬┘
       ﾌﾟﾛﾎﾟｰｼｮﾅﾙ1(文字幅とベースラインのみ)←───────────┘

 (8)基本文字サイズＸ(short int) 
    横方向のフォントデザインの大きさです。

    (ドットイメージのフォントならドット数となり、ベクトル形式なら座標系の最大
    値となります。)

 (9)基本文字サイズＹ(short int) 
    縦方向のフォントデザインの大きさです。

    (ドットイメージのフォントならドット数となり、ベクトル形式なら座標系の最大
    値となります。)

 (10)文字サイズＸ(short int)
     フォントの横方向のサイズです。

 (11)文字サイズＹ(short int)
     フォントの縦方向のサイズです。

 (12)修飾機能1(short int)
     行える修飾機能を示します。

        15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │Ｗ│ 0   0   0   0   0   0   0   0   0                            │
  └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┬┴┬┴┬┴┬┴┬┴┬┴┬┘
                      消し線  ←──────┘  │  │  │  │  │  │
                     ｵｰﾊﾞｰﾗｲﾝ ←────────┘  │  │  │  │  │
                     ｱﾝﾀﾞｰﾗｲﾝ ←──────────┘  │  │  │  │
                      縁取り  ←────────────┘  │  │  │
                      影付    ←──────────────┘  │  │
                      斜体    ←────────────────┘  │
                      太文字  ←──────────────────┘

     - 注意 -
     修飾機能2と合わせて使用した場合は出力結果が異常になる場合があります。
     組み合わせに注意してください。これは、修飾2の機能は複数プレーンを合成
     してはじめてその機能が実現されるため、この複数プレーンに修飾1のイメー
     ジ修飾を行うと合成結果がおかしくなるためです。

 (13)修飾機能2(short int) 
     行える修飾機能を示します。

        15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │Ｗ│ 0   0   0   0   0   0   0   0                                │
  └─┴─┴─┴─┴─┴─┴─┴─┴─┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┘
              領域クリップ    ←────┘  │  │  │  │  │  │  │
              透視変換        ←──────┘  │  │  │  │  │  │
              立体文字        ←────────┘  │  │  │  │  │
              輪郭            ←──────────┘  │  │  │  │
              縁取り          ←────────────┘  │  │  │
              影付            ←──────────────┘  │  │
              斜体            ←────────────────┘  │
              回転            ←──────────────────┘

     - 注意 -
     領域クリップと回転以外の修飾はベクトルフォントでのみ可能です。

 (14)修飾機能能3(short int) 
     行える修飾機能を示します。

        15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │Ｗ│ 0   0   0   0   0   0   0   0   0   0   0       0   0   0   0│
  └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┬┴─┴─┴─┴─┘
              縦書き文字      ←──────────┘

     - 注意 -
     縦書き文字は、全角文字のみ対象です。半角文字は変化しません。

 (15)ﾌｫﾝﾄﾌｧｲﾙ数(short int) 
     フォント種を構成するファイル数です。

 (16)ﾌｫﾝﾄ格納媒体(short int) 
     フォントファイルが格納されている媒体(装置)を示します。

        15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │Ｗ│         0   0   0   0   0   0   0                            │
  └─┴┬┴┬┴─┴─┴─┴─┴─┴─┴─┴┬┴┬┴┬┴┬┴┬┴┬┴┬┘
        │  └────────────┐    │  │  │  │  │  │  │
        └─────────────┐│    │  │  │  │  │  │  │
        0:使用可能  、1:使用不可  ←┘│    │  │  │  │  │  │  │
        0:非交換媒体、1:交換媒体  ←─┘    │  │  │  │  │  │  │
                                            │  │  │  │  │  │  │
          RAMﾃﾞｨｽｸ(非交換媒体)←──────┘  │  │  │  │  │  │
        ﾌﾛｯﾋﾟｨﾃﾞｨｽｸ (交換媒体)←────────┘  │  │  │  │  │
         光磁気ﾃﾞｨｽｸ(交換媒体)←──────────┘  │  │  │  │
           IＣカード(交換媒体)←────────────┘  │  │  │
          CD-ROM    (交換媒体)←──────────────┘  │  │
         ﾊｰﾄﾞﾃﾞｨｽｸ(非交換媒体)←────────────────┘  │
        本体ROM､RAM ←───────────────────────┘

     - 注意 -
     ﾌｫﾝﾄ格納媒体はﾗﾝﾀﾞﾑｱｸｾｽが可能なものに限定します。

 (17)ﾌｧｲﾙ格納場所(char[66]) 
     格納場所をフルパスで指定します。(格納ドライブ名も含む)

 (18)ﾌﾟﾛﾎﾟｰｼｮﾅﾙ情報1(文字幅)
     プロポーショナル文字を指定した場合に実際の文字幅を返します。
     この文字幅には修飾部分は含まれません。

 (19)ﾌﾟﾛﾎﾟｰｼｮﾅﾙ情報1(ﾍﾞｰｽﾗｲﾝ)
     プロポーショナル文字を指定した場合にベースラインの位置を返します。
     この値によってベースラインの調整をします。

2 拡張フォント管理ライブラリ

2.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│FTM_GetWorkSize           │拡張フォント管理ワークサイズ取得          │
├─────────────┼─────────────────────┤
│FTM_Open                  │拡張フォント管理初期化                    │
├─────────────┼─────────────────────┤
│FTM_Close                 │拡張フォント管理終了                      │
├─────────────┼─────────────────────┤
│FTM_OpenCache             │キャッシュ管理の起動                      │
├─────────────┼─────────────────────┤
│FTM_InitCache             │キャッシュ領域の初期化                    │
├─────────────┼─────────────────────┤
│FTM_CloseCache            │キャッシュ管理の終了                      │
├─────────────┼─────────────────────┤
│FTM_GetLogicWorkSize      │論理フォント用ワークサイズ取得            │
├─────────────┼─────────────────────┤
│FTM_SetLogicFont          │論理フォントの設定                        │
├─────────────┼─────────────────────┤
│FTM_ResetLogicFont        │論理フォントの解除                        │
├─────────────┼─────────────────────┤
│FTM_GetFontTableSize      │フォント一覧サイズの取得                  │
├─────────────┼─────────────────────┤
│FTM_GetFontTableSize2     │フォント一覧サイズの取得2                 │
├─────────────┼─────────────────────┤
│FTM_GetFontTable          │フォント一覧の取得                        │
├─────────────┼─────────────────────┤
│FTM_GetFontTable2         │フォント一覧の取得2                       │
├─────────────┼─────────────────────┤
│FTM_GetFontInfo           │フォント情報の取得                        │
├─────────────┼─────────────────────┤
│FTM_GetFontInfo2          │フォント情報の取得2                       │
├─────────────┼─────────────────────┤
│FTM_GetFontNo             │フォントNoの取得                          │
├─────────────┼─────────────────────┤
│FTM_GetFontSize           │フォントサイズの取得                      │
├─────────────┼─────────────────────┤
│FTM_GetFontImage          │フォントイメージの取得                    │
├─────────────┼─────────────────────┤
│FTM_GetFontOutline        │アウトラインデータの取得                  │
├─────────────┼─────────────────────┤
│FTM_SetAtr                │修飾機能設定                              │
├─────────────┼─────────────────────┤
│FTM_SetAtrRotation        │回転修飾機能の設定                        │
├─────────────┼─────────────────────┤
│FTM_SetAtrSlope           │斜体修飾機能の設定                        │
├─────────────┼─────────────────────┤
│FTM_SetAtrShadow          │影付修飾機能の設定                        │
├─────────────┼─────────────────────┤
│FTM_SetAtrBorder          │縁取り修飾機能の設定                      │
├─────────────┼─────────────────────┤
│FTM_SetAtrOutline         │輪郭修飾機能の設定                        │
├─────────────┼─────────────────────┤
│FTM_SetAtrSolid           │立体文字修飾機能の設定                    │
├─────────────┼─────────────────────┤
│FTM_SetAtrPers            │透視変換修飾機能の設定                    │
├─────────────┼─────────────────────┤
│FTM_SetAtrField           │領域･クリップ修飾機能の設定               │
├─────────────┼─────────────────────┤
│FTM_FreeDLL               │呼び出しDLLの解放                         │
└─────────────┴─────────────────────┘

2.2 各関数の解説

-----------------------------------------------------------------------------
.FTM_Close 
拡張フォント管理終了
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_Close (char *pwork);
char      *pwork;             /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ領域ｱﾄﾞﾚｽ    */

- 戻り値 -
0    :正常
負数 :終了処理ができない

- 例 -
#include <ftm.h>
            …
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
            …
/*  拡張フォント管理の終了  */
FTM_Close(Fwork); 

/*  拡張フォント管理ワークの解放  */
free(Fwork);
            …

- 内容 -
拡張フォント管理の終了処理をさせます。
拡張フォント管理ワーク領域の解放はアプリケーションで行ってください。

- 注意 -
拡張フォント管理で独自にメモリを確保している場合が考えられます。そのため、
いったん終了処理をしてから拡張フォント管理ワークを解放してください。
終了処理をしないと、拡張フォント管理で取得したメモリが解放されません。

-----------------------------------------------------------------------------
.FTM_CloseCache
キャッシュ管理の終了
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_CloseCache (char *pwork); 
char      *pwork;         /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ領域ｱﾄﾞﾚｽ  */

- 戻り値 -
0    :正常
負数 :終了処理ができない

- 例 -
#include <ftm.h>
            …
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
char *CacheWork;        /*  フォントキャッシュアドレス      */
            …
                              /*  キャッシュ管理の終了      */
FTM_CloseCache(Fwork);

                              /*  キャッシュ領域の解放      */
free(CacheWork);
            …

- 内容 -
キャッシュ用領域の登録を拡張フォント管理より抹消し、キャッシュ機能を未使用と
します。キャッシュ内容はそのまま保持されます。再びキャッシュ機能を使用したい
場合はキャッシュ管理の起動を実行してください。

- 注意 -
キャッシュ終了処理を実行したあと、キャッシュ領域の解放をしてください。
また、解放はアプリケーションで行ってください。

-----------------------------------------------------------------------------
.FTM_FreeDLL 
呼び出しDLLの解放
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_FreeDLL(char *pwork, int *psize); 
char          *pwork;     /*  拡張フォント管理ワーク領域アドレス  */
int           *psize;     /*  解放領域ｻｲｽﾞ格納ｱﾄﾞﾚｽ               */

- 戻り値 -
0    :解放可能
負数 :解放できないDLLが存在する

- 例 -
#include <ftm.h>
#include <xld.h>
            …
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス      */
int size;                               /*  解放領域サイズ      */
            …
                                  /*  呼び出しDLLの解放         */
if( FTM_FreeDLL(Fwork, &size) == 0) {
                  /*  拡張フォント管理DLLの解放                 */
    if(_XLD_unlink(FTM_GetWorkSize) == 0){
        /*  拡張フォント管理DLLを解放できませんでした           */
    }else{
                                            /*  解放できました  */
    }
}else{
            /*  拡張フォント管理が呼び出したDLLを               */
            /*  解放できませんでした                            */
}
            …

- 内容 -
拡張フォント管理が呼び出したDLLを解放します。

- 注意 -
この関数は拡張フォント管理の初期化から終了までの間で使用してください。
解放領域サイズは解放したDLL領域の合計値です。
必ずしも連続している領域とは限りません。

-----------------------------------------------------------------------------
.FTM_GetFontImage
フォントイメージの取得
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetFontImage(char *plogic, int code); 
char        *plogic;      /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ       */
int         code;         /*  文字コード(シフトＪIＳ)    */

- 戻り値 -
0    :正常
負数 :文字イメージの取得ができない

- 例 -
#include <ftm.h>
            …
char *LogicWork;    /*  論理フォントワーク領域のアドレス  */
FTM_SIZE *FSizeWork;   /*   文字サイズ情報領域のアドレス  */
struct  {
    char *data; 
    unsigned short ds;
    short x1; 
    short y1; 
    short x2; 
    short y2; 
}  EgbPara;
            …
                                /*  フォントサイズの取得  */
FTM_GetFontSize( LogicWork, 0x88A4, &FSizeWork);

/*  必要イメージ領域の取得とイメージ領域オフセットの設定  */
FSizeWork->imageOff = (char *)malloc(FSizeWork->imageSize); 

                                  /*  イメージ領域クリア  */
memset(FSizeWork->imageOff, 0x00, FSizeWork->imageSize);

                              /*  フォントイメージの取得  */
FTM_GetFontImage(LogicWork, 0x88A4);
                                  /*  イメージの画面描画  */
EGB_writeMode(EgbWork, 0);
EgbPara.ds = getds();
EgbPara.x1 = 0;
EgbPara.y1 = 0;

EgbPara.x2 = EgbPara.x1 + 
                      (FSizeWork->rdwX - FSizeWork->lupX);
EgbPara.y2 = EgbPara.y1 + 
                      (FSizeWork->rdwY - FSizeWork->lupY);
for(i=0;i<FSizeWork->planeCnt;i++){
    EgbPara.data = FSizeWork->imageOff +
                                   FSizeWork->planeSize * i 
    EGB_color(EgbWork, 0, FSizeWork->planeTblOff[i]); 
    EGB_putBlockColor(EgbWork, 0, (char *)&EgbPara);
}
            …

- 内容 -
文字コード(シフトJIS)で指定された文字のイメージを取得します。
文字イメージはアプリケーションが用意した領域に書き込まれます。

- 注意 -
文字イメージ格納領域は、フォントサイズの取得関数で指定されただけの領域が確保
されているとして実行します。もし不足している場合はメモリ領域を破壊する可能性
があります。
この関数を実行する前に、文字イメージ格納領域アドレスをフォントサイズ取得関数
で得たFTM_SIZE型構造体領域内のイメージ格納領域オフセットに設定してください。

-----------------------------------------------------------------------------
.FTM_GetFontInfo 
フォント情報の取得
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetFontInfo(char *pwork, short fontNo, FTM_INFO *pinfo); 
char        *pwork;       /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ領域ｱﾄﾞﾚｽ     */
short       fontNo;       /*  フォントNo                   */
FTM_INFO    *pinfo;       /*  ﾌｫﾝﾄ情報格納領域ｱﾄﾞﾚｽ        */

- 戻り値 -
0    :正常
負数 :取得できない

- 例 -
#include <ftm.h>
            …
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
FTM_INFO FontInfo;                       /*   フォント情報  */
            …
                                    /*  フォント情報の取得  */
FTM_GetFontInfo(Fwork, 16, &FontInfo);
            …

- 内容 -
フォントNoで指定されたフォントの詳細情報を取得します。指定フォントのファイル
がアクセス可能か確認して、結果をフォント格納媒体の最上位ビットに設定します。

-----------------------------------------------------------------------------
.FTM_GetFontInfo2
フォント情報の取得2
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetFontInfo2(char *pwork, short fontNo, 
                                FTM_INFO *pinfo, unsigned short check); 
char          *pwork;     /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ 領域ｱﾄﾞﾚｽ  */
short          fontNo;    /*  フォントＮＯ               */
FTM_INFO    *pinfo;       /*  ﾌｫﾝﾄ情報格納領域ｱﾄﾞﾚｽ      */
unsigned short check;     /*  チェック対象媒体指定       */

- 戻り値 -
0    :正常
負数 :取得できない

- 例 -
#include <ftm.h>
            …
char *Fwork;        /*  拡張ﾌｫﾝﾄ管理ワーク領域のアドレス  */
FTM_INFO FontInfo;  /*  フォント情報                      */
            …
/*  フォント情報の取得2  */
FTM_GetFontInfo2(Fwork, 16, &FontInfo, 0);
            …

- 内容 -
フォントNoで指定されたフォントの詳細情報を取得します。チェック対象媒体を指定
した場合は、指定媒体に格納されているフォントファイルがアクセス可能か確認して
、結果をフォント格納媒体の最上位ビットに設定します。
なお、チェック対象媒体はフォント格納媒体と同じフォーマットです。

-----------------------------------------------------------------------------
.FTM_GetFontNo 
フォントNoの取得
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetFontNo(char *pwork, FTM_INFO *pinfo, short *pfontNo); 
char        *pwork;     /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ領域ｱﾄﾞﾚｽ   */
FTM_INFO    *pinfo;     /*  ﾌｫﾝﾄ情報格納領域ｱﾄﾞﾚｽ      */
short       *pfontNo;   /*  ﾌｫﾝﾄNO格納ｱﾄﾞﾚｽ            */

- 戻り値 -
0    :正常
負数 :フォントNoが返せない

- 例 -
#include <ftm.h>
            …
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
FTM_INFO FontInfo;                    /*  フォント情報      */
short fontNo;                         /*  フォントNo        */
            …
                                /*  フォント情報の設定      */
strcpy((char *)(&(FontInfo.fontName)), "明朝体  ﾍﾞｸﾄﾙ(ICｶｰﾄﾞ)");

                                /*  フォントNoの取得        */
FTM_GetFontNo(Fwork, &FontInfo, &fontNo); 
            …

- 内容 -
フォントの各種情報より、一致するフォントNoを取得します。

-----------------------------------------------------------------------------
.FTM_GetFontOutline
アウトラインデータの取得
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetFontOutline(char *plogic, int code); 
char *plogic;       /*  論理ﾌｫﾝﾄﾜｰｸ 領域ｱﾄﾞﾚｽ     */
int   code;         /*  文字コード(シフトＪIＳ)   */

- 戻り値 -
0    :正常
負数 :アウトラインデータの取得ができない

- 例 -
#include <ftm.h>
            …
char *LogicWork;     /*   論理フォントワーク領域のアドレス  */
FTM_SIZE *FSizeWork; /*   文字サイズ情報領域のアドレス      */
            …
/*  フォントサイズの取得  */
FTM_GetFontSize(LogicWork, 0x88A4, &FSizeWork); 

/*  必要アウトラインデータ領域の取得と
                  アウトラインデータ領域オフセットの設定  */
FSizeWork->outlineOff = (char *)malloc(FSizeWork->outlineSize); 

/*  アウトラインデータの取得  */
FTM_GetFontOutline(LogicWork, 0x88A4);
            …

- 内容 -
文字コード(シフトJIS)で指定された文字のアウトラインデータを取得します。
アウトラインデータはアプリケーションが用意した領域に書き込まれます。

- 注意 -
アウトラインデータ格納領域は、フォントサイズの取得関数で指定されただけの領域
が確保されているとして実行します。もし不足している場合はメモリ領域を破壊する
可能性があります。この関数を実行する前にアウトラインデータ格納領域アドレスを
フォントサイズ取得関数で得た、FTM_SIZE型構造体領域内のアウトラインデータ格納
領域オフセットに設定してください。
取得されるアウトラインデータには、修飾機能は無効です。

-----------------------------------------------------------------------------
.FTM_GetFontSize 
フォントサイズの取得
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetFontSize(char *plogic, int code, FTM_SIZE **psize);
char        *plogic;    /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ        */
int         code;       /*  文字コード(シフトＪIＳ)     */
FTM_SIZE    **psize;    /*  文字ｻｲｽﾞ情報領域ｱﾄﾞﾚｽ       */

- 戻り値 -
0    :正常
負数 :文字サイズ情報の取得ができない

- 例 -
#include <ftm.h>
            …
char *LogicWork;  /*  論理フォントワーク領域のアドレス  */
FTM_SIZE *FSizeWork; /*   文字サイズ情報領域のアドレス  */
            …
                             /*  フォントサイズの取得   */ 
FTM_GetFontSize(LogicWork, 0x88A4, &FSizeWork); 
            …

- 内容 -
文字コード(シフトJIS)で指定された文字のサイズ情報を取得します。この文字サイズ
情報領域は論理フォントワーク領域内に確保されていて、この領域のアドレスを渡し
ます。この領域は解放しないでください。

- 注意 -
サイズは修飾機能も含めたサイズが返ります。しかし、プロポーショナル文字の場合
に返されるプロポーショナル情報1には、修飾により変化した分は含みません。

-----------------------------------------------------------------------------
.FTM_GetFontTableSize
フォント一覧サイズの取得
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetFontTableSize(char *pwork, int *pfontCnt); 
char      *pwork;         /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ領域ｱﾄﾞﾚｽ */
int       *pfontCnt;      /*  ﾌｫﾝﾄ数格納領域ｱﾄﾞﾚｽ      */

- 戻り値 -
0以上 :フォント一覧のサイズ
負数  :取得できない

- 例 -
#include <ftm.h>
            …
int size;                          /*   ワーク領域のサイズ  */
int fontCnt;                               /*   フォント数  */
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
            …
                              /*  フォント一覧サイズの取得  */
size =  FTM_GetFontTableSize(Fwork, &fontCnt);
            …

- 内容 -
フォント一覧を格納するのに必要なメモリサイズを取得します。
また、フォント種類の総数を返します。

-----------------------------------------------------------------------------
.FTM_GetFontTableSize2 
フォント一覧サイズの取得2
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetFontTableSize2(char *pwork, int *pfontCnt, 
int getCnt, 0); 
char  *pwork;         /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ 領域ｱﾄﾞﾚｽ    */
int   *pfontCnt;      /*  ﾌｫﾝﾄ数格納領域ｱﾄﾞﾚｽ          */
int    getCnt;        /*  取得する個数                 */
                      /*  0       ＝全て取得           */
                      /*  1 以上  ＝指定された分取得   */

- 戻り値 -
0 以上 :フォント一覧のサイズ
負数   :取得できない

- 例 -
#include <ftm.h>
            …
int   size;       /*  ワーク領域のサイズ                    */
int   fontCnt;    /*  フォント数                            */
char *Fwork;      /*  拡張ﾌｫﾝﾄ管理ワーク領域のアドレス      */
            …
  /*  10個分のフォント一覧を格納するのに必要なサイズの取得  */
size = FTM_GetFontTableSize2(Fwork, &fontCnt, 10, 0);
            …

- 内容 -
指定された個数分のフォント一覧を格納するに必要なメモリサイズを取得します。
また、フォント種類の総数を返します。なお、フォント一覧のサイズは、指定された
個数が0の場合はフォント総数分を返し、指定された個数がフォント総数より小さい
場合は指定された個数分を返し、フォント総数より大きい場合はフォント総数分を返
します。

-----------------------------------------------------------------------------
.FTM_GetFontTable
フォント一覧の取得
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetFontTable(char *pwork, char *ptable, int *pfontCnt, unsigned,
                       short check);
char      *pwork;         /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ領域ｱﾄﾞﾚｽ */
char      *ptable;        /*  ﾌｫﾝﾄ一覧格納領域ｱﾄﾞﾚｽ    */
int       *pfontCnt;      /*  ﾌｫﾝﾄ数格納領域ｱﾄﾞﾚｽ      */
unsigned  short check;    /*  チェック対象媒体指定     */

- 戻り値 -
0    :正常
負数 :取得できない

- 例 -
#include <ftm.h>
            …
int size;                               /*  ワーク領域のサイズ  */
int fontCnt;                                    /*  フォント数  */
char *Fwork;          /*  拡張フォント管理ワーク領域のアドレス  */
FTM_TABLE *FontListTable;     /*  フォント一覧の領域のアドレス  */

                                  /*  フォント一覧サイズの取得  */
size =  FTM_GetFontTableSize(Fwork, &fontCnt);

                                    /*  フォント一覧領域の取得  */
FontListTable =  (FTM_TABLE *)malloc(size); 

                                        /*  フォント一覧の取得  */
FTM_GetFontTable(Fwork, (char *)FontListTable, &fontCnt, 0);
            …

- 内容 -
登録されているフォント一覧を取得します。チェック対象媒体を指定された場合は、
指定媒体に格納されているフォントのファイルがアクセス可能か確認して、結果をフ
ォント格納媒体の最上位ビットにセットします。なお、チェック対象媒体はフォント
格納媒体と同じフォーマットです。フォント一覧はFTM_TABLE構造体がフォント数分繰
り返されています。フォントの数はフォント数格納領域に返されます。

-----------------------------------------------------------------------------
.FTM_GetFontTable2 
フォント一覧の取得2
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetFontTable2(char *pwork, char *ptable, char *pfontCnt,
                      unsigned short check, int start, int getCnt, 0);
char            *pwork;         /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ 領域ｱﾄﾞﾚｽ     */
char            *ptable;        /*  ﾌｫﾝﾄ一覧格納領域ｱﾄﾞﾚｽ         */
int             *pfontCnt;      /*  ﾌｫﾝﾄ数格納領域ｱﾄﾞﾚｽ           */
unsigned short   check;         /*  チェック対象媒体指定          */
int              start;         /*  先頭番号                      */
                                /*  (先頭(0)〜最後(総数-1))       */
int              getCnt;        /*  取得個数                      */
                                /*  0       ＝全て取得            */
                                /*  1 以上  ＝指定分取得          */

- 戻り値 -
0    :正常
負数 :取得できない

- 例 -
#include <ftm.h>
            …
int i,j,k;
int size;                       /*  ワーク領域のサイズ            */
int fontCnt, fontCnt2;          /*  フォント数                    */
char *Fwork;                    /*  拡張ﾌｫﾝﾄ管理ワーク領域のｱﾄﾞﾚｽ */
FTM_TABLE *FontListTable;       /*  フォント一覧の領域のアドレス  */
            …
/*  10個分のフォント一覧を格納するのに必要なサイズの取得          */
size = FTM_GetFontTableSize2(Fwork, &fontCnt, 10, 0);
            …
/*  フォント一覧の取得                                            */
FontListTable = (FTM_TABLE *)malloc(size);
            …

/*  10個ずつフォント情報を取得して表示する  */
for(i=0 ; i<fontCnt ; i+=10){
   /*   指定番目から10個分のフォント一覧の取得  */
    FTM_GetFontTable2(Fwork, (char *)FontListTable, 
                                          &fontCnt2, 0, i, 10 , 0); 
    k = ((i+10 < fontCnt) ? i+10 : fontCnt);
    for(j=i ; j<k ; j++)
        printf("%s\n",(char *)&(FontListTable[j-i].fontName));
}
free(FontListTable);
            …

- 内容 -
先頭番号で指定された情報から取得個数分のフォント一覧を取得します。チェック対
象媒体を指定された場合は、指定媒体に格納されているフォントファイルがアクセス
可能か確認して、結果をフォント格納媒体の最上位ビットにセットします。
なお、チェック対象媒体はフォント格納媒体と同じフォーマットです。
フォント一覧はFTM_TABLE構造体がフォント数分繰り返されています。
フォントの数はフォント数格納領域に返されます。

-----------------------------------------------------------------------------
.FTM_GetLogicWorkSize
論理フォント用ワークサイズ取得
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetLogicWorkSize(void); 

- 戻り値 -
0以上 :論理フォント用ワークサイズ
負数  :ワークサイズが取得できない

- 例 -
#include <ftm.h>
            …
int size;         /*  ワーク領域のサイズ  */
            …
    /*  論理フォント用ワークサイズの取得  */
size =  FTM_GetLogicWorkSize(); 
            …

- 内容 -
論理フォントのワーク領域サイズを取得します。

- 注意 -
論理フォント用ワークサイズは変更される場合があります。
アプリケーションはサイズ固定でプログラミングしないでください。

-----------------------------------------------------------------------------
.FTM_GetWorkSize 
拡張フォント管理ワークサイズ取得
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_GetWorkSize(int mode);
int       mode;           /*  拡張ﾌｫﾝﾄ管理実行ﾓｰﾄﾞ指定 */
                          /*  (固定値0を指定します)    */

- 戻り値 -
0以上 :拡張フォント管理で必要なワークサイズのバイト数
負数  :取得できない

- 例 -
#include <FTM.H>
            …
int size;             /*  ワーク領域のサイズ  */
            …
      /*  拡張フォント管理ワークサイズの取得  */
size =  FTM_GetWorkSize(0); 
            …

- 内容 -
拡張フォント管理で必要とするワーク領域の計算をします。

《拡張フォント管理実行モード》
      0 :通常モード

- 注意 -
拡張フォント管理ワークのサイズは変更される場合がありますので、アプリケーショ
ンはサイズを固定にしてプログラミングしないでください。

-----------------------------------------------------------------------------
.FTM_InitCache 
キャッシュ領域の初期化
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_InitCache (char *pwork, FTM_CACHE *pinfo);
char          *pwork;     /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ領域ｱﾄﾞﾚｽ   */
FTM_CACHE     *pinfo;     /*  ｷｬｯｼｭ情報構造体ｱﾄﾞﾚｽ       */

- 戻り値 -
0    :正常
負数 :初期化できない

- 例 -
#include <ftm.h>
            …
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
char *CacheWork;            /*  フォントキャッシュアドレス  */
FTM_CACHE CacheInfo;                    /*  キャッシュ情報  */
            …
                                    /*  キャッシュ領域確保  */
CacheWork = malloc(64*1024);
                                /*  キャッシュ領域の初期化  */
CacheInfo.cacheOff  = CacheWork ; 
CacheInfo.cacheSize = 64*1024 ; 
FTM_InitCache(Fwork, &CacheInfo); 
            …
                                  /*  キャッシュ管理の起動  */
FTM_OpenCache(Fwork, CacheWork);
            …

- 内容 -
キャッシュ用領域を初期化します。
既存のキャッシュ領域を指定した場合は内容がクリアされます。
また、キャッシュ領域サイズを変更した場合にも初期化する必要があります。

-----------------------------------------------------------------------------
.FTM_Open
拡張フォント管理初期化
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_Open(int mode, char *pwork, void *(*pmalloc)(size_t), 
              void(*pfree)(void*)); 
int       mode;                  /*  拡張ﾌｫﾝﾄ管理実行ﾓｰﾄﾞ指定   */
                                 /*  (固定値0を指定します)      */
char      *pwork                 /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ領域ｱﾄﾞﾚｽ   */
void      *(*pmalloc)(size_t);   /*  ﾒﾓﾘ 取得ﾙｰﾁﾝのｱﾄﾞﾚｽ        */
void      (*pfree)(void *);      /*  ﾒﾓﾘ 解放ﾙｰﾁﾝのｱﾄﾞﾚｽ        */

- 戻り値 -
 0         :正常
-8         :拡張フォント管理ファイルのバージョン、レベルが一致しない
その他負数 :初期化できない

- 例 -
#include <ftm.h>
            …
int size;         /*  ワーク領域のサイズ                    */
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
            …
/*  拡張フォント管理ワークサイズの取得  */
size =  FTM_GetWorkSize(0); 

Fwork = malloc(size); /*  拡張フォント管理ワーク領域の取得  */

/*  拡張フォント管理の初期化  */
FTM_Open(0, Fwork, malloc, free); 
            …

- 内容 -
拡張フォント管理ワーク領域を与え、初期化します。
また、メモリ取得関数と解放関数を登録します。

《拡張フォント管理実行モード》
    0 :通常モード
《拡張フォント管理ワーク領域アドレス》
    拡張フォント管理が各種の状態情報を記録したり、内部で取得したメモリ領域
    のアドレスを記録する領域です。
《メモリ取得および解放ルーチンのアドレス》
    拡張フォント管理が必要となるワーク領域を取得するための関数を設定します。
    GUIライブラリを使用するときと使用しないときでは異なります。

- 注意 -
拡張フォント管理を使う一番最初に行います。また、与えたワーク領域のアドレスは
拡張フォント管理を呼び出すたびに与える必要がありますので、保持しておいてくだ
さい。

-----------------------------------------------------------------------------
.FTM_OpenCache 
キャッシュ管理の起動
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_OpenCache(char *pwork, char *pcache);
char      *pwork;         /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ領域ｱﾄﾞﾚｽ  */
char      *pcache;        /*  キャッシュ領域アドレス    */

- 戻り値 -
0    :正常
負数 :起動できない

- 例 -
#include <ftm.h>
            …
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
char *CacheWork;        /*  フォントキャッシュアドレス      */
FTM_CACHE CacheInfo;                  /*  キャッシュ情報    */
            …
/*  キャッシュ領域確保  */
CacheWork = malloc(64*1024);
            …
/*  キャッシュ領域の初期化  */
CacheInfo.cacheOff  = CacheWork ; 
CacheInfo.cacheSize = 64*1024 ; 
FTM_InitCache(Fwork, &CacheInfo); 

/*  キャッシュ管理の起動  */
FTM_OpenCache(Fwork, CacheWork);
            …

- 内容 -
キャッシュ用領域を拡張フォント管理に登録し、キャッシュ機能を使用可能にします
。キャッシュ領域はアプリケーションにて確保してください。

- 注意 -
キャッシュサイズは登録する文字のサイズや種類、文字数により違いますが、64KB〜
数百KBほど必要です。(最大1MBまで)

-----------------------------------------------------------------------------
.FTM_ResetLogicFont
論理フォントの解除
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_ResetLogicFont(char *plogic); 
char      *plogic;        /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ     */

- 戻り値 -
0    :正常
負数 :解除できない

- 例 -
#include <ftm.h>
            …
char *LogicWork;  /*  論理フォントワーク領域のアドレス  */
            …
                                /*  論理フォントの解除  */
FTM_ResetLogicFont(LogicWork);

                    /*  論理フォント用ワーク領域の解放  */
free(LogicWork);
            …

- 内容 -
論理フォントを解除します。

- 注意 -
論理フォントの解除処理をしてから論理フォント用ワーク領域を解放してください。

-----------------------------------------------------------------------------
.FTM_SetAtr
修飾機能設定
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_SetAtr(char *plogic, FTM_ATR *patr); 
char        *plogic;    /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ     */
FTM_ATR     *patr;      /*  修飾指定のｱﾄﾞﾚｽ          */

- 戻り値 -
0    :正常
負数 :設定できない

- 例 -
#include <ftm.h>
            …
char *Fwork;          /*  拡張フォント管理ワーク領域のアドレス  */
FTM_INFO FontInfo;                       /*   フォント情報      */
char *LogicWork;      /*  論理フォントワーク領域のアドレス      */
FTM_ATR Atr;                                  /*  修飾指定      */
            …
                                    /*  フォント情報の設定      */
strcpy((char *)(&(FontInfo.fontName)), "明朝体  ﾍﾞｸﾄﾙ(ICｶｰﾄﾞ)");

                                    /*  フォントＮＯの取得  */
FTM_GetFontNo( Fwork, &FontInfo, &Atr.fontNo ); 

                            /*  修飾機能のパラメータ作成    */
Atr.sizeX = 48;             /*  文字サイズＸ(48ドット)      */
Atr.sizeY = 48;             /*  文字サイズＹ(48ドット)      */
Atr.outData =  1;     /*  出力データ形式(ドットイメージ)    */
                      /* (アウトラインデータは0x0100を指定) */
Atr.color = 15;                         /*  文字色(15)      */
Atr.atr1 = 0x0006;            /*  修飾機能1(斜体･影付)      */
Atr.atr2 = 0x0000;                  /*  修飾機能2(なし)     */

                              /*  修飾機能パラメータの設定  */
FTM_SetAtr(LogicWork, &Atr);
            …

- 内容 -
修飾指定の構造体で指定された、フォント種、サイズ、修飾で文字を要求することを
設定します。

- 注意 -
指定された修飾パラメータ領域のアドレスは、論理フォントワークに記録されます。
対象の論理フォントを使用しなくなるまで保持してください。修飾機能1と修飾機能2
を合わせて使用した場合は、出力結果が異常になる場合があります。

-----------------------------------------------------------------------------
.FTM_SetAtrBorder
縁取り修飾機能の設定
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_SetAtrBorder(char *plogic, FTM_ATRBORDER *pborder);
char             *plogic;   /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ     */
FTM_ATRBORDER    *pborder;  /*  縁取り修飾ﾊﾟﾗﾒｰﾀｱﾄﾞﾚｽ    */

- 戻り値 -
0    :正常
負数 :設定できない

- 例 -
#include <ftm.h>
            …
char *Fwork;    /*  拡張フォント管理ワーク領域のアドレス*/
FTM_INFO FontInfo;                   /*   フォント情報  */
char *LogicWork;  /*  論理フォントワーク領域のアドレス  */
/*  修飾指定(96dot*96dot, ドットイメージ, 文字色15)     */
FTM_ATR Atr = { 0, 96, 96, 1, 0x0000, 0x0000, 0x0000, 15 };
FTM_ATRBORDER Para;       /*  縁取り修飾機能パラメータ  */
            …
                    /*  縁取り修飾機能のパラメータ作成  */
Para.mode = 0;                    /*  モード色(0)       */
Para.borderDot = 2;               /*  縁のドット数(2)   */
Para.borderCol = 10;              /*  縁の色(10)        */

                    /*  縁取り修飾機能パラメータの設定  */
FTM_SetAtrBorder(LogicWork, &Para); 

                                /*  フォント情報の設定  */
strcpy((char *)(&(FontInfo.fontName)), "明朝体  ﾍﾞｸﾄﾙ(ICｶｰﾄﾞ)");

                                /*  フォントＮＯの取得  */
FTM_GetFontNo(Fwork, &FontInfo, &Atr.fontNo); 

                          /*  修飾機能のパラメータ作成  */
Atr.atr1 = 0x0000;              /*  修飾機能1(なし)     */
Atr.atr2 = 0x0008;            /*  修飾機能2(縁取り)     */

                          /*  修飾機能パラメータの設定  */
FTM_SetAtr(LogicWork, &Atr);
            …

- 内容 -
縁取り修飾のパラメータを設定します。

- 注意 -
指定された修飾パラメータ領域のアドレスは、論理フォントワークに記録されます。
対象の論理フォントを使用しなくなるか、この修飾機能を使用しなくなるまで保持し
てください。この関数では詳細パラメータの設定のみ行っています。縁取り修飾を行
うためには、修飾機能設定関数で指定するFTM_ATR型構造体の修飾機能2も設定する必
要があります。

-----------------------------------------------------------------------------
.FTM_SetAtrField 
領域･クリップ修飾機能の設定
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_SetAtrField(char *plogic, FTM_ATRFIELD *pfield);
char            *plogic;  /*  論理ﾌｫﾝﾄﾜｰｸ 領域ｱﾄﾞﾚｽ      */
FTM_ATRFIELD  *pfield;  /*  領域･ｸﾘｯﾌﾟ修飾ﾊﾟﾗﾒｰﾀ ｱﾄﾞﾚｽ   */

- 戻り値 -
0    :正常
負数 :設定できない

- 例 -
#include <ftm.h>
            …
char *Fwork;          /*  拡張ﾌｫﾝﾄ管理ワーク領域のアドレス  */
FTM_INFO FontInfo;    /*  フォント情報                      */
char *LogicWork;      /*  論理フォントワーク領域のアドレス  */
/*  修飾指定(96dot*96dot, ドットイメージ, 文字色15)         */
FTM_ATR Atr = { 0, 96, 96, 1, 0x0000, 0x0000, 0x0000, 15 }; 
FTM_ATRFIELD Para;    /*  領域･ｸﾘｯﾌﾟ修飾機能パラメータ      */
            …
/*  領域･ｸﾘｯﾌﾟ修飾機能のパラメータ作成                      */
Para.mode   =    0;     /*  モード(ｸﾘｯﾌﾟ無し)               */
Para.fieldX =  640;     /*  領域横ドット数                  */
Para.fieldY =  480;     /*  領域縦ドット数                  */
Para.posX   =  110;     /*  文字左上座標Ｘ                  */
Para.posY   =  140;     /*  文字左上座標Ｙ                  */

/*  領域･ｸﾘｯﾌﾟ修飾機能パラメータの設定  */
FTM_SetAtrField(LogicWork, &Para);

/*  フォント情報の設定  */
strcpy((char *)(&(FontInfo.fontName)), "明朝体  ﾍﾞｸﾄﾙ(ICｶｰﾄﾞ)");

/*  フォントＮＯの取得        */
FTM_GetFontNo(Fwork, &FontInfo, &Atr.fontNo); 

/*  修飾機能のパラメータ作成  */
Atr.atr1 = 0x0000;   /*   修飾機能1(なし)        */
Atr.atr2 = 0x0080;   /*   修飾機能2(領域･ｸﾘｯﾌﾟ)  */

/*  修飾機能パラメータの設定  */
FTM_SetAtr(LogicWork, &Atr);

- 内容 -
領域･クリップ修飾のパラメータを設定します。

- 注意 -
指定された修飾パラメータ領域のアドレスは、論理フォントワークに記録されます。
対象の論理フォントを使用しなくなるか、この修飾機能を使用しなくなるまで保持し
てください。この関数で設定するFTM_FIELD型構造体の領域横ドット数および領域縦ド
ット数の指定値だけのイメージ領域が必要となります。この関数では詳細パラメータ
の設定のみ行っています。領域･クリップ修飾を行うためには、修飾機能設定関数で指
定するFTM_ATR型構造体の修飾機能2も設定する必要があります。

-----------------------------------------------------------------------------
.FTM_SetAtrOutline 
輪郭修飾機能の設定
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_SetAtrOutline(char *plogic, FTM_ATROUTLINE *poutline);
char             *plogic;   /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ     */
FTM_ATROUTLINE   *poutline; /*  輪郭修飾ﾊﾟﾗﾒｰﾀｱﾄﾞﾚｽ      */

- 戻り値 -
0    :正常
負数 :設定できない

- 例 -
#include <ftm.h>
            …
char *Fwork;  /*  拡張フォント管理ワーク領域のアドレス  */
FTM_INFO FontInfo;                   /*   フォント情報  */
char *LogicWork;  /*  論理フォントワーク領域のアドレス  */
/*  修飾指定(96dot*96dot, ドットイメージ, 文字色15)     */
FTM_ATR Atr = { 0, 96, 96, 1, 0x0000, 0x0000, 0x0000, 15 }; 
FTM_ATROUTLINE  Para;         /*  輪郭修飾機能パラメータ  */
            …
                              /*  輪郭修飾機能のパラメータ作成  */
Para.mode = 0;                /*  モード(黒輪郭)        */
Para.outlineDot1 = 3;         /*  輪郭1のドット数(3)    */
Para.outlineCol1 = 10;        /*  輪郭1の色1(10)        */

                      /*  輪郭修飾機能パラメータの設定  */
FTM_SetAtrOutline(LogicWork, &Para);

                                /*  フォント情報の設定  */
strcpy((char *)(&(FontInfo.fontName)), "明朝体  ﾍﾞｸﾄﾙ(ICｶｰﾄﾞ)");

                                /*  フォントＮＯの取得  */
FTM_GetFontNo(Fwork, &FontInfo, &Atr.fontNo); 

                          /*  修飾機能のパラメータ作成  */
Atr.atr1 = 0x0000;              /*  修飾機能1(なし)     */
Atr.atr2 = 0x0010;              /*  修飾機能2(輪郭)     */

                          /*  修飾機能パラメータの設定  */
FTM_SetAtr(LogicWork, &Atr);
            …

- 内容 -
輪郭修飾のパラメータを設定します。

- 注意 -
指定された修飾パラメータ領域のアドレスは、論理フォントワークに記録されます。
対象の論理フォントを使用しなくなるか、この修飾機能を使用しなくなるまで保持し
てください。この関数では詳細パラメータの設定のみ行っています。輪郭修飾を行う
ためには、修飾機能設定関数で指定するFTM_ATR型構造体の修飾機能2も設定する必要
があります。

-----------------------------------------------------------------------------
.FTM_SetAtrPers
透視変換修飾機能の設定
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_SetAtrPers(char *plogic, FTM_ATRPERS *ppers);
char          *plogic;  /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ     */
FTM_ATRPERS   *ppers;   /*  透視変換修飾ﾊﾟﾗﾒｰﾀｱﾄﾞﾚｽ  */

- 戻り値 -
0    :正常
負数 :設定できない

- 例 -
#include <ftm.h>
            …
char *Fwork;  /*  拡張フォント管理ワーク領域のアドレス  */
FTM_INFO FontInfo;                   /*   フォント情報  */
char *LogicWork;  /*  論理フォントワーク領域のアドレス  */
/*  修飾指定(96dot*96dot, ドットイメージ, 文字色15)     */
FTM_ATR Atr = { 0, 96, 96, 1, 0x0000, 0x0000, 0x0000, 15 }; 
FTM_ATRPERS Para;       /*  透視変換修飾機能パラメータ  */
            …
/*  透視変換修飾機能のパラメータ作成  */
Para.lupX =   20;            /*   点ＡのＸ座標          */
Para.lupY =   30;            /*   点ＡのＹ座標          */
Para.rupX =  120;            /*   点ＢのＸ座標          */
Para.rupY =    0;            /*   点ＢのＹ座標          */
Para.rdwX =  140;            /*   点ＣのＸ座標          */
Para.rdwY =  130;            /*   点ＣのＹ座標          */
Para.ldwX =    0;            /*   点ＤのＸ座標          */
Para.ldwY =  100;            /*   点ＤのＹ座標          */

                  /*  透視変換修飾機能パラメータの設定  */
FTM_SetAtrPers(LogicWork, &Para); 

                                /*  フォント情報の設定  */
strcpy((char *)(&(FontInfo.fontName)), "明朝体  ﾍﾞｸﾄﾙ(ICｶｰﾄﾞ)");

                                /*  フォントＮＯの取得  */
FTM_GetFontNo(Fwork, &FontInfo, &Atr.fontNo); 

                          /*  修飾機能のパラメータ作成  */
Atr.atr1 = 0x0000;              /*  修飾機能1(なし)     */

Atr.atr2 = 0x0040 ;         /*  修飾機能2(透視変換)     */

                          /*  修飾機能パラメータの設定  */
FTM_SetAtr( LogicWork, &Atr );
            …

- 内容 -
透視変換修飾のパラメータを設定します。

- 注意 -
指定された修飾パラメータ領域のアドレスは、論理フォントワークに記録されます。
対象の論理フォントを使用しなくなるか、この修飾機能を使用しなくなるまで保持し
てください。透視変換修飾指定時は回転、斜体、影付、縁取り、輪郭、立体文字の各
修飾機能は無効になります。この関数では詳細パラメータの設定のみ行っています。
透視変換修飾を行うためには、修飾機能設定関数で指定するFTM_ATR型構造体の修飾機
能2も設定する必要があります。

-----------------------------------------------------------------------------
.FTM_SetAtrRotation
回転修飾機能の設定
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_SetAtrRotation(char *plogic, FTM_ATRROTAION *protation);
char               *plogic;       /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ    */
FTM_ATRROTATION    *protation;    /*  回転修飾ﾊﾟﾗﾒｰﾀｱﾄﾞﾚｽ     */

- 戻り値 -
0    :正常
負数 :設定できない

- 例 -
#include <ftm.h>
            …
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
FTM_INFO FontInfo;                       /*   フォント情報  */
char *LogicWork;      /*  論理フォントワーク領域のアドレス  */
/*  修飾指定(96dot*96dot, ドットイメージ, 文字色15)         */
FTM_ATR Atr = { 0, 96, 96, 1, 0x0000, 0x0000, 0x0000, 15 }; 
FTM_ATRROTATION Para;           /*  回転修飾機能パラメータ  */
            …
                          /*  回転修飾機能のパラメータ作成  */
Para.mode = 0;                    /*  モード(その場回転)    */
Para.rotationAng = 90;              /*  回転角度(90度)      */

                          /*  回転修飾機能パラメータの設定  */
FTM_SetAtrRotation(LogicWork, &Para); 

                                    /*  フォント情報の設定  */
strcpy((char *)(&(FontInfo.fontName)), "明朝体  ﾍﾞｸﾄﾙ(ICｶｰﾄﾞ)");

                                    /*  フォントNoの取得    */
FTM_GetFontNo(Fwork, &FontInfo, &Atr.fontNo); 

                              /*  修飾機能のパラメータ作成  */
Atr.atr1 = 0x0000 ;                 /*  修飾機能1(なし)     */
Atr.atr2 = 0x0001 ;                 /*  修飾機能2(回転)     */

                              /*  修飾機能パラメータの設定  */
FTM_SetAtr(LogicWork, &Atr);
            …

- 内容 -
回転修飾のパラメータを設定します。

- 注意 -
指定された修飾パラメータ領域のアドレスは、論理フォントワークに記録されます。
対象の論理フォントを使用しなくなるか、この修飾機能を使用しなくなるまで保持し
てください。この関数では詳細パラメータの設定のみ行っています。回転修飾を行う
ためには、修飾機能設定関数で指定するFTM_ATR型構造体の修飾機能2も設定する必要
があります。

-----------------------------------------------------------------------------
.FTM_SetAtrShadow
影付修飾機能の設定
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_SetAtrShadow(char *plogic, FTM_ATRSHADOW *pshadow);
char             *plogic;   /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ     */
FTM_ATRSHADOW    *pshadow;  /*  影付修飾ﾊﾟﾗﾒｰﾀｱﾄﾞﾚｽ      */

- 戻り値 -
0    :正常
負数 :設定できない

- 例 -
#include <ftm.h>
            …
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
FTM_INFO FontInfo;                       /*   フォント情報  */
char *LogicWork;      /*  論理フォントワーク領域のアドレス  */
/*  修飾指定(96dot*96dot, ドットイメージ, 文字色15)         */
FTM_ATR Atr = { 0, 96, 96, 1, 0x0000, 0x0000, 0x0000, 15 }; 
FTM_ATRSHADOW Para;             /*  影付修飾機能パラメータ  */
            …
                          /*  影付修飾機能のパラメータ作成  */
Para.shadowX = 5;                     /*  影の位置Ｘ(5)     */
Para.shadowY = 5;                     /*  影の位置Ｙ(5)     */
Para.shadowCol = 10;                  /*  影の色(10)        */

                          /*  影付修飾機能パラメータの設定  */
FTM_SetAtrShadow(LogicWork, &Para); 

                                    /*  フォント情報の設定  */
strcpy((char *)(&(FontInfo.fontName)), "明朝体  ﾍﾞｸﾄﾙ(ICｶｰﾄﾞ)");

                                    /*  フォントＮＯの取得  */
FTM_GetFontNo(Fwork, &FontInfo, &Atr.fontNo); 

                              /*  修飾機能のパラメータ作成  */
Atr.atr1 = 0x0000;                  /*  修飾機能1(なし)     */
Atr.atr2 = 0x0004;                  /*  修飾機能2(影付)     */

                              /*  修飾機能パラメータの設定  */
FTM_SetAtr(LogicWork, &Atr);
            …

- 内容 -
影付修飾のパラメータを設定します。

- 注意 -
指定された修飾パラメータ領域のアドレスは、論理フォントワークに記録されます。
対象の論理フォントを使用しなくなるか、この修飾機能を使用しなくなるまで保持し
てください。立体文字や輪郭修飾指定時は影付修飾は無効となります。
この関数では詳細パラメータの設定のみ行っています。影付修飾を行うためには、修
飾機能設定関数で指定するFTM_ATR型構造体の修飾機能2も設定する必要があります。

-----------------------------------------------------------------------------
.FTM_SetAtrSlope 
斜体修飾機能の設定
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_SetAtrSlope(char *plogic, FTM_ATRSLOPE *pslope);
char             *plogic;   /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ     */
FTM_ATRSLOPE     *pslope;   /*  斜体修飾ﾊﾟﾗﾒｰﾀｱﾄﾞﾚｽ      */

- 戻り値 -
0    :正常
負数 :設定できない

- 例 -
#include <ftm.h>
            …
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
FTM_INFO FontInfo;                        /*  フォント情報  */
char *LogicWork;  /*  論理フォントワーク領域のアドレス      */
/*  修飾指定(96dot*96dot, ドットイメージ, 文字色15)         */
FTM_ATR Atr = { 0, 96, 96, 1, 0x0000, 0x0000, 0x0000, 15 }; 
FTM_ATRSLOPE Para;            /*  斜体修飾機能パラメータ    */
            …
                          /*  斜体修飾機能のパラメータ作成  */
Para.mode = 0;                        /*  モード(右斜体)    */
Para.slopeAng = 30;                   /*  斜体角度(30度)    */

                          /*  斜体修飾機能パラメータの設定  */
FTM_SetAtrSlope(LogicWork, &Para);

                                    /*  フォント情報の設定  */
strcpy((char *)(&(FontInfo.fontName)), "明朝体  ﾍﾞｸﾄﾙ(ICｶｰﾄﾞ)");

                                    /*  フォントＮＯの取得  */
FTM_GetFontNo(Fwork, &FontInfo, &Atr.fontNo); 

                              /*  修飾機能のパラメータ作成  */
Atr.atr1 = 0x0000;                  /*  修飾機能1(なし)     */
Atr.atr2 = 0x0002;                  /*  修飾機能2(斜体)     */

                              /*  修飾機能パラメータの設定  */
FTM_SetAtr(LogicWork, &Atr);
            …

- 内容 -
斜体修飾のパラメータを設定します。

- 注意 -
指定された修飾パラメータ領域のアドレスは、論理フォントワークに記録されます。
対象の論理フォントを使用しなくなるか、この修飾機能を使用しなくなるまで保持し
てください。
この関数では詳細パラメータの設定のみ行っています。斜体修飾を行うためには、修
飾機能設定関数で指定するFTM_ATR型構造体の修飾機能2も設定する必要があります。

-----------------------------------------------------------------------------
.FTM_SetAtrSolid 
立体文字修飾機能の設定
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_SetAtrSolid(char *plogic, FTM_ATRSOLID *psolid);
char             *plogic;   /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ     */
FTM_ATRSOLID     *psolid;   /*  立体文字修飾ﾊﾟﾗﾒｰﾀｱﾄﾞﾚｽ  */

- 戻り値 -
0    :正常
負数 :設定できない

- 例 -
#include <ftm.h>
            …
char *Fwork;  /*  拡張フォント管理ワーク領域のアドレス  */
FTM_INFO FontInfo;                   /*   フォント情報  */
char *LogicWork;  /*  論理フォントワーク領域のアドレス  */
/*  修飾指定(96dot*96dot, ドットイメージ, 文字色15)     */
FTM_ATR Atr = { 0, 96, 96, 1, 0x0000, 0x0000, 0x0000, 15 }; 
FTM_ATRSOLID  Para;     /*  立体文字修飾機能パラメータ  */
            …
                  /*  立体文字修飾機能のパラメータ作成  */
Para.mode       =  0;   /*  モード(平行移動)            */
Para.posX       = 30;   /*  立体化相対Ｘ座標            */
Para.posY       = 40;   /*  立体化相対Ｙ座標            */
Para.solidCol1  =  7;   /*  立体色1(側面色)             */

                  /*  立体文字修飾機能パラメータの設定  */
FTM_SetAtrSolid(LogicWork, &Para);

                                /*  フォント情報の設定  */
strcpy((char *)(&(FontInfo.fontName)), "明朝体  ﾍﾞｸﾄﾙ(ICｶｰﾄﾞ)");

                                /*  フォントＮＯの取得  */
FTM_GetFontNo(Fwork, &FontInfo, &Atr.fontNo); 

                          /*  修飾機能のパラメータ作成  */
Atr.atr1 = 0x0000;              /*  修飾機能1(なし)     */
Atr.atr2 = 0x0020;          /*  修飾機能2(立体変換)     */

                          /*  修飾機能パラメータの設定  */
FTM_SetAtr( LogicWork, &Atr );
            …

- 内容 -
立体文字修飾のパラメータを設定します。

- 注意 -
指定された修飾パラメータ領域のアドレスは、論理フォントワークに記録されます。
対象の論理フォントを使用しなくなるか、この修飾機能を使用しなくなるまで保持し
てください。
この関数では詳細パラメータの設定のみ行っています。立体修飾を行うためには、修
飾機能設定関数で指定するFTM_ATR型構造体の修飾機能2も設定する必要があります。

-----------------------------------------------------------------------------
.FTM_SetLogicFont
論理フォントの設定
-----------------------------------------------------------------------------

- 定義 -
#include <ftm.h>
int   FTM_SetLogicFont(char *pwork, char *plogic);
char      *pwork;         /*  拡張ﾌｫﾝﾄ管理ﾜｰｸ領域ｱﾄﾞﾚｽ     */
char      *plogic;        /*  論理ﾌｫﾝﾄﾜｰｸ領域ｱﾄﾞﾚｽ         */

- 戻り値 -
0    :正常
負数 :設定できない

- 例 -
#include <ftm.h>
            …
int size;                           /*  ワーク領域のサイズ  */
char *Fwork;      /*  拡張フォント管理ワーク領域のアドレス  */
char *LogicWork;      /*  論理フォントワーク領域のアドレス  */
            …
                      /*  論理フォント用ワークサイズの取得  */
size =  FTM_GetLogicWorkSize(); 

                          /*  論理フォントワーク領域の取得  */
LogicWork = malloc(size);

                                    /*  論理フォントの設定  */
FTM_SetLogicFont(Fwork, LogicWork); 
            …

- 内容 -
論理フォントの登録、初期化をします。

- 注意 -
論理フォント用ワークアドレスは他の関数にて設定する必要がありますので、保持し
ておいてください。

2.3 サンプルプログラム

┌────────────────────────────────────┐
│拡張フォント管理ライブラリ  サンプルプログラム                          │
│■  機能  ■                                                            │
│  1．TownsシステムソフトウェアV2.1内のシステム設定で登録されているフォ  │
│    ント種の文字イメージを表示します。なお、ベクトル文字パターン、ベクト│
│    ル文字パターンIIはICメモリカードスロットに装着することにより、表示さ│
│    れます。                                                            │
│  2．修飾付でフォントを表示します。                                     │
│  3．ランダムなフォント種、ランダムな文字サイズでフォントを表示します。 │
│■  本体･ディスプレイ以外に必要な動作環境  ■                           │
│  1．TownsシステムソフトウェアV2.1                                      │
│     TownsシステムソフトウェアV2.1内のシステム設定で、書体を登録しておく│
│    必要があります。                                                    │
│  2．RAM 2MB以上                                                        │
│  3．キーボード                                                         │
└────────────────────────────────────┘

/****************************************************************/
/*                                                              */
/*      FTMSMP.EXP  /   FTMSMP.C                                */
/*                                                              */
/*      機能概要    ･ 拡張フォント管理ライブラリ                */
/*                    のサンプルプログラム                      */
/*                                                              */
/****************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#include <time.h>
#include <msdos.cf>
#include <egb.h>
#include <fmcfrb.h>
#include <xld.h>

#include <FTM.H>

/****************************************************************/
/*                                                              */
/*      マクロ定義                                              */
/*                                                              */
/****************************************************************/
#define SMALL   96              /* 文字の大きさ(最小) */
#define BIG     (256-SMALL)     /* 文字の大きさ(最大) */

/****************************************************************/
/*                                                              */
/*      型定義                                                  */
/*                                                              */
/****************************************************************/
/*************************************/
/*  EGB_putBlockColor()で使う構造体  */
/*************************************/
typedef struct {
    unsigned    long    data;
    unsigned    short   ds;
    short   lupx, lupy;     /* 左上の座標                       */ 
    short   rdwx, rdwy;     /* 右下の座標                       */ 
}  PBC;

/****************************************************************/
/*                                                              */
/*      グローバル変数                                          */
/*                                                              */
/****************************************************************/

char    EgbWork[1536];      /* EGBワーク領域                    */

char    *FWork;             /* 拡張フォント管理ワークアドレス   */
char    *CacheWork;         /* フォントキャッシュアドレス       */
char    *LogicWork;         /* 論理フォントワークアドレス       */
FTM_SIZE    *FSizeWork;     /* 文字イメージサイズのアドレス     */
FTM_ATR Atr;                /* 修飾指定                         */

short   UseFontNo[150];     /* 使用可能フォントNOを格納する領域 */

jmp_buf jump_buffer; 

/****************************************************************/
/*                                                              */
/*      内部関数のプロトタイプ宣言                              */
/*                                                              */
/****************************************************************/
int DEMO_FTMInit();          /* 拡張フォント管理の初期化        */
int DEMO_LogicFontSet();     /* 論理フォント設定                */
int DEMO_CacheInit(int size);/* キャッシュ管理の初期化          */
int DEMO_FontSelect();       /* フォント選択                    */
int DEMO_AtrSet(short fontNo, short mx, short my, int col, short atr);
                             /* 修飾パラメータの設定            */
int DEMO_ImageWrite(short x, short y, int moji, int mcolor);
                             /* 文字イメージ取得･描画の手順     */
int DEMO_CacheClose();       /* キャッシュ管理の終了            */
int DEMO_LogicFontReset();   /* 論理フォントの解除              */
int DEMO_FTMExit();          /* 拡張フォント管理の終了          */
int DEMO_DLLcheck();         /* ダイナミック実行エラーチェック  */
int DEMO_UseFontShow(FTM_TABLE *p); /* 使用可能なフォントの表示 */
int DEMO_GetCode();          /* 文字列から文字を取り出します    */
int DEMO_GetSlideWord();  /* 全角文字の基準点(左下)調節幅の計算 */
int DEMO_GetSlideByte();  /* 半角文字の基準点(左下)調節幅の計算 */
int DEMO_GetSlidePropo();   /* プロポ文字の基準点(左下)調節幅の計算 */
int DEMO_KanjiMake();       /* 漢字コードつくります                 */
void GraphiucInit();        /* 画面の初期化                         */
int DEMO_palette();         /* パレット設定                         */
void Title();               /* タイトル表示                         */
void DEMO_WaitLoop(int n);  /* 指定時間のウエイト                   */
int DEMO_Message(short x,short y,char *str);
                            /* 指定位置に文字列を表示します         */

/********************************************************************/
/*  void    main()                                                  */
/*                                                                  */
/*      〔機  能〕  メインルーチン                                  */
/*                                                                  */
/********************************************************************/
void main()
{
    short        x=300,y=200;
    unsigned    int key , encode ;
    TIM_CALEN   time;
    short       vx,vy,wx,wy,flag=3;
    int         kanji,color=1;
    int         ErrFlag=0;

    TIM_rdcalendar(&time);
    srand((time.hour+1)*(time.minute+1)*(time.sec+1)*(time.msec+1));

    KYB_init();                         /* キーボードの初期化             */
    GraphiucInit();                     /* グラフィック画面の初期化       */

    Title();                            /* タイトル表示                   */

    _XLD_init(0);                       /* ＤＬＬの初期設定               */
    _XLD_setMemFunc(malloc, free);      /* メモリ割り当て･解放関数の登録  */
    ErrFlag = setjmp(jump  buffer);
    if(ErrFlag)
        exit(1);

    DEMO_FTMInit();                     /* 拡張フォント管理の初期化       */
    DEMO_LogicFontSet();                /* 論理フォントの設定             */

    /************************** デモ その1********************************/
    if(DEMO_FontSelect())               /* フォント選択 */ 
    goto errJmp;
    /************************** デモ その2********************************/
    DEMO_AtrFontShow();                 /* 修飾別フォントの表示 */ 

    /************************** デモ その3********************************/
    /* 終了メッセージの表示 */
    DEMO_Message(-1,480-16,
                "このプログラムを終了する時は、ＥＳＣキーを押して下さい");
    DEMO_CacheInit(64*1024);            /* キャッシュ管理の初期化         */

    vx = 8;                             /* 横の移動量                     */

    if(rand()%2) vx=-vx;                /* スタート方向             */
    vy = 4;                             /* 縦の移動量               */
    if(rand()%2) vy=-vy;                /* スタート方向             */

    kanji = DEMO_KanjiMake();       /* 一番最初の文字コードをセット */
      wx = rand()%BIG+SMALL;      /* 一番最初の文字のサイズをセット */
      wy = rand()%BIG+SMALL;
                            /* 一番最初の文字の修飾パラメータの設定 */
    DEMO_AtrSet(UseFontNo[1+rand()%UseFontNo[0]],wx,wy,255, 0);
    DEMO_palette();                     /* パレットの設定           */
    while(1){
        key = KYB_read(1,&encode);      /* キーの読み取り           */
        if(key == 0x1b)                 /* ESCキーが押されたら終了  */
            break;
        x += vx;                        /* 描画位置移動             */
        y += vy;
        if(x < -96 || x>639){        /* 描画範囲チェック            */
            vx = -vx;
            x += vx;
            flag--;
        }
        if(y < -96 || y>479){        /* 描画範囲チェック            */
            vy = -vy;
            y += vy;
            flag--;
        }
        if(flag < 1){              /* 3回端に当たったら､文字コード  */ 
            kanji = DEMO_KanjiMake();   /* と文字サイズを変えます   */ 
            wx = rand()%BIG+SMALL;
            wy = rand()%BIG+SMALL;
            DEMO_AtrSet(UseFontNo[1+rand()%UseFontNo[0]],wx,wy,255,0);
            flag = 3;
        }
        DEMO_ImageWrite(x, y, kanji, color);  /* 文字イメージの描画 */ 
        if(++color > 246)
            color = 1;
    }

    DEMO_CacheClose();                  /* キャッシュ管理の終了     */ 
errJmp:;
    DEMO_LogicFontReset();              /* 論理フォントの解除       */ 
    DEMO_FTMExit();                     /* 拡張フォント管理の終了   */ 
    EGB_clearScreen( EgbWork );         /* 全画面の消去             */ 
}

/********************************************************************/
/*  int DEMO_FTMInit()                                              */
/*                                                                  */
/*      〔機  能〕  拡張フォント管理の初期化                        */
/*      〔関数値〕  == 0    正常終了                                */
/*                                                                  */
/********************************************************************/
int DEMO_FTMInit()
{

    int size;

    /* 拡張フォント管理ワークサイズの取得 */ 
    size = FTM_GetWorkSize(0);
    DEMO_DLLcheck();               /* ダイナミック実行エラーチェック */ 

    /* 拡張フォント管理ワークの取得 */ 
    FWork = malloc(size);

    /* 拡張フォント管理マネージャーの初期化 */ 
    FTM_Open(0,FWork,malloc,free);
    DEMO_DLLcheck();               /* ダイナミック実行エラーチェック */ 

    return 0;
}

/********************************************************************/
/*  int DEMO_CacheInit(int size)                                    */
/*                                                                  */
/*      〔機  能〕  キャッシュ管理の初期化                          */
/*      〔関数値〕  == 0    正常終了                                */
/*                                                                  */
/********************************************************************/
int DEMO_CacheInit(int size)
{
    FTM_CACHE CacheInfo;

    /* キャッシュ領域確保 */ 
    CacheWork = malloc(size);

    /* キャッシュ領域の初期化 */ 
    CacheInfo.cacheOff = CacheWork; /* キャッシュ領域アドレスのセット */ 
    CacheInfo.cacheSize = size;     /* キャッシュ領域サイズのセット   */ 
    FTM_InitCache( FWork, &CacheInfo );
    DEMO_DLLcheck();                /* ダイナミック実行エラーチェック */ 

    /* キャッシュ管理起動 */ 
    FTM_OpenCache( FWork, CacheWork );
    DEMO_DLLcheck();                /* ダイナミック実行エラーチェック */ 

    return 0;
}

/********************************************************************/
/*  int DEMO_LogicFontSet()                                         */
/*                                                                  */
/*      〔機  能〕  論理フォント設定                                */
/*      〔関数値〕  == 0    正常終了                                */
/*                                                                  */
/********************************************************************/
int DEMO_LogicFontSet()
{
    int size;

    /* 論理フォント領域サイズの取得 */ 
    size = FTM_GetLogicWorkSize();
    DEMO_DLLcheck();                /* ダイナミック実行エラーチェック */ 

    /* 論理フォント領域の取得 */ 
    LogicWork = malloc(size);

    /* 論理フォントの設定 */ 
    FTM_SetLogicFont(FWork,LogicWork);
    DEMO_DLLcheck();                /* ダイナミック実行エラーチェック */ 

    return 0;
}

/********************************************************************/
/*  int DEMO_FontSelect()                                           */
/*                                                                  */
/*      〔機  能〕  フォント選択                                    */
/*      〔関数値〕  == 0    正常終了                                */
/*                  == -1   第一水準の文字イメージが取得可能で使用  */
/*                          可能なフォントが存在しません            */
/********************************************************************/
int DEMO_FontSelect()
{
    FTM_TABLE *FontListTable;
    int FontCnt;
    int i,c,size;

    /* フォント一覧サイズの取得 */ 
    size = FTM_GetFontTableSize(FWork,&FontCnt);
    DEMO_DLLcheck();                /* ダイナミック実行エラーチェック */ 

    /* フォント一覧領域の取得 */ 
    FontListTable = (FTM_TABLE *)malloc(size);

    /* フォント一覧の取得 */ 
    FTM_GetFontTable(FWork,(char *)FontListTable,&FontCnt,0x407f);
    DEMO_DLLcheck();                /* ダイナミック実行エラーチェック */ 

    /* フォント一覧の表示 */ 
    c=0;
    for( i = 0 ; i < FontCnt ; i++ ){
        /* 使用可能なフォントを取得 */
        if( !(FontListTable[i].media & 0x8000)) {
            /* フォント管理情報に登録されているフォントを表示 */ 
            DEMO_UseFontShow(&FontListTable[i]);
            if(((FontListTable[i].supportCode & 0x0008) == 0x0008)){
                /* デモ その3で使用するフォントNOを覚えておきます */ 
                UseFontNo[++c] = FontListTable[i].fontNo;
            }
      }
}

    UseFontNo[0] = c; /* 第一水準の文字イメージが取得可能で使用可能な */ 
                      /* フォント数をセットする                       */ 
    /* フォント一覧領域の解放 */ 
    free(FontListTable);

    if(c == 0)
        return -1;

    return 0;
}

/********************************************************************/
/* int DEMO_AtrSet(short fontNo,short mx,short my,int col,short atr)*/
/*                                                                  */
/*                                                                  */
/*      〔機  能〕  修飾パラメータの設定(修飾機能1)                 */
/*      〔関数値〕  == 0    正常終了                                */
/*                                                                  */
/********************************************************************/
int DEMO_AtrSet(short fontNo, short mx, short my, int col, short atr)
{
    /* 修飾機能のパラメータの作成 */ 
    Atr.fontNo = fontNo;          /* フォントNO     */ 
    Atr.sizeX = mx ;              /* 文字サイズＸ   */ 
    Atr.sizeY = my ;              /* 文字サイズＹ   */ 
    Atr.outData = 1;              /* 出力データ形式 */ 
    Atr.color = col;              /* 文字色         */ 

    Atr.atr1 = atr ;              /* 修飾機能1 */
    Atr.atr2 = 0x0000 ;           /* 修飾機能2 */
    Atr.atr3 = 0x0000 ;           /* 修飾機能3 */

    /* 修飾機能のパラメータの設定 */ 
    FTM_SetAtr(LogicWork,&Atr);
    DEMO_DLLcheck();              /* ダイナミック実行エラーチェック */ 

    return 0;
}

/********************************************************************/
/*  int DEMO_ImageWrite(short x,short y,int moji,int mcolor)        */
/*                                                                  */
/*      〔機  能〕  文字イメージ取得･描画の手順                     */
/*      〔関数値〕  == 0    正常終了                                */
/*                                                                  */
/********************************************************************/
int DEMO_ImageWrite(short x, short y, int moji, int mcolor)
{
    PBC para;
    int ret,MojiColor;

    /* 画面描画モードの設定(PSET) */ 
    EGB_writeMode( EgbWork, 0 );

    /* フォントサイズの取得 */ 
    FTM_GetFontSize(LogicWork,moji,&FSizeWork);
    DEMO_DLLcheck();              /* ダイナミック実行エラーチェック */

    /* 必要イメージ領域の確保 と イメージ領域オフセットの設定 */ 
    FSizeWork->imageOff = 
    (char *)malloc( FSizeWork->imageSize);

    /* 取得領域のクリア */ 
    memset(FSizeWork->imageOff,0x00,FSizeWork->imageSize);

    /* フォントイメージの取得 */ 
    FTM_GetFontImage(LogicWork,moji);
    DEMO_DLLcheck();              /* ダイナミック実行エラーチェック */ 

    /* イメージの画面描画 */ 

    /* 文字の色を設定 */ 
    if(mcolor < 0){
        MojiColor = (int)(*(FSizeWork->planeTblOff));
        EGB_color( EgbWork, 0, MojiColor );
    }else
        EGB_color( EgbWork, 0, mcolor );

    /* 描画位置の初期設定 */
    para.data   = (long)(FSizeWork->imageOff);
    para.ds     = getds();
    para.lupx   = x ;
    para.lupy   = y ;
    para.rdwx   = para.lupx + ( FSizeWork->rdwX - FSizeWork->lupX );
    para.rdwy   = para.lupy + ( FSizeWork->rdwY - FSizeWork->lupY );
    /* ドットデータの書き込み(カラー) */
    EGB_putBlockColor( EgbWork  ,(char *)&para );

    ret = ( FSizeWork->rdwX - FSizeWork->lupX );

    /* イメージ領域の解放 */
    free( FSizeWork->imageOff);

    return ret;
}

/********************************************************************/
/*  int DEMO_LogicFontReset()                                       */
/*                                                                  */
/*      〔機  能〕  論理フォントの解除                              */
/*      〔関数値〕  == 0    正常終了                                */
/*                                                                  */
/********************************************************************/
int DEMO_LogicFontReset()
{
    /* 論理フォントの解除 */
    FTM_ResetLogicFont( LogicWork );
    DEMO_DLLcheck();              /* ダイナミック実行エラーチェック */ 

    /* 論理フォント領域の解放 */
    free( LogicWork );

    return 0;
}

/********************************************************************/
/*  int DEMO_CacheClose()                                           */
/*                                                                  */
/*      〔機  能〕  キャッシュ管理の終了                            */
/*      〔関数値〕  == 0    正常終了                                */
/*                                                                  */
/********************************************************************/
int DEMO_CacheClose()
{
    /* キャッシュ管理の終了 */ 
    FTM_CloseCache( FWork );
    DEMO_DLLcheck();              /* ダイナミック実行エラーチェック */ 

    /* キャッシュ領域の解放 */ 
    free( CacheWork );

    return 0;
}

/********************************************************************/
/*  int DEMO_FTMExit()                                              */
/*                                                                  */
/*      〔機  能〕  拡張フォント管理の終了及びダイナミックリンクラ  */
/*                  イブラリの解放                                  */
/*      〔関数値〕  == 0    正常終了                                */
/*                                                                  */
/********************************************************************/
int DEMO_FTMExit()
{
    int     size;

    if(!FTM_FreeDLL(FWork,&size)){   /* 呼び出しＤＬＬの解放               */
        FTM_Close( FWork );          /* 拡張フォント管理マネージャーの終了 */
        DEMO_DLLcheck();             /* ダイナミック実行エラーチェック     */
        free( FWork );               /* 拡張フォント管理ワークの解放       */
        /* フォント管理マネージャーＤＬＬの解放 */
        if(!(_XLD_unlink(FTM  GetWorkSize))){
            /* フォント管理マネージャーDLLを解放できませんでした */
            DEMO_DLLcheck();         /* ダイナミック実行エラーチェック */ 
        }
    }else{
        /* フォント管理マネージャーが呼び出したDLLを解放できませんでした */
        DEMO_DLLcheck();             /* ダイナミック実行エラーチェック */
    }
    return 0;
}

/********************************************************************/
/*  int DEMO_KanjiMake()                                            */
/*                                                                  */
/*      〔機  能〕  漢字コードつくる                                */
/*                  (シフトJISコード[0x889F(亜) 〜 0x9872(腕))      */
/*      〔関数値〕  == 0    正常終了                                */
/*                                                                  */
/********************************************************************/
int DEMO_KanjiMake()
{
    /* 全角文字のバイト上位,下位反転用共用体 */
    static union         {
        int          code;          /* 文字コード */
        char         moji[2];       /* 文字コード */
    }  Kcode =   { 0x889F };
    int ret;

    if(Kcode.moji[0] == 0x7f){
        Kcode.moji[0]++;
    }
    if(Kcode.moji[0] > 0xfc){
        Kcode.moji[0] = 0x40;
        Kcode.moji[1]++;
    }
    if(Kcode.moji[1] == 0x98 && Kcode.moji[0] == 0x73){
        Kcode.moji[1] = 0x88;
        Kcode.moji[0] = 0x9F;
}

    ret = Kcode.code;
    (Kcode.code)++;

    return ret;
}

/********************************************************************/
/*  int DEMO_DLLcheck()                                             */
/*                                                                  */
/*      〔機  能〕  ダイナミック実行エラーチェック                  */
/*      〔関数値〕  == 0    正常終了                                */
/*                                                                  */
/********************************************************************/
int DEMO_DLLcheck()
{
    char    msg[20];

    int Derr;

    Derr = _XLD_getError();

    if(!Derr)
        return 0;

    sprintf(msg,"エラー番号:%d",Derr);

    DEMO_Message(-1,180,
                "ダイナミックリンクマネージャー実行中にエラー発生");
    DEMO_Message(-1,210,msg);
    DEMO_Message(-1,240,
                "エラー番号については､ダイナミックリンクをご参照ください");

    DEMO_WaitLoop(5);  /* 5秒ウエイト */

    longjmp(jump_buffer,-1);
}
/********************************************************************/
/*  int DEMO_UseFontShow(FTM_TABLE *p)                              */
/*                                                                  */
/*      〔機  能〕  使用可能なフォントの表示                        */
/*      〔入  力〕  p : フォント一覧情報のアドレス                  */
/*                                                                  */
/********************************************************************/
int DEMO_UseFontShow(FTM_TABLE *p)
{
    PBC     PBCpara;
    short   para[4];

    int     code;
    int     cnt;
    short   sizeX,sizeY;    /* イメージ領域の大きさ   */
    short   lenX;           /* 文字の送り幅           */
    short   baseX;          /* 描画文字の左下の基準点 */
    short   slideX,slideY;  /* 描画文字の左下の基準点 */
    char    string[34];

    DEMO_Message(-1,180,(char *)(&(p->fontName)));

    if(p->atrFlag == 0x0001)      /* プロポーショナルかチェック */
        strcpy(string,"abcdefghijklMNOPQRST");
    else{
        strcpy(string,(char *)(&(p->fontName)));
    }
    /* 修飾機能のパラメータの作成 */
    Atr.fontNo = p->fontNo;                       /* フォントNO     */
    Atr.sizeX = ( p->sizeX > 96 ? 96 : p->sizeX); /* 文字サイズＸ   */
    Atr.sizeY = ( p->sizeY > 96 ? 96 : p->sizeY); /* 文字サイズＹ   */
    Atr.outData = 1;                              /* 出力データ形式 */
    Atr.color = 255;                              /* 文字色         */
    Atr.atr1 = 0x0000 ;                           /* 修飾機能1      */
    Atr.atr2 = 0x0000 ;                           /* 修飾機能2      */

    /* 修飾機能のパラメータの設定 */ 
    FTM_SetAtr(LogicWork,&Atr);
    DEMO_DLLcheck();              /* ダイナミック実行エラーチェック */

    /* 画面描画モードの設定 */
    EGB_writeMode( EgbWork, 0 );

    /* 文字列の一文字目の取得 */
    cnt = 0;
    code = DEMO_GetCode( string, &cnt );

    /* 文字の大きさ取得 */
    FTM_GetFontSize( LogicWork,code,&FSizeWork );
    DEMO_DLLcheck();              /* ダイナミック実行エラーチェック */

    /* 必要イメージ領域の確保 と イメージ領域オフセットの設定 */ 
    FSizeWork->imageOff = 
        (char *)malloc( FSizeWork->imageSize);

    /* イメージ領域の大きさ計算 */
    sizeX = FSizeWork->rdwX - FSizeWork->lupX + 1;
    sizeY = FSizeWork->rdwY - FSizeWork->lupY + 1;

    /* 第1文字目の基準点(左下) */
    baseX=20;

    /* 文字の色を設定 */
    /* 色テーブルはサイズ計算の後でないと設定されていないので注意 */
    EGB_color( EgbWork, 0, (int)(*(FSizeWork->planeTblOff)) );

    for( cnt = 0 ; string[cnt] != 0x00 ; )
    {
        /* 文字列より1文字だけ取得 */
        code = DEMO_GetCode( string, &cnt );

        /* イメージ領域のクリア */
        memset(FSizeWork->imageOff,0x00,FSizeWork->imageSize);

        /* 文字イメージの取得 */
        FTM_GetFontImage( LogicWork,code );

        /* 文字種による基準点の調節量と次の文字の送り幅を計算します */
        if(FSizeWork->atrFlag == 0x0001)
            /* プロポ文字 */
            DEMO_GetSlidePropo( &slideX,&slideY,&lenX ); 
        else
            if(code > 0xff)
                /* 全角文字 */
                DEMO_GetSlideWord( &slideX,&slideY,&lenX );
                else
                    /* 半角文字 */
                    DEMO_GetSlideByte( &slideX,&slideY,&lenX );

        /* 描画位置の設定 */
        PBCpara.data    = (int)(FSizeWork->imageOff);
        PBCpara.ds      = getds();
        PBCpara.lupx    = baseX - slideX;
        PBCpara.rdwx    = baseX - slideX + sizeX - 1;
        PBCpara.lupy    = 300 + slideY - sizeY + 1;
        PBCpara.rdwy    = 300 + slideY;

        /* ドットデータの書き込み(カラー) */
        EGB_putBlockColor( EgbWork,1,(char *)&PBCpara );

        /* 次の文字のベースを求めます */
        baseX += lenX;
    }

    /* 描画の後始末 */
    free( FSizeWork->imageOff );

    DEMO_WaitLoop(3);  /* 3秒ウエイト */
    /* 部分画面クリア処理 */
    para[0] = 0; para[1] = 160; para[2] = 639; para[3] = 350;
    EGB_paintMode( EgbWork, 0x20 );
    EGB_color( EgbWork, 2, 0 );
    EGB_rectangle( EgbWork, (char *)&para );
    EGB_paintMode( EgbWork, 0x02 );

    return 0;
}
/********************************************************************/
/*  int DEMO_GetCode( pstring,pcnt )                                */
/*                                                                  */
/*      〔機  能〕  文字列から文字を取り出す                        */
/*                  (1バイトと2バイトを自動判別する)                */
/*                                                                  */
/********************************************************************/
int DEMO_GetCode( pstring,pcnt )
char      *pstring;      /* 対象文字列の先頭アドレスか取り出したいアドレス */
int       *pcnt;         /* 抽出文字のバイト数 */
{
    union     {
        int       code;             /* 文字コード */
        char      moji[4];          /* 文字コード */
    }  code;     /* 全角文字のバイト上位,下位反転用共用体 */

    code.code = 0;
    /* 文字列より先頭の1文字を取得します */
    if( ((pstring[*pcnt] >= 0x81) && (pstring[*pcnt] <= 0x9f))
     || ((pstring[*pcnt] >= 0xe0) && (pstring[*pcnt] <= 0xfc)) )
    {  /* 漢字コード */
        code.moji[1]  = pstring[*pcnt];
        code.moji[0]  = pstring[*pcnt+1];
        (*pcnt)++;                  /* 漢字は1バイト進めます    */
    }
    else
        code.moji[0]  = pstring[*pcnt];
    (*pcnt)++;

    return  code.code;
}

/********************************************************************/
/*  int DEMO_GetSlideWord( pX,pY,pSize )                            */
/*                                                                  */
/*    〔機  能〕  全角文字の基準点(左下)調節幅の計算                */
/*                                                                  */
/********************************************************************/
int DEMO_GetSlideWord( pX,pY,pSize )
short       *pX;        /* 横方向の移動量   */
short       *pY;        /* 縦方向の移動量   */
short       *pSize;     /* 文字送りドット数 */
{
    *pX = *pY =0;

    /* 文字送りのドット数の計算 */
    /* 全角文字の横幅と修飾により太る分だけ文字送りします */
    /* 要はイメージ領域と同じだけ文字送りします */
    *pSize = FSizeWork->rdwX - FSizeWork->lupX + 1;

    return  0;
}
/********************************************************************/
/*  int DEMO_GetSlideByte( pX,pY,pSize )                            */
/*                                                                  */
/*      〔機  能〕  半角文字の基準点(左下)調節幅の計算              */
/*                                                                  */
/********************************************************************/
int DEMO_GetSlideByte( pX,pY,pSize )
short       *pX;        /* 横方向の移動量   */
short       *pY;        /* 縦方向の移動量   */
short       *pSize;     /* 文字送りドット数 */
{
    short   lenX;

    *pX = *pY =0;

    /* イメージ領域計算 */
    lenX = FSizeWork->rdwX - FSizeWork->lupX + 1;
    /* 修飾により太った大きさ計算 */
    lenX -= Atr.sizeX;
    /* 文字送りのドット数の計算 */
    /* 半角文字の横幅と修飾により太る分だけ文字送りします */
    *pSize = lenX + ( Atr.sizeX / 2 );

    return  0;
}
/********************************************************************/
/*  int DEMO_GetSlidePropo( pX,pY,pSize )                           */
/*                                                                  */
/*      〔機  能〕  プロポ文字の基準点(左下)調節幅の計算            */
/*                                                                  */
/********************************************************************/
int DEMO_GetSlidePropo( pX,pY,pSize )
short       *pX;        /* 横方向の移動量 */
short       *pY;        /* 縦方向の移動量 */

short       *pSize;     /* 文字送りドット数 */
{
    short   lenX;

    /* 横方向の移動量計算 */
    /* プロポ文字は半角領域(全角領域の左半分)の中心に置かれます */
    *pX = (Atr.sizeX / 2 - FSizeWork->propo1Size) / 2;
    /* 縦方向の移動量の計算 */
    *pY = FSizeWork->propo1Base;

    /* イメージ領域計算 */
    lenX = FSizeWork->rdwX - FSizeWork->lupX + 1;
    /* 修飾により太った大きさ計算 */
    lenX -= Atr.sizeX;
    /* 文字送りのドット数の計算 */
    /* プロポ文字の横幅と修飾により太る分だけ文字送りします */
    *pSize = lenX + FSizeWork->propo1Size;

    return  0;
}

/********************************************************************/
/*  int DEMO_AtrFontShow()                                          */
/*                                                                  */
/*      〔機  能〕  修飾別の表示                                    */
/*                                                                  */
/********************************************************************/
int DEMO_AtrFontShow()
{
    short   i;
    char    *msg[]={ "ノーマル","太文字","斜体","影付","縁取り" };

    DEMO_Message(-1,20,"修飾");

    for(i=0;i<5;i++){
        DEMO_Message(i*128,95,msg[i]);
        DEMO_AtrSet(UseFontNo[UseFontNo[0]],96,96,255,(i ? 1 << (i-1) : 0));
        DEMO_ImageWrite(i*128, 100, 0x88A4, 255);
    }

    DEMO_WaitLoop(5);             /* 5秒ウエイト  */
    EGB_clearScreen( EgbWork );   /* 全画面の消去 */

    return 0;
}
/********************************************************************/
/*  int DEMO_palette()                                              */
/*                                                                  */
/*      〔機  能〕  パレット設定                                    */
/*                                                                  */
/********************************************************************/
int DEMO_palette()
{
    struct  {

        unsigned int    setSu;
        unsigned int    colorNum;
        unsigned char   Blue, Red, Green;
        unsigned char   zero;
    }  pal;                    /* EGB_palette()で使用する構造体 */

    static struct {
        unsigned short  Blue, Red, Green;
        short   pm[3];
    } p = { 160,200,80,0,-4,4 }; /* パレット変化の初期設定 */

    unsigned short  a;
    int i;

    /* 色識別番号1〜246にパレットを設定します */
    for(i=1;i<247;i++){
        pal.setSu = 1;
        pal.colorNum = i;
        pal.zero = 0;
        p.Blue  += p.pm[0];
        p.Red   += p.pm[1];
        p.Green += p.pm[2];
        pal.Blue = p.Blue;
        pal.Red = p.Red;
        pal.Green = p.Green;
        if(p.Blue==0 || p.Red==0 || p.Green==0 ||
           p.Blue>=252 || p.Red>=252 || p.Green>=252){
           a = p.pm[0]; p.pm[0] = p.pm[1]; p.pm[1] = p.pm[2]; p.pm[2] = a;
        }
        EGB_palette(EgbWork,0,(char *)&pal);
    }
    return 0;
}
/********************************************************************/
/*  int DEMO_Message(short x,short y,char *str);                    */
/*                                                                  */
/*      〔機  能〕  指定位置に文字列を表示します                    */
/*      〔入  力〕  x : 表示位置Ｘ                                  */
/*                  (但し､Ｘ座標が-1の場合は文字列の文字数を計算して*/
/*                  中央にでるようにし､枠も付けます)                */
/*                  y : 表示位置Ｙ                                  */
/*                  str : 表示する文字列                            */
/*      〔関数値〕  == 0    正常終了                                */
/*                                                                  */
/********************************************************************/
int DEMO_Message(short x,short y,char *str)
{
    struct {
        short   x;
        short   y;
        unsigned    short   len;
        char    moji[80];
    }  sjisStr;                    /* EGB_sjisString()で使う構造体 */

    short   para[4];

    EGB_writeMode( EgbWork, 0 );    /* 画面描画モードの設定*/

    sjisStr.x = x;
    sjisStr.y = y;
    sjisStr.len = strlen(str);
    if(x < 0){
        sjisStr.x = (640-(sjisStr.len*8))/2;

        para[0] = sjisStr.x-10;
        para[1] = sjisStr.y-16-5;
        para[2] = sjisStr.x+(sjisStr.len*8)+10;
        para[3] = sjisStr.y+5;
        EGB_paintMode( EgbWork, 0x22 );
        EGB_color( EgbWork, 0, 0 );
        EGB_color( EgbWork, 2, 255 );
        EGB_rectangle( EgbWork, (char *)&para );
    }
    strcpy(sjisStr.moji,str);
    EGB_color( EgbWork, 0, (x < 0  ? 0 : 255));
    EGB_sjisString(EgbWork,(char *)&sjisStr);

    return 0;
}

/********************************************************************/
/*  void    DEMO_WaitLoop(int n)                                    */
/*                                                                  */
/*      〔機  能〕  指定時間のウエイト                              */
/*      〔入  力〕  n : 時間(秒単位)                                */
/*                                                                  */
/********************************************************************/
void DEMO_WaitLoop(int n)
{
    time_t time1,time2;

    time(&time1);
    do{
    time(&time2);
    }while(difftime(time2,time1) < n);
}

/********************************************************************/
/*  void    Title()                                                 */
/*                                                                  */
/*      〔機  能〕  タイトル表示                                    */
/*                                                                  */
/********************************************************************/
void Title()
{
        DEMO_Message(200,220,"  拡張フォント管理ライブラリ");
        DEMO_Message(200,240,"      サンプルプログラム");

        DEMO_WaitLoop(3);            /* 3秒ウエイト  */

        EGB_clearScreen( EgbWork );  /* 全画面の消去 */
}

/********************************************************************/
/*  void    GraphiucInit()                                          */
/*                                                                  */
/*      〔機  能〕  画面の初期化                                    */
/*                                                                  */
/********************************************************************/
void GraphiucInit()
{
    EGB_init(EgbWork,1536);
    EGB_resolution(EgbWork,0,12);
    EGB_displayPage(EgbWork,0,1);
    EGB_writePage(EgbWork,0);
}

*****************************************************************************
第14章  アイテム登録ライブラリ
*****************************************************************************

1 アイテム登録ライブラリについて

1.1 アイテム登録ライブラリ

  アイテムファイルには、Townsシステムソフトウェア V2.1上のアイテム表示ウィン
ドウに表示するアイテムの情報が記録されています。ファイル名は"TMENU.ITM"で各
ドライブのルートディレクトリに存在します。
  各アイテム情報(付属の情報も含む)は、可変長レコードで管理されています。

  ┌────────〜───────────────┐
  │レコード0(ＨＥＡＤＥＲ  ＲＥＣＯＲＤ)           │
  ├────────〜───────────────┤
  │レコード1                                       │
  ├────────〜───────────────┤
  │レコード2                                       │
  ├────────〜───────────────┤
  │レコード3                                       │
  │  …                                            │
  │レコードｎ                                      │
  ├────────〜───────────────┤
  │Ｖ1.1レコード                                   │
  └────────〜───────────────┘
                                                    ↑End of file 

 (1)レコード0
    ルートの登録数、チェックサム、ファイル名が記録されています。
    必ずV1.1レコードが存在するため、最低登録数は1とします。

 (2)レコード1〜レコードn
    アプリケーションレコード、グループレコード、サブディレクトリコードが記録
    されています。

 (3)V1.1レコード
    V1.1のアイテムの登録数などが記録されているレコードです。
    "TMENU.ITM"には必ずこのレコードが一つ存在します。

1.2 アイテム構造について

┌────────────────────────────────────┐
│  ￥  ┌───────┐                                                │
│  ├─┤ｸﾞﾙｰﾌﾟｱｲﾃﾑ(1) │                                                │
│  │  └──┬────┘                                                │
│  │        ├ 1ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ                                           │
│  │        ├ 2ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ                                           │
│  │        ├ 3ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ                                           │
│  │        │┌───────┐                                        │
│  │        └┤ｸﾞﾙｰﾌﾟｱｲﾃﾑ(2) │                                        │
│  │          └──┬────┘                                        │
│  │                ├ 4ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ                                   │
│  │                └ 5ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ                                   │
│  ├ 6ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ                                                     │
│  ├ 7ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ                                                     │
│  └ 8ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ                                                     │
└────────────────────────────────────┘
                  ▼                            ▼
┌────────────────────────────────────┐
│1.HEADER RECORD                                     登録数=4            │
│2.GROUP ITEM RECORD         ｸﾞﾙｰﾌﾟｱｲﾃﾑ1)      登録数=4←┤次ﾎﾟｼﾞｼｮﾝ ─┐│
│3.APPLICATION ITEM RECORD    1ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ      ←┤   │            ││
│4.APPLICATION ITEM RECORD    2ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ      ←┤   │            ││
│5.APPLICATION ITEM RECORD    3ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ      ←┤   │            ││
│6.GROUP ITEM RECORD        ｸﾞﾙｰﾌﾟｱｲﾃﾑ2)  登録数=2←┘   │次ﾎﾟｼﾞｼｮﾝ ┐││
│7.APPLICATION ITEM RECORD    4ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ←┤         │          │││
│8.APPLICATION ITEM RECORD    5ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ←┘         │          │││
│9.APPLICATION ITEM RECORD    6ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ           ←┤←────┴┘│
│A.APPLICATION ITEM RECORD    7ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ           ←┤              │
│B.APPLICATION ITEM RECORD    8ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ           ←┘              │
└────────────────────────────────────┘

1.3 アイテムを追加する

  登録済アイテムで一番右下のアイテム座標を取得し、その右下にアイテムを追加し
ます。(※サンプルプログラムのSample2関数を参照。)

  図EXL121R-030

 (1)アイテムを追加するウィンドウに登録されているアイテムの座標をすべて取得し
    、その中で一番大きい右下座標(x2,y2個別)を検索します。
 (2)検索して得られた座標y2にタイトル文字列のY幅ドット数を追加します。
 (3)追加するアイテムの座標を次のように設定します。
      左上X座標 = x2
      左上Y座標 = y2
      右下X座標 = x2+追加するアイテムのアイコンのX幅
      右下Y座標 = y2+追加するアイテムのアイコンのY幅
 (4)設定した座標がウィンドウからはみ出さないかをチェックします。
    はみ出してしまう場合は、はみ出ないように座標を修正します。
 (5)設定した座標でアイテムを追加します。

1.4 注意事項

 (1)各アイテム(グループ、アプリケーション、サブディレクトリ)はファイルポジシ
    ョン(数値)で指定します。

    例えば、アイテムを削除する場合はファイルポジションを指定して、アイテムの
    削除を行います。ファイルポジションとは、アイテムファイルTMENU.ITMの先頭か
    らの絶対位置(バイト数)です。ファイルポジションはアイテム追加時やキーワー
    ドから取得することができます。

 (2)関数のパラメータについて

  ■文字列引数の文字数
      タイトル文字列  :106文字
      パス文字列      :77文字
      パラメータ文字列:64文字
  ■枠座標
    枠座標はアイテムアイコンの大きさ(タイトル文字列は含みません)とします。

  ■パス文字列
    パス文字列は大文字で指定してください。

 (3)追加/変更/削除時の注意
    追加、変更、削除の関数を呼び出すと、その時点でアイテムファイルが変更され
    るため、その関数の前で取得したファイルポジションの値はすべて無効になりま
    す。
    ※ITM_AddGrpItem:例(2)/ITM_AddAplItem:例(2)/ITM_AddSubDirItem:例(2)参照。

2 アイテム登録ライブラリ

2.1 関数一覧

┌─────────────┬──────────────────────┐
│        関  数  名        │              機          能                │
├─────────────┼──────────────────────┤
│ITM_CreateItemFile        │アイテムファイルの作成                      │
├─────────────┼──────────────────────┤
│ITM_AddGrpItem            │グループアイテムの追加                      │
├─────────────┼──────────────────────┤
│ITM_AddAplItem            │アプリケーションアイテムの追加              │
├─────────────┼──────────────────────┤
│ITM_AddSubDirItem         │サブディレクトリアイテムの追加              │
├─────────────┼──────────────────────┤
│ITM_DelItem               │アイテムの削除                              │
├─────────────┼──────────────────────┤
│ITM_GetHeadFPos           │ヘッダ情報のファイルポジションの取得        │
├─────────────┼──────────────────────┤
│ITM_GetGrpFPos            │ｷｰﾜｰﾄﾞからｸﾞﾙｰﾌﾟｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得     │
├─────────────┼──────────────────────┤
│ITM_GetAplFPos            │ｷｰﾜｰﾄﾞからｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得  │
├─────────────┼──────────────────────┤
│ITM_GetSubDirFPos         │ｷｰﾜｰﾄﾞからｻﾌﾞﾃﾞｨﾚｸﾄﾘｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得 │
├─────────────┼──────────────────────┤
│ITM_GetV11FPos            │ｷｰﾜｰﾄﾞからV1.1ｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得       │
├─────────────┼──────────────────────┤
│ITM_GetItmType            │アイテムの種別の取得                        │
├─────────────┼──────────────────────┤
│ITM_GetPhysclNextFPos     │指定されたｱｲﾃﾑの次のｱｲﾃﾑﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得   │
├─────────────┼──────────────────────┤
│ITM_GetHeadData           │ヘッダ情報の取得                            │
├─────────────┼──────────────────────┤
│ITM_GetGrpData            │ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからｸﾞﾙｰﾌﾟｱｲﾃﾑの情報の取得       │
├─────────────┼──────────────────────┤
│ITM_GetAplData            │ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑの情報の取得    │
├─────────────┼──────────────────────┤
│ITM_GetSubDirData         │ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからｻﾌﾞﾃﾞｨﾚｸﾄﾘｱｲﾃﾑの情報の取得   │
├─────────────┼──────────────────────┤
│ITM_GetV11Data            │ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからV1.1ｱｲﾃﾑの情報の取得         │
├─────────────┼──────────────────────┤
│ITM_ChgGrpData            │グループアイテムデータの変更                │
├─────────────┼──────────────────────┤
│ITM_ChgAplData            │アプリケーションアイテムデータの変更        │
├─────────────┼──────────────────────┤
│ITM_ChgSubDirData         │サブディレクトリアイテムデータの変更        │
├─────────────┼──────────────────────┤
│ITM_GetBaseFPos           │指定されたｱｲﾃﾑの親ｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得   │
├─────────────┼──────────────────────┤
│ITM_GetStair              │指定されたアイテムの階層レベルの取得        │
└─────────────┴──────────────────────┘

2.2 各関数の解説

-----------------------------------------------------------------------------
.ITM_AddAplItem
アプリケーションアイテムの追加
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_AddAplItem(char *ItmPath, int BaseFPos, int IcnNum, char *TtlStr, 
                    char *PathStr, char *ParaStr, int AtrInf, ITMFRM Frm);
char   *ItmPath;        /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ             */
int    BaseFPos;        /*  追加するｸﾞﾙｰﾌﾟのﾌｧｲﾙﾎﾟｼﾞｼｮﾝ */
int    IcnNum;          /*  ｱｲｺﾝ番号                  */
char   *TtlStr;         /*  ﾀｲﾄﾙ文字列                */
char   *PathStr;        /*  ﾊﾟｽ文字列(ﾄﾞﾗｲﾌﾞ名を除く) */
char   *ParaStr;        /*  ﾊﾟﾗﾒｰﾀ文字列              */
int    AtrInf;          /*  属性情報                  */
ITMFRM Frm;             /*  枠情報                    */

- 戻り値 -
正数 :追加したアイテムのファイルポジション
負数 :エラー

- 例 -
(1)ルートに以下の情報のアプリケーションアイテムを追加します。
    追加するｸﾞﾙｰﾌﾟﾌｧｲﾙﾎﾟｼﾞｼｮﾝ : 0 (ﾙｰﾄ) 
      ｱｲｺﾝ番号                : 1024
      ﾀｲﾄﾙ文字列              : APPLICATION ITEM
      ﾌﾟﾛｸﾞﾗﾑ名               : \APL.EXP 
      ﾊﾟﾗﾒｰﾀ                  : なし
      属性                    : 動作ﾓｰﾄﾞ = Townsｼｽﾃﾑｿﾌﾄｳｪｱ V2.1 / ﾃﾞｨﾚｸﾄﾘ移動
                                                                         あり
      枠座標                  : 左上 = (0,0) / 右下 = (24,24)

   #include <item.h> 
               …
   int   AddFPos;
   ITMFRM Frm ={0,0,24,24}; 
               …
   AddFPos = ITM_AddAplItem("D:\\TMENU.ITM",0,1024,"APPLICATION ITEM"
                                                  ,"\\APL.EXP","",2,&Frm);

(2)特定のグループアイテムを検索し、そのグループアイテムを削除してから、アプリ
   ケーションアイテムを追加します。

┌＜良い例＞───────────────────────────────┐
│                                    …                                  │
│DelFPos = ITM_GetGrpFPos("D:\\TMENU.ITM",0,5,-1,"OLD GRP",-1,&Frm);     │
│ITM_DelItem("D:\\TMENU.ITM",DelFPos);                                   │
│AddFPos = ITM_AddAplItem("D:\\TMENU.ITM",0,1024,"NEW APL"               │
│                                                ,"\\APL.EXP","",2,&Frm);│
│                                    …                                  │
└────────────────────────────────────┘
┌＜悪い例＞───────────────────────────────┐
│                                    …                                  │
│DelFPos = ITM_GetGrpFPos("D:\\TMENU.ITM",0,5,-1,"OLD GRP",-1,&Frm);     │
│AddFPos = ITM_AddAplItem("D:\\TMENU.ITM",0,1024,"NEW APL"               │
│                                                ,"\\APL.EXP","",2,&Frm);│
│ITM_DelItem("D:\\TMENU.ITM",DelFPos);                                   │
│                                    …                                  │
└────────────────────────────────────┘
  AddFPosのアプリケーションアイテムが追加されたあと、検索されたグループアイテ
ムDelFPosの値は無効になります。したがってIT_DelItem("D:\\TMENU.ITM",DelFPos);
のアイテム削除処理は不可能です。

- 内容 -
指定されたファイルにアプリケーションアイテムを追加します。
属性情報は以下のようになっています。

          31  30       9   8   7   6   5   4   3   2   1   0
属性情報┌─┬─┬…┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        │  │  │  │  │  │  │  │  │  │  │  │  │  │
 AtrInf └─┴─┴…┴─┴─┴─┴─┴─┴─┴─┴┬┴┬┴┬┘
                                                  │  │  └動作モード
                                                  │  │ (0:TownsOS/1:MS-DOS)
                                                  │  └──ディレクトリ移動
                                                  │     (0:なし / 1:あり) 
                                                  └────V1.1アイテム
                                                         (0:OFF / 1:ON)

- 注意 -
アイテムの追加変更、削除処理を行うと、その前に得られたファイルポジションの値
はすべて無効になります。例(2) を参照してください。

-----------------------------------------------------------------------------
.ITM_AddGrpItem
グループアイテムの追加
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_AddGrpItem(char *ItmPath, int BaseFPos, short IcnNum, 
                      char *TtlStr, ITMFRM *Frm); 
char   *ItmPath;            /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ                 */
int    BaseFPos;            /*  追加するｸﾞﾙｰﾌﾟのﾌｧｲﾙﾎﾟｼﾞｼｮﾝ   */
short  IcnNum;              /*  ｱｲｺﾝ番号                      */
char   *TtlStr;             /*  ﾀｲﾄﾙ文字列                    */
ITMFRM *Frm;                /*  枠座標                        */

- 戻り値 -
正数 :追加したアイテムのファイルポジション
負数 :エラー

- 例 -
(1)ルートに以下の情報のグループアイテムを追加します。
      追加するｸﾞﾙｰﾌﾟﾌｧｲﾙﾎﾟｼﾞｼｮﾝ : 0 (ﾙｰﾄ) 
      ｱｲｺﾝ番号                  : 1024
      ﾀｲﾄﾙ文字列                : GROUP ITEM
      枠座標                    : 左上 = (0,0)/右下 = (24,24)

   #include <item.h> 
               …
   int   AddFPos;
   ITMFRM Frm ={ 0 , 0 , 24 , 24  };
               …
   AddFPos = ITM_AddGrpItem("D:\\TMENU.ITM",0,1024,"GROUP ITEM",&Frm); 

(2)特定のグループアイテムを検索し、そのグループアイテムを削除してから、グルー
   プアイテムを追加します。

┌＜良い例＞───────────────────────────────┐
│                                    …                                  │
│DelFPos = ITM_GetGrpFPos("D:\\TMENU.ITM",0,5,-1,"OLD GRP",-1,&Frm);     │
│ITM_DelItem("D:\\TMENU.ITM",DelFPos);                                   │
│AddFPos = ITM_AddGrpItem("D:\\TMENU.ITM",0,1028,"NEW GRP",&Frm);        │
│                                    …                                  │
└────────────────────────────────────┘
┌＜悪い例＞───────────────────────────────┐
│                                    …                                  │
│DelFPos = ITM_GetGrpFPos("D:\\TMENU.ITM",0,5,-1,"OLD GRP",-1,&Frm);     │
│AddFPos = ITM_AddGrpItem("D:\\TMENU.ITM",0,1028,"NEW GRP",&Frm);        │
│ITM_DelItem("D:\\TMENU.ITM",DelFPos);                                   │
│                                    …                                  │
└────────────────────────────────────┘
  AddFPosのグループアイテムが追加されたあと、検索されたグループアイテム
DelFPosの値は無効になります。したがってITM_Delltem("D:\\TMENU.ITM",DelFPos)の
アイテム削除処理は不可能です。

- 内容 -
指定されたファイルにグループアイテムを追加します。

- 注意 -
アイテムの追加変更、削除処理を行うと、その前に得られたファイルポジションの値
はすべて無効になります。例(2)を参照してください。

-----------------------------------------------------------------------------
.ITM_AddSubDirItem 
サブディレクトリアイテムの追加
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int   ITM_AddSubDirItem(char *ItmPath, int BaseFPos, int IcnNum,
                        char *TtlStr, char *PathStr, ITMFRM Frm); 
char *ItmPath;        /*  アイフムファイルのパス                */
int   BaseFPos;       /*  追加するグループのファイルポジション  */
int   IcnNum;         /*  アイコン番号                          */
char *TtlStr;         /*  タイトル文字列                        */
char *PathStr;        /*  パス文字列 (ドライブ名除く)           */
ITMFRM Frm;           /*  枠情報                                */

- 戻り値 -
正数 :追加したアイテムのファイルポジション
負数 :エラー

- 例1 -
ルートに以下の情報のサブディレクトリアイテムを追加します。
  追加するｸﾞﾙｰﾌﾟﾌｧｲﾙﾎﾟｼﾞｼｮﾝ   : 0(ルート)
  ｱｲｺﾝ番号                    : 1024
  ﾀｲﾄﾙ文字列                  : SUBDIR ITEM 
  ﾊﾟｽ名                       : \SUB
  枠座標                      : 左上 = (0,0)/右下 = (24,24)

  #include <item.h> 
              …
  int   AddFPos;
  ITEMFRM Frm = {0,0,24,24 };
              …
  AddFPos = ITM_AddSubDirItem("D:\\TMENU.ITM",0,1024,"SUBDIR ITEM", 
                                                        "\\SUB",&Frm);

- 例2 -
キーワードから特定のグループアイテムを検索し、そのグループアイテムを削除して
からサブディレクトリアイテムを追加する。

┌＜良い例＞───────────────────────────────┐
│#inclue <item.h>                                                        │
│          │                                                            │
│DelFPos = ITM_GetGrpFPos("D:\\TMENU.ITM",0,5,-1,"OLD GRP",-1,&Frm);     │
│ITM_DelItem("D:\\TMENU.ITM",DelFPos);                                   │
│AddFPos=ITM_AdSubDirItem("D:\\TMENU.ITM",0,1024,"NEW SUB","\\SUB",&Frm);│
│          │                                                            │
└────────────────────────────────────┘
┌＜悪い例＞───────────────────────────────┐
│#inclue <item.h>                                                        │
│          │                                                            │
│DelFPos = ITM_GetGrpFPos("D:\\TMENU.ITM",0,5,-1,"OLD GRP",-1,&Frm);     │
│AddFPos=ITM_AdSubDirItem("D:\\TMENU.ITM",0,1024,"NEW SUB","\\SUB",&Frm);│
│ITM_DelItem("D:\\TMENU.ITM",DelFPos);                                   │
│          │                                                            │
└────────────────────────────────────┘
  AddFPosのサブディレクトリアイテムが追加された後、検索されたグループアイテム
DelFPosの値は無効になります。したがって、ITM_DelItem("D:\\TMENU.ITM",DelFPos)
のアイテム削除処理は不可能です。

- 内容 -
指定されたファイルにサブディレクトリアイテムを追加します。

- 注意 -
アイテム追加/変更/削除処理を行うと、その前で得られたファイルポジションの値は
全て無効になります。(例2参照)

-----------------------------------------------------------------------------
.ITM_ChgAplData
アプリケーションアイテムデータの変更
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int   ITM_ChgAplData(char *ItmPath, int AplFPos, int IcnNum, char *TtlStr,
                     char *PathStr, char *ParaStr, int AtrInf, ITMFRM Frm); 
char   *ItmPath;  /*  アイテムファイルのパス                        */
int     AplFPos;  /*  変更するアイテムのファイルポジション          */
int     IcnNum;   /*  アイコン番号                                  */
char   *TtlStr;   /*  タイトル文字列                                */
char   *PathStr;  /*  パス文字列 (ドライブ名を除く)                 */
char   *ParaStr;  /*  パラメタ文字列                                */
int     AtrInf;   /*  属性情報                                      */
ITMFRM *Frm;      /*  枠情報                                        */

- 戻り値 -
正数 :変更したアイテムのファイルポジション
負数 :エラー

- 例 -
ファイルポジション58のアプリケーションアイテムを変更します。
  変更するｱﾌﾟﾘｹｰｼｮﾝﾌｧｲﾙﾎﾟｼﾞｼｮﾝ : 58
  ｱｲｺﾝ番号                     : 1024
  ﾀｲﾄﾙ文字列                   : APPLICATION ITEM
  ﾌﾟﾛｸﾞﾗﾑ名                    : \APL.EXP 
  ﾊﾟﾗﾒﾀ                        : 無し
  属性                         : 動作モード = TownsOS/ﾃﾞｨﾚｸﾄﾘ移動あり
  枠座標                       : 左上 = (0,0)/右下 = (24,24)

  #include <item.h> 
              …
  int ChgFPos;
  ITMFRM Frm =  {0,0,24,24 };
              …
  ChgFPos = ITM_ChgAplData("D:\\TMENU.ITM",58,1024,"APPLICATION ITEM",
                                                   "\\APL.EXP","",2,&Frm); 

- 内容 -
指定されたファイルポジションのアプリケーションアイテムを変更します。
属性情報についてはITM_AddAplItem関数を参照してください。

- 注意 -
アイテム変更処理を行うと、その前で得られたファイルポジションの値は全て無効に
なります。

-----------------------------------------------------------------------------
.ITM_ChgGrpData
グループアイテムデータの変更
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int   ITM_ChgGrpData(char *ItmPath, int GrpFPos, int EtyNum,
                       short IcnNum, char *TtlStr, ITMFRM *Frm);
char   *ItmPath;  /*  アイテムファイルのパス                        */
int     GrpFPos;  /*  変更するグループのファイルポジション          */
int     EtyNum;   /*  登録数                                        */
short   IcnNum;   /*  アイコン番号                                  */
char   *TtlStr;   /*  タイトル文字列                                */
ITMFRM *Frm;      /*  枠座標                                        */

- 戻り値 -
正数 :変更したアイテムのファイルポジション
負数 :エラー

- 例 -
ファイルポジション34のグループアイテムを変更します。
  変更するｸﾞﾙｰﾌﾟﾌｧｲﾙﾎﾟｼﾞｼｮﾝ : 34
  登録数                    : 8 
  ｱｲｺﾝ番号                  : 1024
  ﾀｲﾄﾙ文字列                : GROUP ITEM
  枠座標                    : 左上 = (0,0)/右下 = (24,24)

  #include <item.h> 
              …
  int ChgFPos;
  ITMFRM Frm =  {0,0,24,24 };
              …
  ChgFPos = ITM_ChgGrpData("D:\\TMENU.ITM",34,8,1024,"GROUP ITEM",&Frm);

- 内容 -
指定されたファイルポジションのグループアイテムの内容を変更します。

- 注意 -
アイテム変更処理を行うと、その前で得られたファイルポジションの値は全て無効に
なります。

-----------------------------------------------------------------------------
.ITM_ChgSubDirData 
サブディレクトリアイテムデータの変更
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int   ITM_ChgSubDirData(char *ItmPath, int DirFPos, int IcnNum, 
char *TtlStr, char *PathStr, ITMFRM Frm); 
char   *ItmPath;  /*  アイテムファイルのパス                        */
int     AplFPos;  /*  変更するアイテムのファイルポジション          */
int     IcnNum;   /*  アイコン番号                                  */
char   *TtlStr;   /*  タイトル文字列                                */
char   *PathStr;  /*  パス文字列 (ドライブ名を除く)                 */
ITMFRM *Frm;      /*  枠情報                                        */

- 戻り値 -
正数 :変更したアイテムのファイルポジション
負数 :エラー

- 例 -
ファイルポジション78のサブディレクトリアイテムを変更します。
  変更するｱﾌﾟﾘｹｰｼｮﾝﾌｧｲﾙﾎﾟｼﾞｼｮﾝ : 78
  ｱｲｺﾝ番号                     : 1024
  ﾀｲﾄﾙ文字列                   : SUBDIR ITEM 
  ﾊﾟｽ名                        : \SUB
  枠座標                       : 左上 = (0,0)/右下 = (24,24)

  #include <item.h> 
              …
  int ChgFPos;
  ITMFRM Frm =  {0,0,24,24 };
              …
  ChgFPos = ITM_ChgSubDirData("D:\\TMENU.ITM",78,1024,"SUBDIR ITEM",
                                                           "\\SUB",&Frm);

- 内容 -
指定されたファイルポジションのサブディレクトリアイテムを変更します。

- 注意 -
アイテム変更処理を行うと、その前で得られたファイルポジションの値は全て無効に
なります。

-----------------------------------------------------------------------------
.ITM_CreateItemFile
アイテムファイルの作成
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_CreateItemFile(char *ItmPath);
char   *ItmPath;         /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ  */

- 戻り値 -
0      :正常終了
その他 :エラーコード

- 例 -
Dドライブのルートにアイテムファイルを作成します。

#include <item.h> 
            …
ITM_CreateItemFile("D:\\TMENU.ITM");

- 内容 -
指定されたパスにアイテムファイルを作成します。
アイテムファイル名はTMENU.ITMとします。

- 注意 -
すでにTMENU.ITMが存在する場合は、内容を消去して新規に作成します。

-----------------------------------------------------------------------------
.ITM_DelItem 
アイテムの削除
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_DelItem(char *ItmPath, int DelFPos);
char   *ItmPath;    /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ             */
int    DelFPos;     /*  削除するｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝ */

- 戻り値 -
0    :正常終了
負数 :エラー

- 例 -
ファイルポジションが25のアイテムを削除します。

#include <item.h> 
            …
ITM_DelItem("D:\\TMENU.ITM",25);

- 内容 -
グループアイテムのファイルポジションが指定されたときは、そのグループアイテム
内のアイテムもすべて削除します。
Townsシステムソフトウェア V1.1アイテムなど、特殊アイテムは削除不可とします。

- 注意 -
アイテム削除処理を行うと、その前に得られたファイルポジションの値はすべて無効
になります。

-----------------------------------------------------------------------------
.ITM_GetAplData
ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑの情報の取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_GetAplData(char *ItmPath, int AplFPos, short *IcnNum,
                      char   *TtlStr, char *PathStr, char *ParaStr, 
                      int    AtrInf, ITMFRM *Frm);
char   *ItmPath;    /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ                 */
int    AplFPos;     /*  ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝ    */
short  *IcnNum;     /*  ｱｲｺﾝ番号を格納するｱﾄﾞﾚｽ       */
char   *TtlStr;     /*  ﾀｲﾄﾙ文字列を格納するｱﾄﾞﾚｽ     */
char   *PathStr;    /*  ﾊﾟｽ文字列を格納するｱﾄﾞﾚｽ      */
char   *ParaStr;    /*  ﾊﾟﾗﾒｰﾀ文字列を格納するｱﾄﾞﾚｽ   */
int    *AtrInf;     /*  属性情報を格納するｱﾄﾞﾚｽ       */
ITMFRM *Frm;        /*  枠座標を格納する構造体のｱﾄﾞﾚｽ */

- 戻り値 -
0    :正常終了
負数 :エラー

- 例 -
ファイルポジションが104のアプリケーションアイテムの情報を取得します。

#include <item.h> 
            …
short  IcnNum;
char   TtlStr[107]; 
char   PathStr[78]; 
char   ParaStr[65]; 
int    AtrInf;
ITMFRM Frm; 
            …
ITM_GetAplData("D:\\TMENU.ITM",104,&IcnNum,TtlStr 
                                           ,PathStr,ParaStr,&AtrInf,&Frm);

- 内容 -
指定されたファイルポジションのアプリケーションアイテムの情報を取得します。
指定されたファイルポジションがアプリケーションアイテム以外のときはエラーとな
ります。

-----------------------------------------------------------------------------
.ITM_GetAplFPos
ｷｰﾜｰﾄﾞからｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_GetAplFPos(char *ItmPath, int StartFPos, short IcnNum,
                      char *TtlStr, char *PathStr, char *ParaStr, 
                      int AtrInf, ITMFRM Frm);
char   *ItmPath;   /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ        */
int    StartFPos;  /*  検索開始ﾌｧｲﾙﾎﾟｼﾞｼｮﾝ  */
short  IcnNum;     /*  ｱｲｺﾝ番号             */
char   *TtlStr;    /*  ﾀｲﾄﾙ文字列           */
char   *PathStr;   /*  ﾊﾟｽ文字列            */
char   *ParaStr;   /*  ﾊﾟﾗﾒｰﾀ文字列         */
int    AtrInf;     /*  属性情報             */
ITMFRM *Frm;       /*  枠座標               */

- 戻り値 -
正数 :一致したアプリケーションアイテムのファイルポジション
負数 :一致するアプリケーションアイテムが存在しない

- 例 -
以下の情報のアプリケーションアイテムを最初から探します。
  ｱｲｺﾝ番号     : 1024 
  ﾀｲﾄﾙ文字列   : APPLICATION
  ﾊﾟｽ文字列    : \APL.EXP 
  ﾊﾟﾗﾒｰﾀ文字列 : 不明
  属性情報     : 不明
  FRAME        : 不明

  #include <item.h> 
              …
  int   AplFPos;
  ITMFRM Frm ={-1,-1,-1,-1}; 
              …
  ITM_GetAplFPos("D:\\TMENU.ITM",0,1024,"APPLICATION","\\APL.EXP" 
                                                       ,NULL,-1,&Frm);

- 内容 -
StartFPosからアプリケーションアイテムの情報を取得し、指定されたパラメータと
比較して一致したアプリケーションアイテムのファイルポジションを取得します。
文字列パラメータでNULL、数値パラメータで負数が指定された場合は、その情報の
比較を無視して検索します。

-----------------------------------------------------------------------------
.ITM_GetBaseFPos 
指定されたｱｲﾃﾑの親のｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_GetGrpFPos(char *ItmPath, int ItmFPos);
char   *ItmPath;    /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ      */
int    ItmFPos;     /*  ｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝ  */

- 戻り値 -
正数 :指定されたアイテムの親のファイルポジション
負数 :エラー

- 例 -
ファイルポジションが84のアイテムの親のファイルポジションを取得します。

#include <item.h> 
            …
int  BaseFPos;
            …
BaseFPos = ITM_GetGrpFPos("D:\\TMENU.ITM",84); 

- 内容 -
指定されたアイテムのファイルポジションから、その親のアイテムのファイルポジシ
ョンを取得します。

-----------------------------------------------------------------------------
.ITM_GetGrpData
ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからｸﾞﾙｰﾌﾟｱｲﾃﾑの情報の取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_GetGrpData(char *ItmPath, int GrpFPos, int *EtyNum, 
                      chort *IcnNum, char *TtlStr,
                      int *NextFPos, ITMFRM *Frm);
char   *ItmPath;    /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ                  */
int    GrpFPos;     /*  ｸﾞﾙｰﾌﾟｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝ        */
int    *EtyNum;     /*  登録数を格納するｱﾄﾞﾚｽ          */
short  *IcnNum;     /*  ｱｲｺﾝ番号を格納するｱﾄﾞﾚｽ        */
char   *TtlStr;     /*  ﾀｲﾄﾙ名を格納するｱﾄﾞﾚｽ          */
int    *NextFPos;   /*  次ﾌｧｲﾙﾎﾟｼﾞｼｮﾝを格納するｱﾄﾞﾚｽ   */
ITMFRM *Frm;        /*  枠座標を格納する構造体のｱﾄﾞﾚｽ  */

- 戻り値 -
0    :正常終了
負数 :エラー

- 例 -
ファイルポジョンが72のグループアイテムの情報を取得します。

#include <item.h> 
            …
int    EtyNum;
short  IcnNum;
char   TtlStr[107]; 
int    NextFPos;
ITMFRM Frm; 
            …
ITM_GetGrpData("D:\\TMENU.ITM",72,&EtyNum,&IcnNum,TtlStr,&NextFPos,&Frm); 

- 内容 -
指定されたファイルポジションのグループアイテムの情報を取得します。
指定されたファイルポジションがグループアイテム以外のときはエラーとなります。

-----------------------------------------------------------------------------
.ITM_GetGrpFPos
ｷｰﾜｰﾄﾞからｸﾞﾙｰﾌﾟｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_GetGrpFPos(chan *ItmPath, int StartFPos, int EtyNum,
                    short IcnNum, char *TtlStr, int NextFPos, ITMFRM *Frm); 
char   *ItmPath;  /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ       */ 
int    StartFPos; /*  検索開始ﾌｧｲﾙﾎﾟｼﾞｼｮﾝ */ 
int    EtyNum;    /*  登録数              */ 
short  IcnNum;    /*  ｱｲｺﾝ番号            */ 
char   *TtlStr;   /*  ﾀｲﾄﾙ文字列          */ 
int    NextFPos;  /*  次ﾌｧｲﾙﾎﾟｼﾞｼｮﾝ       */ 
ITMFRM *Frm;      /*  枠座標              */ 

- 戻り値 -
正数 :一致したグループアイテムのファイルポジション
負数 :一致するグループアイテムが存在しない

- 例 -
以下の情報のグループアイテムを最初から探します。
  登録数        : 5 
  ｱｲｺﾝ番号      : 不明
  ﾀｲﾄﾙ文字列    : GROUP1
  次ﾌｧｲﾙﾎﾟｼﾞｼｮﾝ : 不明
  枠座標        : 不明

  #include <item.h> 
              …
  ITMFRM Frm ={-1,-1,-1,-1}; 
              …
  GrpFPos = ITM_GetGrpFPos("D:\\TMENU.ITM",0,5,-1,"GROUP1",-1,&Frm);

- 内容 -
StartFPosからグループアイテムの情報を取得し、指定されたパラメータと比較して
一致したグループアイテムのファイルポジションを取得します。
文字列パラメータでNULL、数値パラメータで負数が指定された場合は、その情報の
比較を無視して検索します。

-----------------------------------------------------------------------------
.ITM_GetHeadData 
ヘッダ情報の取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int   ITM_GetHeadData(char *ItmPath, int *EtyNum, int *CRC, char *NameStr); 
char *ItmPath;  /*  アイテムファイルのパス                  */
int  *EtyNum;   /*  登録数を格納するアドレス                */
int  *CRC;      /*  CRC を格納するアドレス                  */
char *NameStr;  /*  アイテムファイル名を格納するアドレス    */

- 戻り値 -
0    :正常終了
負数 :エラー

- 例 -
72のグループアイテムの情報を取得します。

#include <item.h> 
            …
int  EtyNum;
int  CRC; 
char Namestr[80]; 
            …
ITM_GetGrpData("D:\\TMENU.ITM", &EtyNum, &CRC, NameStr);

- 内容 -
ヘッダ情報を取得します。

-----------------------------------------------------------------------------
.ITM_GetHeadFPos 
ヘッダ情報のファイルポジションの取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int   ITM_GetHeadFPos(char *ItmPath); 
char *ItmPath;     /* アイテムファイルのパス          */

- 戻り値 -
正数 :ヘッダ情報のファイルポジション
負数 :ヘッダ情報が存在しない
      (指定したファイルはアイテムファイルではない)

- 例 -
ヘッダ情報のファイルポジションを取得します。

#include <item.h> 
            …
HeadFPos = ITM_GetHeadFPos("D:\\TMENU.ITM");

- 内容 -
ヘッダ情報のファイルポジションを取得します。アイテムファイルには、必ずヘッダ
情報が存在します。したがって、関数値が負数の場合は指定したファイルがアイテム
ファイルではないということを表します。

-----------------------------------------------------------------------------
.ITM_GetItmType
アイテムの種別の取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_GetItmType(char *ItmPath, int ItmFPos);
char   *ItmPath;   /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ        */
int    ItmFPos;    /*  ｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝ    */

- 戻り値 -
0    :ヘッダ情報                      〔HEADER_RECORD〕
1    :グループアイテム                〔GROUP_RECORD〕
2    :アプリケーションアイテム        〔APPLICATION_RECORD〕
3    :V1.1グループアイテム            〔V11ITEM_RECORD〕
4    :ディレクトリ (ファイル) アイテム〔SU_DIR_RECORD〕
                                    ※〔  〕内はITEM.Hに定義されている
負数 :エラー

- 例 -
ファイルポジションが53のアイテムの種別を取得します。

#include <item.h> 
            …
int   ItmType;
            …
ItmType = GetItmType("D:\\TMENU.ITM",53); 

- 内容 -
指定されたアイテムのファイルポジションからアイテム種別を取得します。

-----------------------------------------------------------------------------
.ITM_GetPhysclNextFPos 
指定されたアイテムの次のアイテムファイルポジションの取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_GetPhysclNextFPos(char *ItmPath, int CrntFPos); 
char   *ItmPath;     /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ       */
int    CrntFPos;     /*  ｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝ   */

- 戻り値 -
正数 :次のアイテムのファイルポジション
負数 :エラー

- 例 -
ファイルポジションが25の次のアイテムのファイルポジションを取得します。

#include <item.h> 
            …
int  NextFPos;
            …
NextFPos = ITM_GetPhysclNextFPos("D:\\TMENU.ITM",25);

- 内容 -
指定されたアイテムの、次のアイテムのファイルポジションを取得します。
指定されたアイテムがグループアイテムの場合はそのグループアイテムと同階層のア
イテムのファイルポジションを取得するのではなく、そのグループ内のアイテムのフ
ァイルポジションを取得します。

-----------------------------------------------------------------------------
.ITM_GetStair
指定されたアイテムの階層レベルの取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int    ITM_GetStair(char *ItmPath, int FPos);
char   *ItmPath;    /*  ｱｲﾃﾑﾌｧｲﾙのﾊﾟｽ      */
int    FPos;        /*  ｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝ  */

- 戻り値 -
正数 :指定されたアイテムの階層レベル
負数 :エラー

- 例 -
ファイルポジションが104のアイテムの階層レベルを取得します。

#include <item.h> 
            …
int  Stair; 
            …
Stair = ITM_GetStair("D:\\TMENU.ITM",104);

- 内容 -
指定されたアイテムの階層レベル(0=ルート/1=ルートに登録されているグループ下…)
を取得します。

-----------------------------------------------------------------------------
.ITM_GetSubDirData 
ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからｻﾌﾞﾃﾞｨﾚｸﾄﾘｱｲﾃﾑの情報の取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int   ITM_GetSubDirData(char *ItmPath, int DirFPos, short *IcnNum,
                        char *TtlStr, char *PathStr, ITMFRM *Frm);
char   *ItmPath;  /*  アイテムファイルのパス                    */
int     DirFPos;  /*  ｻﾌﾞﾃﾞｨﾚｸﾄﾘｱｲﾃﾑのファイルポジション        */
short  *IcnNum;   /*  アイコン番号を格納するアドレス            */
char   *TtlStr;   /*  タイトル文字列を格納するアドレス          */
char   *PathStr;  /*  パス文字列を格納するアドレス              */
ITMFRM *Frm;      /*  枠座標を格納するアドレス                  */

- 戻り値 -
0    :正常終了
負数 :エラー

- 例 -
104のサブディレクトリアイテムの情報を取得します。

#include <item.h> 
            …
shot IcnNum;
char Ttlstr[107]; 
char PathStr[78]; 
ITMFRM Frm; 
            …
ITM_GetAplData("D:\\TMENU.ITM",104,&IcnNUm,TtlStr,PathStr,&Frm);

- 内容 -
指定されたファイルポジションのサブディレクトリアイテムの情報を取得します。
指定されたファイルポジションがサブディレクトリアイテム以外の時は、エラーとな
ります。

-----------------------------------------------------------------------------
.ITM_GetSubDirFPos 
ｷｰﾜｰﾄﾞからｻﾌﾞﾃﾞｨﾚｸﾄﾘｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int   ITM_GetSubDirFPos(char *ItmPath, int StartPath, short IcnNum, 
                        char *TtlStr, char *PathStr, ITMFRM *Frm);
char   *ItmPath;    /*  アイテムファイルのパス        */
int     StartPath;  /*  検索開始ファイルポジション    */
short   IcnNum;     /*  アイコン番号                  */
char   *TtlStr;     /*  タイトル文字列                */
char   *PathStr;    /*  パス文字列                    */
ITMFRM *Frm;        /*  枠座標                        */

- 戻り値 -
正数 :一致したサブディレクトリアイテムのファイルポジション
負数 :一致するサブディレクトリアイテムが存在しない

- 例 -
以下の情報のサブディレクトリアイテムを最初から探します。
  ｱｲｺﾝ番号   : 1024 
  ﾀｲﾄﾙ文字列 : SUBDIR 
  ﾊﾟｽ文字列  : \SUB 
  FRAME      : 不明

  #include <item.h> 
              …
  int AplFPos;
  ITMFRM Frm ={-1,-1,-1,-1 };
              …
  ITM_GetSubDirFPos("D:\\TMENU.ITM",0,1024,"SUBDIR","\\SUB",&Frm);

- 内容 -
StartFPosからサブディレクトリアイテムの情報を取得し、指定されたパメラータと
比較して一致したサブディレクトリアイテムのファイルポジションを取得します。
文字列パラメータでNULL、数値パラメータで負数が指定された場合は、その情報の
比較を無視して検索します。

-----------------------------------------------------------------------------
.ITM_GetV11Data
ﾌｧｲﾙﾎﾟｼﾞｼｮﾝからV1.1ｱｲﾃﾑの情報の取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int   ITM_GetV11Data(char *ItmPath, int V11FPos, int *EtyNum, 
                 short *IcnNum, char *TtlStr, int *NextFPos, ITMFRM *Frm);
char   *ItmPath;  /*  アイテムファイルのパス                        */
int     V11FPos;  /*  V1.1ｱｲﾃﾑのファイルポジション                  */
int    *EtyNum;   /*  登録数を格納するアドレス                      */
short  *IcnNum;   /*  アイコン番号を格納するアドレス                */
char   *TtlStr;   /*  タイトル文字列を格納するアドレス              */
int    *NextFPos; /*  次のファイルポジションを格納するアドレス      */
ITMFRM *Frm;      /*  枠座標を格納する構造体アドレス                */

- 戻り値 -
0    :正常終了
負数 :エラー

- 例 -
72のV1.1アイテムの情報を取得します。

#include <item.h> 
            …
int EtyNum; 
short IcnNum; 
char TtlStr[107]; 
int NextFPos; 
ITMFRM Frm; 
            …
ITM_GetV11Data("D:\\TMENU.ITM",72,&EtyNum,&IcnNum,TtlStr,&NextFPos,&Frm); 

- 内容 -
指定されたファイルポジションのV1.1アイテムの情報を取得します。
指定されたファイルポジションがV1.1アイテム以外の時はエラーとなります。

-----------------------------------------------------------------------------
.ITM_GetV11Fpos
ｷｰﾜｰﾄﾞからV1.1ｱｲﾃﾑのﾌｧｲﾙﾎﾟｼﾞｼｮﾝの取得
-----------------------------------------------------------------------------

- 定義 -
#include <item.h> 
int   ITM_GetV11FPos(char *ItmPath, int StartFPos, int EtyNum,
                   short IcnNum, char *TtlStr, int NextFPos, ITMFRM *Frm);
char   *ItmPath;      /*  アイテムファイルのパス              */
int     StartFPos;    /*  検索開始ファイルポジション          */
int     EtyNum;       /*  登録数                              */
short   IcnNum;       /*  アイコン番号                        */
char   *TtlStr;       /*  タイトル文字列                      */
int     NextFPos;     /*  次のファイルポジション              */
ITMFRM *Frm;          /*  枠座標                              */

- 戻り値 -
正数 :一致したV1.1アイテムのファイルポジション
負数 :一致するV1.1アイテムが存在しない

- 例 -
以下の情報のV1.1アイテムを最初から探します。
  登録数          : 5 
  ｱｲｺﾝ番号        : 不明
  ﾀｲﾄﾙ文字列      : V1.1アイテム
  次のﾌｧｲﾙﾎﾟｼﾞｼｮﾝ : 不明
  枠座標          : 不明

  #include <item.h> 
              …
  ITMFRM Frm ={-1,-1,-1,-1 };
              …
  V11FPos = ITM_GetV11FPos("D:\\TMENU.ITM",0,5,-1,"V1.1ｱｲﾃﾑ",-1,&Frm);

- 内容 -
StartFPosからV1.1アイテムの情報を取得し、指定されたパラメータと比較し一致し
たV1.1アイテムのファイルポジションを取得します。文字列パラメータでNULL、
数値パラメータで負数が指定された場合は、その情報の比較を無視して検索します。

2.3 サンプルプログラム

┌────────────────────────────────────┐
│  アイテム登録ライブラリ                                                │
│  ■  機能  ■                                                          │
│    アイテムの階層表示、登録、詳細情報の表示を行います。                │
└────────────────────────────────────┘

/*■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■                 アイテム作成ライブラリサンプルプログラム               ■
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■*/
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    <fcntl.h>
#include    <io.h>
#include    <conio.h>
#include    <jctype.h>
#include    <dos.h>
#include    "item.h"

void    DspSpc();
void    InputNum();
void    InputStr();
void    InputChr();

void main()
{
    int     ContFlg = 1;
    int     SlctNum;

    do
    {
        printf("★★★★★★★★★サンプルプログラムメニュー★★★★★★★★★\n\n");
        printf("1:登録されているアイテムのタイトルを階層表示します\n\n");
        printf("2:指定されたグループアイテムのウィンドウ上であいているスペー\n");
        printf("  スを検索してその場所にアイテムを登録します\n\n");
        printf("3:グループアイテムを追加してそのクループアイテムの下にアプリ\n");
        printf("  ケーションアイテムを追加します\n\n");
        printf("4:現在わかっているデータを元にそのデータと一致するアイテムを\n");
        printf("  すべて検索し詳細情報を表示します\n\n");
        printf("5:終了\n\n");
        printf("★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★\n");
        InputNum("番号を選択してください(1〜5):",&SlctNum,1,5);

        switch(SlctNum)
        {
            case    1:
                Sample1();
                break;
            case    2:
                Sample2();
                break;
            case    3:
                Sample3();
                break;
            case    4:
                Sample4();
                break;
            case    5:
                ContFlg = 0;
        }

    } while(ContFlg);

    exit(0);
}

/*■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■             登録されているアイテムのタイトルを階層表示します           ■
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■*/
int Sample1()
{
    int     Stair;
    int     FPos = 0;
    int     EtyNum;
    int     AtrInf;
    int     NextFPos;
    char    ItmPath[16] = "?:\\TMENU.ITM";
    char    TtlStr[96];
    char    PathStr[80];
    char    ParaStr[72];
    short   IcnNum;
    ITMFRM  Frm;

    InputChr("アイテムファイルのドライブ=",&ItmPath[0],'A','z');

    do
    {
        Stair = ITM_GetStair(ItmPath,FPos);     /*  ｱｲﾃﾑの階層取得        */
        switch(ITM_GetItmType(ItmPath,FPos))    /*  ｱｲﾃﾑ種別取得･比較     */
        {
            case    HEADER_RECORD:
                printf("%05d:ルート\n",FPos);
                break;
            case    GROUP_RECORD:
                ITM_GetGrpData(ItmPath,FPos,&EtyNum,&IcnNum,TtlStr,&NextFPos,
                                                                       &Frm);
                DspSpc(Stair*4);               /*  ｸﾞﾙｰﾌﾟｱｲﾃﾑ情報取得･表示 */
                printf("%05d:%s\n",FPos,TtlStr);
                break;
            case    APPLICATION_RECORD:

                ITM_GetAplData(ItmPath,FPos,&IcnNum,TtlStr,PathStr,ParaStr,
                                                              &AtrInf,&Frm);
                DspSpc(Stair*4);                /*  ｱﾌﾟﾘｱｲﾃﾑ情報取得･表示 */
                printf("%05d:%s\n",FPos,TtlStr);
                break;
            case    V11ITEM_RECORD:
                printf("%05d:V1.1ｱｲﾃﾑ\n",FPos);
                break;
            case    SUB_DIR_RECORD:
                printf("%05d:ｻﾌﾞﾃﾞｨﾚｸﾄﾘｱｲﾃﾑ\n",FPos);
                break;
            default:
                printf("%05d:不明\n",FPos);
        }                                   /*  次のｱｲﾃﾑﾌｧｲﾙﾎﾟｼﾞｼｮﾝ取得 */
    } while((FPos = ITM_GetPhysclNextFPos(ItmPath,FPos)) >= 0);

    return(0);
}

void    DspSpc(SpcNum)               /*  指定された数の空白を表示します  */
int     SpcNum;
{
    int     i;

    for(i=0;i<SpcNum;i++)
        printf(" ");

    return;
}

/*■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ 指定されたアイテムウィンドウ上であいているスペースを検索してアイテムを ■
■ 登録します                                                             ■
■────────────────────────────────────■
■ 一番右下に登録されているアイテムを検索し、そのアイテムの右下の空白に新 ■
■ しいアイテムを登録します                                               ■
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■*/
int Sample2()
{
    int     FPos = 0;
    int     EtyNum;
    int     BaseFPos;
    int     NextFPos;
    int     AtrInf;
    int     Tmp;
    int     WidthX;
    int     WidthY;
    int     AddFPos;
    char    ItmPath[16] = "?:\\TMENU.ITM";
    char    TtlStr[96];
    char    PathStr[80];

    char    ParaStr[72];
    short   IcnNum;
    ITMFRM  Frm;
    ITMFRM  RDwnFrm;

    InputChr("アイテムファイルのドライブ=",&ItmPath[0],'A','z');

    RDwnFrm.x2 = 0;                  /*  最右下の空白座標初期化   */ 
    RDwnFrm.y2 = 0;

    printf("空白座標検索中...\n");

    while((FPos = ITM_GetPhysclNextFPos(ItmPath,FPos)) > 0)
    {                                        /*  最右下の空白座標を検索  */
        if(ITM_GetStair(ItmPath,FPos) == 0)  /*  ﾙｰﾄのときのみ           */
        {
            switch(ITM_GetItmType(ItmPath,FPos))
            {
                case    GROUP_RECORD:
                    ITM_GetGrpData(ItmPath,FPos,&EtyNum,&IcnNum,TtlStr,&NextFPos, &Frm);
                    break;
                case    APPLICATION_RECORD:
                    ITM_GetAplData(ItmPath,FPos,&IcnNum,TtlStr,PathStr,ParaStr, &AtrInf,&Frm);
            }

            if(RDwnFrm.x1 < Frm.x2)         /*  最右下になる座標を検出   */ 
                RDwnFrm.x1 = Frm.x2;
            if(RDwnFrm.y1 < Frm.y2)
                RDwnFrm.y1 = Frm.y2;
        }
    }

    printf("空白座標検索終了\n");

    AtrInf = 0;                             /*  各項目入力               */ 
    InputNum("追加するグループのファイルポジション=",&BaseFPos,0,32768);
    InputNum("アイコン番号=",&IcnNum,1024,32768);
    InputStr("タイトル名=",TtlStr,1,106);
    InputStr("パス名=",PathStr,1,76);
    InputStr("パラメタ=",ParaStr,0,64);
    InputNum("動作モード(0:TownsOS/1:MS-DOS/2:V1.1)=",&Tmp,0,2);
    switch(Tmp)
    {
        case    1:
            AtrInf |= 1;
            break;
        case    2:
            AtrInf |= 4;
    }
    InputNum("ディレクトリ移動(0:なし/1:あり)=",&Tmp,0,1);
    if(Tmp)
        AtrInf |= 2;

    InputNum("アイテムの大きさ(X幅)=",&WidthX,24,256);
    InputNum("アイテムの大きさ(Y幅)=",&WidthY,24,256);

    RDwnFrm.y1 += ITM_TTL_XWIDTH;       /*  ﾀｲﾄﾙ文字の分下に下げます    */ 
    RDwnFrm.x2 = RDwnFrm.x1 + WidthX;
    RDwnFrm.y2 = RDwnFrm.y1 + WidthY;

    if(RDwnFrm.x2 > WINUSER_MAX_X)    /*  指定したｱｲﾃﾑの座標がｳｨﾝﾄﾞｳﾕｰｻﾞ  */
    {                              /*  枠の右下からはみ出てしまう場合は、 */
        RDwnFrm.x2 = WINUSER_MAX_X;   /* はみでないように座標を修正します */
        RDwnFrm.x1 = RDwnFrm.x2 - WidthX;
    }
    if(RDwnFrm.y2 > WINUSER_MAX_Y)
    {
        RDwnFrm.y2 = WINUSER_MAX_Y;
        RDwnFrm.y1 = RDwnFrm.y2 - WidthY;
    }

    AddFPos = ITM_AddAplItem(ItmPath,BaseFPos,IcnNum,TtlStr,PathStr,ParaStr, AtrInf,&RDwnFrm);

    if(AddFPos < 0)
        printf("アイテム登録に失敗しました\n");
    else
        printf("アイテム登録しました\n");

    return(0);
}

/*■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■  グループアイテムを追加してそのグループアイテムの下にアプリケーション  ■
■  アイテムを追加します                                                  ■
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■*/
int Sample3()
{
    int     BaseFPos;
    int     AtrInf;
    int     Tmp;
    int     GrpAddFPos;
    int     AplAddFPos;
    char    ItmPath[16] = "?:\\TMENU.ITM";
    char    TtlStr[96];
    char    PathStr[80];
    char    ParaStr[72];
    short   IcnNum;
    ITMFRM  Frm;

    InputChr("アイテムファイルのドライブ=",&ItmPath[0],'A','z');

    printf("**********グループアイテム設定**********\n");  /*  各項目入力  */
    InputNum("追加するグループのファイルポジション=",&BaseFPos,0,32768);
    InputNum("アイコン番号=",&IcnNum,1024,32768);
    InputStr("タイトル名=",TtlStr,1,106);

    InputNum("枠座標(左上X)=",&Frm.x1,0,WINUSER_MAX_X);
    InputNum("枠座標(左上Y)=",&Frm.y1,0,WINUSER_MAX_Y);
    InputNum("枠座標(右下X)=",&Frm.x2,0,WINUSER_MAX_X);
    InputNum("枠座標(右下Y)=",&Frm.y2,0,WINUSER_MAX_Y);

    GrpAddFPos = ITM_AddGrpItem(ItmPath,BaseFPos,IcnNum,TtlStr,&Frm);
    if(GrpAddFPos < 0)                          /*  ｸﾞﾙｰﾌﾟｱｲﾃﾑ追加   */
    {
        printf("グループアイテム登録に失敗しました\n");
        return(-1);
    }

    printf("**********アプリケーションアイテム設定**********\n");
    AtrInf = 0;                                 /*  各項目入力       */
    InputNum("アイコン番号=",&IcnNum,1024,32768);
    InputStr("タイトル名=",TtlStr,1,106);
    InputStr("パス名=",PathStr,1,76);
    InputStr("パラメタ=",ParaStr,0,64);
    InputNum("動作モード(0:TownsOS/1:MS-DOS/2:V1.1)=",&Tmp,0,2);
    switch(Tmp)
    {
        case    1:
            AtrInf |= 1;
            break;
        case    2:
            AtrInf |= 4;
    }
    InputNum("ディレクトリ移動(0:なし/1:あり)=",&Tmp,0,1);
    if(Tmp)
        AtrInf |= 2;
    InputNum("枠座標(左上X)=",&Frm.x1,0,WINUSER_MAX_X);
    InputNum("枠座標(左上Y)=",&Frm.y1,0,WINUSER_MAX_Y);
    InputNum("枠座標(右下X)=",&Frm.x2,0,WINUSER_MAX_X);
    InputNum("枠座標(右下Y)=",&Frm.y2,0,WINUSER_MAX_Y);

    AplAddFPos = ITM_AddAplItem(ItmPath,GrpAddFPos,IcnNum,TtlStr,PathStr,ParaStr, AtrInf,&Frm);
    if(AplAddFPos < 0)                  /*  ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ追加       */
    {
        printf("アプリケーションアイテム登録に失敗しました\n");
        return(-1);
    }
    return(0);
}

/*■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■  現在わかっているデータを元にそのデータと一致するアイテムを全て検索し  ■
■  詳細情報を表示します                                                  ■
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■*/
int Sample4()
{
    int     FPos = 0;
    int     EtyNum;

    int     NextFPos;
    int     AtrInf;
    int     Tmp;
    int     ItmType;
    int     InputFlg;
    int     KeyEtyNum;
    int     KeyNextFPos;
    int     KeyAtrInf;
    int     ItmCnt;
    char    *KeyTtlPtr;
    char    *KeyPathPtr;
    char    *KeyParaPtr;
    short   IcnNum;
    short   KeyIcnNum;
    char    ItmPath[16] = "?:\\TMENU.ITM";
    char    TtlStr[96];
    char    PathStr[80];
    char    ParaStr[72];
    char    KeyTtlStr[96];
    char    KeyPathStr[80];
    char    KeyParaStr[72];
    ITMFRM  KeyFrm;
    ITMFRM  Frm;

    KeyTtlPtr = KeyTtlStr;                  /*  文字列でなく数値を設定   */
    KeyPathPtr = KeyPathStr;                /*  する場合があるのでﾎﾟｲﾝﾀ  */
    KeyParaPtr = KeyParaStr;                /*  を使用します             */

    InputChr("アイテムファイルのドライブ=",&ItmPath[0],'A','z');

    InputNum("アイテム種別(0:グループ/1:アプリケーション)",&ItmType,0,1);

    if(ItmType)                             /*  ｱﾌﾟﾘｹｰｼｮﾝｱｲﾃﾑ検索        */
    {
        KeyAtrInf = 0;

        InputNum("アイコン番号(0:無視/1:入力)",&InputFlg,0,1);
        if(InputFlg)                            /*  入力時               */
            InputNum("アイコン番号=",&KeyIcnNum,1024,32768);
        else                                 /*  無視するときは-1を設定  */
            KeyIcnNum = -1;

        InputNum("タイトル名(0:無視/1:入力)",&InputFlg,0,1);
        if(InputFlg)                            /*  入力時               */
            InputStr("タイトル名=",KeyTtlPtr,1,106);
        else                                 /*  無視するときはNULLを設定*/
            KeyTtlPtr = NULL;

        InputNum("パス名(0:無視/1:入力)",&InputFlg,0,1);
        if(InputFlg)                            /*  入力時               */
            InputStr("パス名=",KeyPathPtr,1,76);
        else                                 /*  無視するときはNULLを設定 */
            KeyPathPtr = NULL;

        InputNum("パラメタ(0:無視/1:入力)",&InputFlg,0,1);
        if(InputFlg)                            /*  入力時               */
            InputStr("パラメタ=",KeyParaPtr,0,64);
        else                                /*  無視するときはNULLを設定 */
            KeyParaPtr = NULL;

        InputNum("動作モード･ディレクトリ移動(0:無視/1:入力)",&InputFlg,0,1);
        if(InputFlg)                            /*  入力時                */
        {

            InputNum("動作モード(0:TownsOS/1:MS-DOS/2:V1.1)=",&Tmp,0,2);
            switch(Tmp)
            {
                case    1:
                    KeyAtrInf |= 1;
                    break;
                case    2:
                    KeyAtrInf |= 4;
            }

            InputNum("ディレクトリ移動(0:無視/1:入力)",&InputFlg,0,1);
            if(InputFlg)
            {
                InputNum("ディレクトリ移動(0:なし/1:あり)=",&Tmp,0,1);
                if(Tmp)
                    KeyAtrInf |= 2;
            }
        }
        else                                /*  無視するときは-1を設定  */
            KeyAtrInf = -1;

        InputNum("座標(0:無視/1:入力)",&InputFlg,0,1);
        if(InputFlg)                        /*  入力時                  */
        {
            InputNum("枠座標(左上X)=",&KeyFrm.x1,0,WINUSER_MAX_X);
            InputNum("枠座標(左上Y)=",&KeyFrm.y1,0,WINUSER_MAX_Y);
            InputNum("枠座標(右下X)=",&KeyFrm.x2,0,WINUSER_MAX_X);
            InputNum("枠座標(右下Y)=",&KeyFrm.y2,0,WINUSER_MAX_Y);
        }
        else                                 /*  無視するときは-1を設定  */
        {
            KeyFrm.x1 = -1;
            KeyFrm.y1 = -1;
            KeyFrm.x2 = -1;
            KeyFrm.y2 = -1;
        }

        ItmCnt = 0;                          /*  一致するｱｲﾃﾑ個数初期化  */
        FPos = 0;                            /*  ﾙｰﾄから検索します       */
        while(1)
        {
            FPos = ITM_GetAplFPos(ItmPath,FPos,KeyIcnNum,KeyTtlPtr,KeyPathPtr, KeyParaPtr,KeyAtrInf,&KeyFrm);

            if(FPos < 0)                     /*  一致するｱｲﾃﾑがないときは */
                break;                       /*  検索終了                */

            ItmCnt++;

            ITM_GetAplData(ItmPath,FPos,&IcnNum,TtlStr,PathStr,ParaStr,&AtrInf,&Frm);
                                             /*  詳細情報取得            */
            printf("%d *********************************\n",ItmCnt);
            printf("ファイルポジション=%05d\n",FPos); /*  各項目内容表示  */
            printf("アイコン番号=%d\n",IcnNum);
            printf("タイトル名=%s\n",TtlStr);
            printf("パス名=%s\n",PathStr);
            printf("パラメタ=%s\n",ParaStr);
            printf("動作モード=");
            if(AtrInf && 4)
                printf("V1.1\n");
            else if(AtrInf && 1)
                printf("MS-DOS\n");
            else
                printf("TownsOS\n");
            printf("ディレクトリ移動=");
            if(AtrInf && 2)
                printf("あり\n");
            else
                printf("なし\n");
            printf("枠座標(左上X)=%d\n",Frm.x1);
            printf("枠座標(左上Y)=%d\n",Frm.y1);
            printf("枠座標(右下X)=%d\n",Frm.x2);
            printf("枠座標(右下Y)=%d\n",Frm.y2);

            FPos = ITM_GetPhysclNextFPos(ItmPath,FPos); 
            /* 次のｱｲﾃﾑから再検索します  */
        }
        printf("************************************\n",ItmCnt);
        if(ItmCnt)
            printf("以上の%d個のアイテムが一致しました\n",ItmCnt);
        else
            printf("一致するアイテムはありません\n");
    }
    else                                    /*  ｸﾞﾙｰﾌﾟｱｲﾃﾑ検索          */
    {
        KeyAtrInf = 0;

        InputNum("登録数(0:無視/1:入力)",&InputFlg,0,1);
        if(InputFlg)                        /*  入力時                  */
            InputNum("登録数=",&KeyEtyNum,0,32768);
        else                                /*  無視するときは-1を設定  */
            KeyEtyNum = -1;

        InputNum("アイコン番号(0:無視/1:入力)",&InputFlg,0,1);
        if(InputFlg)                        /*  入力時                  */
            InputNum("アイコン番号=",&KeyIcnNum,1024,32768);
        else                                /*  無視するときは-1を設定  */
            KeyIcnNum = -1;

        InputNum("タイトル名(0:無視/1:入力)",&InputFlg,0,1);
        if(InputFlg)                        /*  入力時                  */
            InputStr("タイトル名=",KeyTtlPtr,1,106);
        else                                /*  無視するときはNULLを設定 */
            KeyTtlPtr = NULL;

        InputNum("次ファイルポジション(0:無視/1:入力)",&InputFlg,0,1);
        if(InputFlg)                        /*  入力時                  */
            InputStr("次ファイルポジション=",&KeyNextFPos,0,32768);
        else                                /*  無視するときは-1を設定  */
            KeyNextFPos = -1;
        InputNum("座標(0:無視/1:入力)",&InputFlg,0,1);
        if(InputFlg)                        /*  入力時                  */
        {
            InputNum("枠座標(左上X)=",&KeyFrm.x1,0,WINUSER_MAX_X);
            InputNum("枠座標(左上Y)=",&KeyFrm.y1,0,WINUSER_MAX_Y);
            InputNum("枠座標(右下X)=",&KeyFrm.x2,0,WINUSER_MAX_X);
            InputNum("枠座標(右下Y)=",&KeyFrm.y2,0,WINUSER_MAX_Y);
        }
        else                                /*  無視するときは-1を設定  */
        {
            KeyFrm.x1 = -1;
            KeyFrm.y1 = -1;
            KeyFrm.x2 = -1;
            KeyFrm.y2 = -1;
        }

        ItmCnt = 0;                         /*  一致するｱｲﾃﾑ個数初期化  */
        FPos = 0;                           /*  ﾙｰﾄから検索します       */
        while(1)
        {
            FPos = ITM_GetGrpFPos(ItmPath,FPos,KeyEtyNum,KeyIcnNum,KeyTtlPtr, KeyNextFPos,&KeyFrm);
            if(FPos < 0)                    /*  一致するｱｲﾃﾑがないときは */
                break;                      /*  検索終了                */

            ItmCnt++;

            ITM_GetGrpData(ItmPath,FPos,&EtyNum,&IcnNum,TtlStr,&NextFPos,&Frm);
                                            /*  詳細情報取得            */
            printf("%d *********************************\n",ItmCnt);
            printf("ファイルポジション=%05d\n",FPos);  /*  各項目内容表示  */
            printf("登録数=%d\n",EtyNum);
            printf("アイコン番号=%d\n",IcnNum);
            printf("タイトル名=%s\n",TtlStr);
            printf("次ファイルポジション=%d\n",NextFPos);
            printf("枠座標(左上X)=%d\n",Frm.x1);
            printf("枠座標(左上Y)=%d\n",Frm.y1);
            printf("枠座標(右下X)=%d\n",Frm.x2);
            printf("枠座標(右下Y)=%d\n",Frm.y2);

            FPos = ITM_GetPhysclNextFPos(ItmPath,FPos);
             /* 次のｱｲﾃﾑから再検索します  */
        }
        printf("************************************\n",ItmCnt);

        if(ItmCnt)
            printf("以上の%d個のアイテムが一致しました\n",ItmCnt);
        else
            printf("一致するアイテムはありません\n");
    }

    return(0);
}

/*■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■                            サービスルーチン                            ■
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■*/
/*
                              数値取得ルーチン
                                                                                */
void    InputNum(DspStr,GetNum,MinNum,MaxNum) 
char    *DspStr;
int     *GetNum;
int     MinNum;
int     MaxNum;
{
    int     i = 0;
    int     j;
    int     RtryFlg;
    int     Num;
    char    KeyChr;
    char    StrBuf[266];

    do
    {
        printf("%s",DspStr);                     /*  入力文字列表示     */

        while((KeyChr = getchar()) != '\n')
        {
            if((KeyChr == 0x08) && (i > 0))      /*  後退時             */
                i--;
            else                                 /*  入力した文字は     */
            {                                    /*  ﾊﾞｯﾌｧに格納します  */
                StrBuf[i] = KeyChr;
                i++;
            }
        }
        StrBuf[i] = '\0';                        /*  末尾をNULLにします */

        for(j=0;j<i;j++)
        {
            if(((StrBuf[j] < '0') || ('9' < StrBuf[j]))
            && ((j == 0) && (StrBuf[j] != '-')))
            {
                printf("〔数値を入力してください〕\n");
                RtryFlg = 1;                    /*  もう一度入力を行います */
                i = 0;
                break;
            }
        }

        Num = ConvNum(StrBuf);                   /*  文字列→数値に変換 */

        if(Num > MaxNum)
        {
            printf("〔入力した数値は大きすぎます(最大=%d)〕\n",MaxNum);
            RtryFlg = 1;                      /*  もう一度入力を行います  */
            i = 0;
        }
        else if(Num < MinNum)
        {
            printf("〔入力した数値は小さすぎます(最小=%d)〕\n",MinNum);
            RtryFlg = 1;                        /*  もう一度入力を行います */
            i = 0;
        }
        else                                    /*  入力が正しかったら     */
            RtryFlg = 0;                        /*  ﾙｰﾌﾟをぬけます        */ 
    } while(RtryFlg);

    *GetNum = Num;

    return;
}

int ConvNum(StrPtr)                    /*  数値文字列を数値に変換します */
char    *StrPtr;
{
    int     i;
    int     Num = 0;
    int     Byte;
    int     NgtvFlg = 0;
    char    TmpBuf[256];

    if(*StrPtr == '-')                            /*  数値が負数のとき  */
    {
        NgtvFlg = 1;
        strcpy(TmpBuf,StrPtr);                    /*  '-'を除いた数値の   */
        strcpy(StrPtr,&TmpBuf[1]);                /*  みにします          */
    }

    Byte = strlen(StrPtr) - 1;
    for(i=Byte;i>=0;i--)
    {
        if((*StrPtr < '0') || ('9' < *StrPtr))
            return(-1);

        Num += (*StrPtr - '0') * BEKI(10,i);
        StrPtr++;
    }

    if(NgtvFlg)                                   /*  負数の場合         */
        Num = 0 - Num;
    return(Num);
}
int BEKI(x,n)                                     /*  べき乗関数         */
int x;

int n;
{
    int i;
    int p = 1;
    for(i=1;i<=n;i++)
        p = p * x;
    return(p);
}

/*
                            文字列取得ルーチン
                                                                                */
void    InputStr(DspStr,GetStr,MinLen,MaxLen) 
char    *DspStr;
char    *GetStr;
int     MinLen;
int     MaxLen;
{
    int     i = 0;
    int     RtryFlg;
    char    KeyChr;
    char    StrBuf[256];

    do
    {
        printf("%s",DspStr);                      /*  入力文字列表示      */

        while((KeyChr = getchar()) != '\n')
        {
            if((KeyChr == 0x08) && (i > 0))       /*  後退時              */
                i--;
            else                                  /*  入力した文字はﾊﾞｯﾌｧ */
            {                                     /*  に格納します        */
                StrBuf[i] = KeyChr;
                i++;
            }
        }
        if(MaxLen < i)
        {
            printf("〔入力した文字列は長すぎます(最大文字数=%d)〕\n",MaxLen);
            RtryFlg = 1;                       /*  もう一度入力を行います */
            i = 0;
        }
        else if(MinLen > i)
        {
            printf("〔入力した文字列は短すぎます(最小文字数=%d)〕\n",MinLen);
            RtryFlg = 1;                       /*  もう一度入力を行います */

            i = 0;
        }
        else
        {
            StrBuf[i] = '\0';     /*  末尾をNULLにして文字列にします       */
            RtryFlg = 0;          /*  入力が正しかったのでループをぬけます */
        }

    } while(RtryFlg);
    strcpy(GetStr,StrBuf);

    return;
}

/*
                             文字取得ルーチン
                                                                                */
void    InputChr(DspStr,GetChr,MinChr,MaxChr)
char    *DspStr;
char    *GetChr;
char    MinChr;
char    MaxChr;
{
    int     i = 0;
    int     RtryFlg;
    char    KeyChr;
    char    StrBuf[256];

    do
    {
        printf("%s",DspStr);                     /*  入力文字列表示      */

        while((KeyChr = getchar()) != '\n')
        {
            if((KeyChr == 0x08) && (i > 0))      /*  後退時              */
                i--;
            else                                 /*  入力した文字はﾊﾞｯﾌｧ */
            {                                    /*  に格納します        */
                StrBuf[i] = KeyChr;
                i++;
            }
        }

        if(i > 1)
        {
            printf("〔一文字を入力してください〕\n");
            RtryFlg = 1;                        /* もう一度入力を行います */
            i = 0;
        }
        else if((StrBuf[0] < MinChr) || (MaxChr < StrBuf[0]))
        {
            printf("〔入力した文字は処理できません〕\n");
            RtryFlg = 1;                       /*  もう一度入力を行います */
            i = 0;
        }
        else
            RtryFlg = 0;           /*  入力が正しかったらループをぬけます  */
    } while(RtryFlg);

    *GetChr = StrBuf[0];
    return;
}

*****************************************************************************
第15章  フルカラーライブラリ
*****************************************************************************

1 フルカラーライブラリについて

1.1 概要

  フルカラーライブラリは、別売のフルカラーカード、フルカラービデオキャプチャ
カード(ビデオキャプチャ時に必要)を使用して、フルカラーの画面を表示するライブ
ラリです。また、画面モードとしては1677万色モードの他、256色と32768色モードを
サポートしています。
  また、FM TOWNSIIモデルMA/MX/HA/HBの1677万色モード(以下本体フルカラー)もサポ
ートしていますが、他のライブラリとの不整合が起きますのでEGBライブラリをご使用
ください。

2 動作環境

2.1 構成

  フルカラーライブラリは、NSDDおよびライブラリから構成されています。
  ハードウェア構成を含めてその構成を以下に示します。

                                                        フルカラーカード
                                                        または本体フルカラー
┌────────┐    ┌─────────┐          ┌────────┐
│アプリケーション│    │フルカラードライバ│マッピング│┌──────┐│
│      ┌────┤    │        (ＮＳＤＤ)│←────→│ＶＲＡＭ    ││
│      │フルカラ│    │                  │メモリ    │└──────┘│
│      │ーライブ├─→│                  │アクセス  │                │
│      │ラリ    │関数│                  │          │┌──────┐│
│      │        │呼び│                  │←────→│制御レジスタ││
│      │        │出し│                  │ I/O      │└──────┘│
└───┴────┘    └─────────┘  アクセス└────────┘
              ↑セレクタの取得
┌──────┴───────────────┐
│ＤＯＳエクステンダ                          │
└──────────────────────┘

  以下に動作手順を示します。

  1.ライブラリはDOSエクステンダからドライバのセレクタを取得します。
  2.取得したセレクタを使用してライブラリ内からNSDDの機能を呼び出します。
  3.NSDD内の機能は初期化時にVRAMをマッピングして使用可能状態とします。
    その後各機能からVRAMおよび制御レジスタをアクセスします。

2.2 注意事項

  フルカラーライブラリを使用するためには、あらかじめドライバを常駐させる必要
があります。以下にその方法を示します。なお詳細はTownsシステムソフトウェア 
V2.1に添付されているマニュアルを参照してください。

 (1)システム設定で設定する場合
    システム設定で｢フルカラーカード｣を使用する設定を行います。

 (2)アイテムで設定する場合
    システムのグループアイテム｢設定｣の中の｢フルカラーON｣をダブルクリックしま
    す。

3 プログラミング

  フルカラーライブラリを使用してプログラムを作成するうえで必要な情報を以下に
示します。なおフルカラーライブラリは、TOWNS用グラフィックBIOS(EGB)とほぼ同じ
仕様になっています。したがって、EGBを参照のうえプログラミングすることを推奨し
ます。

3.1 画面モードと仮想画面

  フルカラーライブラリは4種類の画面モードをサポートしています。ただし画面モー
ド1と2は同時に動作し合成されるため、設定は一方を行うと自動的に他方も行われる
ようになっています。その際、一方を非表示にすることができるので、片側のページ
のみ使用することもできます。以下にその画面モードを示します。なお画面モード1、
3、4はページ0に、画面モード2はページ1に固定されています。

┌─┬─────┬────┬─────┬──────┬───┬──────┐
│  │          │        │          │            │      │ピクセル当た│
│No│  仮想画面│表示画面│同時表示色│  パレット  │画面  │            │
│  │          │        │          │            │  合成│りのバイト数│
├─┼─────┼────┼─────┼──────┼───┼──────┤
│1 │1024×512 │640×480│   256色  │256/1677万色│1←→2│      1     │
├─┤          │        ├─────┼──────┤      ├──────┤
│2 │          │        │  32768色 │    無し    │      │      2     │
├─┤          │        ├─────┼──────┼───┼──────┤
│3 │          │        │ 1677万色 │補正用(注)  │1画面 │      4(注) │
├─┼─────┤        ├─────┼──────┤      ├──────┤
│4 │ 640×480 │        │ 1677万色 │    無し    │      │    3/4(注) │
└─┴─────┴────┴─────┴──────┴───┴──────┘

- 注意 -
 ･画面モード3のパレットはそれぞれ8ビット×256×3個あり、階調の補正として使用
  します。
 ･画面モード3のピクセル当たりのバイト数は実際に使用するのは3バイトで、上位
  8ビットはメモリがなく、表示とは無関係です。
 ･画面モード4のピクセル当たりのバイト数は通常4バイトですが、3バイトにも設定
  可能です。

3.1.1 フルカラーカードの構造

  VRAMは全画面モードとも1024×512ピクセルで定義されています。しかし実際にメモ
リが実装されているのは768×512ピクセルの部分で、以下のようになります。なお、
仮想画面枠は1024×512で定義しています。画面モード1、2、3が設定できます。

              │←──────────1024ピクセル─────────│
              │←─────── 768ピクセル─────→│
    ─────┌────────────────────┬─────┐
        ↑    │                                        │          │
        │    │                                        │          │
        │    │                                        │          │
        │    │    VRAM実装                            │ VRAM     │
        │    │                                        │ 未実装   │
    512       │                                        │          │
    ピクセル  │                                        │          │
        │    │                                        │          │
        │    │                                        │          │
        │    │                                        │          │
        │    │                                        │          │
        ↓    │                                        │          │
    ─────└────────────────────┴─────┘

3.1.2 本体フルカラーの構造

  VRAMは640×480ピクセルで定義されています。メモリ実装および仮想画面枠とも640
×480ピクセルです。画面モード4のみ設定できます。

3.2 画面の重ね合わせ

  フルカラーカードは自表示画面とTOWNS画面を合成する機能を持ちます。
  したがって画面数としてはフルカラーカードで2画面、TOWNS画面で2画面、最大4画
面合成することができます。それぞれは独立して動作し、互いに影響することはあり
ません。ただし、TOWNS画面とフルカラー画面はおのおの一つのグループになっている
ため、最大4画面が任意の順番になるわけではありません。以下にその重ね合わせを示
します。ここではTOWNS画面を一枚としていますが、その中で2画面構成は可能です。
  なお、重ね合わせ時のTOWNS画面は、水平周波数31KHzのモードに限られます。本体
フルカラーはFM TOWNS本体のVRAMを使用しているため、重ね合わせはできません。

 (1)フルカラーカードで2画面合成している場合

  ■TOWNS画面が前面の場合

   ･ページ0(256色)が前の場合

        ┌─────────┐
      ┌┴────────┐│
    ┌┴────────┐││←ページ1(32768色/画面モード2)
    │                  │││
    │                  ││←─ページ0(256色/画面モード1)
    │                  │││
    │                  │←┼─ＴＯＷＮＳ画面
    │                  │├┘
    │                  ├┘
    └─────────┘

   ･ページ1(32768色)が前の場合

        ┌─────────┐
      ┌┴────────┐│
    ┌┴────────┐││←ページ0(256色/画面モード1)
    │                  │││
    │                  ││←─ページ1(32768色/画面モード2)
    │                  │││
    │                  │←┼─ＴＯＷＮＳ画面
    │                  │├┘
    │                  ├┘
    └─────────┘

  ■フルカラー画面が前面の場合

   ･ページ0(256色)が前の場合

        ┌─────────┐
      ┌┴────────┐│
    ┌┴────────┐││←ＴＯＷＮＳ画面
    │                  │││
    │                  ││←─ページ1(32768色/画面モード2)
    │                  │││
    │                  │←┼─ページ0(256色/画面モード1)
    │                  │├┘
    │                  ├┘
    └─────────┘

   ･ページ1(32768色)が前の場合

        ┌─────────┐
      ┌┴────────┐│
    ┌┴────────┐││←ＴＯＷＮＳ画面
    │                  │││
    │                  ││←─ページ0(256色/画面モード1)
    │                  │││
    │                  │←┼─ページ1(32768色/画面モード2)
    │                  │├┘
    │                  ├┘
    └─────────┘

 (2)フルカラーカードが1画面の場合

  ■TOWNS画面が前面の場合

      ┌─────────┐
    ┌┴────────┐│
    │                  ││
    │                  ││←─ページ0(1677万色/画面モード3)
    │                  ││
    │                  │←──ＴＯＷＮＳ画面
    │                  ││
    │                  ├┘
    └─────────┘

  ■フルカラー画面が前面の場合

      ┌─────────┐
    ┌┴────────┐│
    │                  ││
    │                  ││←─ＴＯＷＮＳ画面
    │                  ││
    │                  │←──ページ0(1677万色/画面モード3)
    │                  ││
    │                  ├┘
    └─────────┘

3.3 表示制御

  フルカラーカードでは、仮想画面から実際の表示画面に表示する領域、開始位置、
拡大の制御ができます。以下にそのイメージを示します。

  図EXL121R-031

  設定する項目は、表示画面上での表示開始位置と表示領域の大きさ、仮想画面上の
表示開始位置、および拡大率です。各項目で範囲外の設定がされない範囲で動作し、
範囲外の設定があった場合は範囲内に入るようにまるめられます。また拡大について
は、仮想画面上の表示開始位置を基準にして拡大され、設定された表示画面上の表示
領域に表示されます。つまり、n×m倍に拡大された場合は、1倍のときに比べて表示さ
れる仮想画面上の領域は1/n×1/mとなります。

3.4 ピクセルビット構成

  各画面モードのピクセルビット構成を示します。

 (1)256色(画面モード1)

     7             0                        7                           0
    ┌┬┬┬┬┬┬┬┐                    ┌─┬─┬─┬─┬─┬─┬─┬─┐
    │ﾊﾟﾚｯﾄｲﾝﾃﾞｯｸｽ  │      パレット初期値│    Ｇ    │    Ｒ    │  Ｂ  │
    └┴┴┴┴┴┴┴┘                    └─┴─┴─┴─┴─┴─┴─┴─┘

    画面モード1のデータは8ビットで構成されます。パレットインデックス0のデータ
    が透過色です。パレットの初期値はEGBと同じ設定で上記のとおりです。
    ビット7-5で緑の揮度、ビット4-2で赤の揮度、ビット1-0で青の揮度を反映するよ
    うに設定しています。

 (2)32768色(画面モード2)

    15 14      10 9      5 4       0
    ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐
    ││   Ｇ   │   Ｒ   │   Ｂ   │
    └┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┘

    画面モード2のデータは16ビットで構成されます。ビット15は透過色ビットで1に
    設定すると透過色になり、残りの15ビットでRGB各5ビットずつの揮度の設定を行
    います。RGBの各ビット位置はTOWNS標準画面と同様BRGの順番です。

 (3)1677万色(画面モード3)

     31           24 23           16 15            8 7             0
    ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐
    │    未使用    │      Ｂ      │      Ｇ      │      Ｒ      │
    └┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┘

    画面モード3のデータは32ビットで構成されます。ただし上位8ビットは表示には
    無関係です。RGBの各ビット位置は上記のとおりで、各8ビットずつ揮度の設定を
    行います。RGBそれぞれ0にすると透過色になります。なお透過色の場合、パレッ
    トは無効となります。パレットの初期値は各色成分がリニアに出るように設定し
    ています。(パレット番号nに対して各色成分がnの値を持つ)

 (4)1677万色(画面モード4)

   ･3バイト/ピクセル時

     23           16 15            8 7             0
    ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐
    │      Ｂ      │      Ｇ      │      Ｒ      │
    └┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┘

   ･4バイト/ピクセル時

     31           24 23           16 15            8 7             0
    ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐
    │    未使用    │      Ｂ      │      Ｇ      │      Ｒ      │
    └┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┘

    画面モード4のデータは24ビットまたは32ビットで構成されます。
    ただし32ビット構成の場合上位8ビットは表示には無関係です。
    RGBの各ビット位置は上記のとおりで、各8ビットずつ揮度の設定を行います。
    RGBそれぞれ0にすると透過色になります。

3.5 TOWNSグラフィックBIOS(EGB)との関連

  EGBとこのドライバは基本的には独立に使用することができます。しかし、EGBの初
期化時にTOWNS本体のCRTコントローラを初期化してしまうため、EGBの初期化を行った
後、このドライバの初期化関数を呼んでください。
  また、EGB_resolution系関数でもCRTコントローラを初期化するため、画面モードを
切り換えた場合にはFGS_setys関数を呼び出してください。
  本体フルカラーを使用する場合はこのFGS_setys関数を呼び出す必要はありませんが
、EGBと同じCRTコントローラを使用しますので同時に使用することはできません。
また本体フルカラーの画面からEGBを使用した画面に切り換える時は、必ずFGS_close
を呼んでフルカラーライブラリを終了してください。

  本体フルカラーとEGB画面の切替え手順

〔初期状態〕
  ･EGBを使用して画面操作している状態。

〔フルカラー使用開始時の手順〕
  ･マウスを使用している時はマウスを消す。
  ･初期化関数(FGS_init2)を呼ぶ。
  ･FGS_init2またはFGS_resolutionでフルカラー画面を設定する。
  ･FGS_ClearScreen関数で画面を消去する。
  ･フルカラー画面を操作する。

〔フルカラー使用終了時の手順〕
  ･終了関数(FGS_close)を呼ぶ。
  ･EGBの初期化を行う。

3.6 ビデオキャプチャ

  ビデオキャプチャは、入力されたビデオ信号をビデオバス画面として構成し、その
画面を仮想画面に60分の1秒単位で転送するものです。
  この機能は画面モード2(32768色)、3(1677万色)で使用できます。なおこの機能を使
用するためには別売りのフルカラービデオキャプチャカード(以下キャプチャカードと
呼びます)が必要です。転送時に設定する項目は、ビデオバス画面上の取り込み範囲、
仮想画面上の開始表示位置、拡大率です。拡大率は256分の1単位で設定できますが、
実際には拡大ではなく縮小のみサポートされます。
  以下にそのイメージを示します。

  図EXL121R-032

3.7 Towns Shell上のアプリケーションでの使用

　フルカラードライバの初期化処理はFGS_initを使用してください。FGS_init2関数は
使用しないでください。(本体フルカラーはEGBライブラリを使用してください)

　他のアプリケーションによってフルカラー画面が非表示状態になる場合があります
ので、他のアプリケーションから制御が自アプリケーションに移行してきた場合に、
フルカラー画面を表示するにはFGS_setys関数を呼ぶ必要があります。

　TownsShell環境下ではフルカラードライバを使用するアプリケーションが複数存在
する場合がありますので、プログラムで以下の事ことに注意する必要があります。

  ･FGS_init関数を必ず呼ぶ。
  ･FGS_init関数は、FGSオープンレベルが0から1に変化した時のみ初期化処理をおこ
   ないますので、FGS_init関数を呼んだ後には必ずFGS_resolution関数を呼ぶ。
   また、フルカラー画面を消去する場合には、FGS_ClearScreen関数を呼ぶ。
  ･終了時には必ずFGS_close関数を呼ぶ。

4 フルカラーライブラリ

4.1 関数一覧

 ･セッティングオペレーション
┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│FGS_init                  │初期化                                    │
├─────────────┼─────────────────────┤
│FGS_init2                 │初期化                                    │
├─────────────┼─────────────────────┤
│FGS_close                 │終了                                      │
├─────────────┼─────────────────────┤
│FGS_resolution            │仮想画面の設定                            │
├─────────────┼─────────────────────┤
│FGS_displayStart          │表示開始位置の設定                        │
├─────────────┼─────────────────────┤
│FGS_palette               │パレットレジスタの設定                    │
├─────────────┼─────────────────────┤
│FGS_writePage             │書き込みページの指定                      │
├─────────────┼─────────────────────┤
│FGS_displayPage           │表示ページの指定                          │
├─────────────┼─────────────────────┤
│FGS_viewport              │ビューポートの設定                        │
├─────────────┼─────────────────────┤
│FGS_setys                 │重ね合わせ信号の設定                      │
├─────────────┼─────────────────────┤
│FGS_setPack               │パック状態の設定                          │
└─────────────┴─────────────────────┘

 ･ディジタイズオペレーション
┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│FGS_digitize              │ディジタイズ開始･終了の設定               │
├─────────────┼─────────────────────┤
│FGS_digitizeMode          │ディジタイズ取り込みモードの設定          │
├─────────────┼─────────────────────┤
│FGS_digitizeArea          │ディジタイズ取り込み範囲の設定            │
├─────────────┼─────────────────────┤
│FGS_digitizeQuality       │ディジタイズ画質の調整                    │
├─────────────┼─────────────────────┤
│FGS_digitizeFlip          │ディジタイズ反転の設定                    │
├─────────────┼─────────────────────┤
│FGS_digitizeStart         │ディジタイズ転送開始位置の設定            │
├─────────────┼─────────────────────┤
│FGS_digitizeZoom          │ディジタイズ拡大率の設定                  │
└─────────────┴─────────────────────┘

 ･リーディングオペレーション
┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│FGS_getResolution         │仮想画面の読み取り                        │
├─────────────┼─────────────────────┤
│FGS_getDisplayStart       │表示開始位置の読み取り                    │
├─────────────┼─────────────────────┤
│FGS_getPalette            │パレットの読み取り                        │
├─────────────┼─────────────────────┤
│FGS_getWritePage          │書き込みページの読み取り                  │
├─────────────┼─────────────────────┤
│FGS_getDisplayPage        │表示ページの読み取り                      │
├─────────────┼─────────────────────┤
│FGS_openCheck             │動作状態の読み取り                        │
├─────────────┼─────────────────────┤
│FGS_openCheck2            │動作状態の読み取り                        │
├─────────────┼─────────────────────┤
│FGS_getInformation        │ハードウェア情報の取得                    │
├─────────────┼─────────────────────┤
│FGS_getResolutionPage     │仮想画面の読み取り                        │
├─────────────┼─────────────────────┤
│FGS_getActivePage         │使用可能画面の取得                        │
├─────────────┼─────────────────────┤
│FGS_getPack               │パック状態の読み取り                      │
└─────────────┴─────────────────────┘

 ･ブロックオペレーション
┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│FGS_clearScreen           │全画面の消去                              │
├─────────────┼─────────────────────┤
│FGS_getBlock              │ドットデータの読み込み1                   │
├─────────────┼─────────────────────┤
│FGS_putBlock              │ドットデータの書き込み1                   │
├─────────────┼─────────────────────┤
│FGS_partGetBlock          │ドットデータの読み込み2                   │
├─────────────┼─────────────────────┤
│FGS_partPutBlock          │ドットデータの書き込み2                   │
├─────────────┼─────────────────────┤
│FGS_copy                  │ドットデータの複写                        │
├─────────────┼─────────────────────┤
│FGS_fillRaster            │ドットデータの書き込み3                   │
├─────────────┼─────────────────────┤
│FGS_putRaster             │ドットデータの書き込み4                   │
└─────────────┴─────────────────────┘

4.2 各関数の解説

-----------------------------------------------------------------------------
.FGS_clearScreen 
全画面の消去
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_clearScreen(char *fgs_work);
char    *fgs_work;        /*  作業域のアドレス              */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

ret = FGS_clearScreen(fgs_work);

- 内容 -
書き込みページの仮想画面全体を色識別番号0で塗りつぶします。

図EXL121R-033

-----------------------------------------------------------------------------
.FGS_close 
終了
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_close(void);

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
int     ret;
ret = FGS_close();

- 内容 -
FGS_close関数を呼ぶとFGSオープンレベルが1デクリメントされ、FGSオープンレベル
が1から0に変化した時のみ終了処理をおこないます。
フルカラーライブラリの使用を終了する時には必ず呼んでください。

-----------------------------------------------------------------------------
.FGS_copy
ドットデータの複写
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_copy(char *fgs_work, char *para);
char    *fgs_work;        /*  作業域のアドレス              */
char    *para;            /*  パラメータのアドレス          */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
char    para[64]; 
int     ret;

ret = FGS_copy(fgs_work, para);

- 内容 -
矩形内のドットデータを他の位置に複写します。複写できるのは同一ページ内のみで
、ビューポートで指定された領域は、複写先のみ有効となります。

    ┌─┬───────────┐
   0│SW│第1点Ｘ座標(複写元)   │
    ├─┼───────────┤
   2│SW│第1点Ｙ座標(複写元)   │
    ├─┼───────────┤
   4│SW│第2点Ｘ座標(複写元)   │
    ├─┼───────────┤
   6│SW│第2点Ｙ座標(複写元)   │
    ├─┼───────────┤
   8│SW│第1点Ｘ座標(複写先)   │
    ├─┼───────────┤
   A│SW│第1点Ｙ座標(複写先)   │
    └─┴───────────┘
      ▲パラメータの形式

-----------------------------------------------------------------------------
.FGS_digitize
ディジタイズ開始･終了の設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_digitize(char *fgs_work, int mode);
char    *fgs_work;      /*  作業域のアドレス                  */
int     mode;           /*  開始終了情報  (0:強制終了)
                                          (1:開始) 
                                          (2:強制終了)        */

- 戻り値 -
0 :正常終了
1 :キャプチャカードがない
2 :パラメータエラー
3 :転送中に開始したか、停止中に終了した

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

ret = FGS_digitize(fgs_work, 0);

- 内容 -
ディジタイズの開始、終了の指定をします。ディジタイズを開始するとビデオ入力か
らビデオバス画面の情報が仮想画面(VRAM)に転送されます。終了時には2つの方法があ
ります。モード=0を指定するとその時点で強制的に終了します。
モード=2では現在の転送領域の転送が終わってからディジタイズを終了します。

-----------------------------------------------------------------------------
.FGS_digitizeMode
ディジタイズ取り込みモードの設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_digitizeMode(char *fgs_work, int mode);
char    *fgs_work;      /*  作業域のアドレス                       */
int     mode;           /*  取り込みモード(0:奇数フィールド      )
                                          (1:両フィールド        )
                                          (2:偶数フィールド      )
                                          (3:フレーム            ) */

- 戻り値 -
0 :正常終了
1 :キャプチャカードがない
2 :パラメータエラー

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

ret = FGS_digitize(fgs_work, 0);

- 内容 -
ビデオバス画面から、仮想画面(VRAM)に転送する際のモードを設定します。
各モードの意味は以下のとおりです。

  奇数フィールド:奇数番目の走査線のみを取り込んで表示します。
  両フィールド  :奇数、偶数フィールドを1/30ごとに切り換えて同一ラインに
                 表示します。
  偶数フィールド:偶数番目の走査線のみを取り込んで表示します。
  フレーム      :奇数、偶数フィールドを別のラインに取り込んで表示します。

なお、フィールドモードは取り込む走査線の数が通常の半分になりますので、縦方向
の表示サイズが半分になります。その時に拡大等の設定(FGS_digitizeZoom関数)で横
方向の設定値を2倍にならないようにすると縦方向は通常の大きさになります。

-----------------------------------------------------------------------------
.FGS_digitizeStart 
ディジタイズ転送開始位置の設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_digitizeStart(char * fgs_work, int xpos, int ypos);
char    *fgs_work;      /*  作業域のアドレス                        */
int     xpos;           /*  仮想画面上の転送開始位置のｘ座標        */
int     ypos;           /*  仮想画面上の転送開始位置のｙ座標        */

- 戻り値 -
0 :正常終了
1 :キャプチャカードがない
2 :パラメータエラー

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

ret = FGS_digitizeStart(fgs_work, 200, 300);

- 内容 -
ビデオバス画面から転送されるときの仮想画面上の転送開始位置の左上点を設定しま
す。

-----------------------------------------------------------------------------
.FGS_digitizeZoom
ディジタイズ拡大率の設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_digitizeZoom(char *fgs_work, int xpara, int ypara);
char    *fgs_work;      /*  作業域のアドレス                  */
int     xpara;          /*  横方向の設定値(1〜256)            */
int     ypara;          /*  縦方向の設定値(1〜256)            */

- 戻り値 -
0 :正常終了
1 :キャプチャカードがない
2 :パラメータエラー

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

ret = FGS_digitizeZoom(fgs_work, 128, 128);

- 内容 -
ビデオバス画面から仮想画面(VRAM)に転送する際の縮小量を設定します。
実際の縮小量は、｢設定値/256｣となります。したがって設定値として256を設定した
場合は、元の大きさになります。また128が設定された場合は、半分に縮小されます。

-----------------------------------------------------------------------------
.FGS_digitizeArea
ディジタイズ取り込み範囲の設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_digitizeArea(char *fgs_work, char *para);
char    *fgs_work;      /*  作業域のアドレス                        */
char    para[8];        /*  取り込み範囲を示すパラメータ            */

- 戻り値 -
0 :正常終了
1 :キャプチャカードがない
2 :パラメータエラー

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536],para[8]; 
int     ret;

WORD(para+0) = 0; 
WORD(para+2) = 0; 
WORD(para+4) = 320; 
WORD(para+6) = 120; 

ret = FGS_digitizeArea( fgs_work, para ); 

- 内容 -
ビデオバス画面の取り込み範囲を指定します。取り込みの範囲を以下に示します。
    横方向    0〜639
    縦方向    0〜239

    ┌─┬───────────┐
   0│SW│第1点Ｘ座標           │
    ├─┼───────────┤
   2│SW│第1点Ｙ座標           │
    ├─┼───────────┤
   4│SW│第2点Ｘ座標           │
    ├─┼───────────┤
   6│SW│第2点Ｙ座標           │
    └─┴───────────┘
      ▲パラメータの形式

-----------------------------------------------------------------------------
.FGS_digitizeQuality 
ディジタイズ画質の調整
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_digitizeQuality(char *fgs_work, int mode, int val,
                                                      int writemode); 
char    *fgs_work;    /*  作業域のアドレス                          */
int     mode;         /*  設定する画質    0:  シャープネス
                                          1:  コントラスト
                                          2:  明るさ
                                          3:  濃さ
                                          4:  色相                  */
int     val;          /*  設定値          0〜255                    */
int     writemode;    /*  書き込みモード                            */
                      /*    ビット0  0:設定値をROMに書き込まない    */
                      /*             1:設定値をROMに書き込む        */
                      /*    ビット1  0:指定した値を設定する         */
                      /*             1:ROMの値を設定する            */

- 戻り値 -
0 :正常終了
1 :キャプチャカードがない
2 :パラメータエラー
3 :ハードエラー
4 :ROMに値が設定されていない

- 例 -
#include <fgs.h>
          …
char    fgs_work[1536]; 
int     ret;
int     val=128;

ret = FGS_digitizeQuality(fgs_work, 0, &val, 0);

- 内容 -
取り込み時の画質を設定します。キャプチャカード内に画質設定値記憶用のROMを持っ
ています。一度調整した値をROMに書き込んで、その後はその値をROMから読んで初期
化時に設定するという運用を推奨します。またROMに書き込み回数制限(10万回)があり
ますので、個々の調整でROMに書き込まないでください。なお初期値は128です。
書き込みモードのビット0が1の場合はROMに書き込んでからハードウェアに設定します
ので、ビット1は無効になります。
また、書き込みモードのビット1が1の場合にすると、設定値はROMの値になります。

-----------------------------------------------------------------------------
.FGS_digitizeFlip
ディジタイズ反転の設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_digitizeFlip(char *fgs_work, int mode);
char    *fgs_work;      /*  作業域のアドレス                        */
int     mode;           /*  反転状態                                */
                        /*  ビット0  0:横方向の反転をしない         */
                        /*           1:横方向の反転をする           */
                        /*  ビット1  0:縦方向の反転をしない         */
                        /*           1:縦方向の反転をする           */

- 戻り値 -
0 :正常終了
1 :キャプチャカードがない
2 :パラメータエラー

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

ret = FGS_digitizeFlip( fgs_work, 3 );

- 内容 -
ディジタイズ時の反転状態を設定します。

-----------------------------------------------------------------------------
.FGS_displayPage 
表示ページの指定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_displayPage(char *fgs_work, int pri, int display);
char    *fgs_work;      /*  作業域のアドレス                         */
int     pri;            /*  プライオリティ
                              ビット0  0:ページ0を前
                                       1:ページ1を前
                              ビット1  0:ＴＯＷＮＳ画面を前
                                       1:フルカラー画面を前          */
int     display;        /*  表示ページ
                            0:設定不可
                            1:ページ0表示
                            2:ページ1表示
                            3:ページ0、1表示
                            4:TOWNS画面表示
                            5:TOWNS画面、ページ0表示
                            6:TOWNS画面、ページ1表示
                            7:TOWNS画面、ページ0、1表示              */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

ret = FGS_displayPage(fgs_work, 0, 7);

- 内容 -
ハードウェアで表示可能なページを指定します。フルカラー画面のみの表示を指定し
た場合はプライオリティのビット1は1とみなします。
なお、表示ページに0の指定はできません。

                  31  30              3  2  1  0
                ┌─┬─┬──〜──┬─┬─┬─┬─┐
  表示ページ    │ 0│ 0│          │ 0│  │  │  │
                └─┴─┴──〜──┴─┴┬┴┬┴┬┘
                                          │  │  │
                                          │  │  ページ0
                                          │  ページ1
                                          ＴＯＷＮＳ画面
  
                  31  30               3   2   1   0
                ┌─┬─┬──〜──┬─┬─┬─┬─┐
  プライオリティ│ 0│ 0│          │ 0│ 0│  │  │
                └─┴─┴──〜──┴─┴─┴┬┴┬┘
                                              │  │
                                              │  前面のページ
                                              0:ＴＯＷＮＳ画面が前
                                              1:フルカラー画面が前

  ここでページ0、1、TOWNS画面とは以下のとおりです。
    ページ0   :256 色ページ(2画面合成の場合)
               1677万色ページ(1画面の場合)
    ページ1   :32768色ページ(2画面合成の場合)
    TOWNS画面 :標準構成のハードウェアで表示されるページ

  画面モード4の時は表示ページのビット1、2とプライオリティは無効です。

-----------------------------------------------------------------------------
.FGS_displayStart
表示開始位置の設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_displayStart(char *fgs_work, int mode, int xstart, 
                                                   int ystart); 
char    *fgs_work;        /*  作業域のアドレス              */
int     mode;             /*  モード                        */
int     xstart;           /*  横方向パラメータ              */
int     ystart;           /*  縦方向パラメータ              */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

/*  画面モードNo1で仮想画面の(0,0)-(319,239)の部分を縦横2倍に
    拡大して全画面に表示します                                  */
ret = FGS_displayStart(fgs_work, 0, 0, 0);
ret = FGS_displayStart(fgs_work, 1, 0, 0);
ret = FGS_displayStart(fgs_work, 2, 2, 2);
ret = FGS_displayStart(fgs_work, 3, 640, 480);

- 内容 -
以下の項目を設定します。
  モード    0:表示画面上の表示開始位置の設定
            1:仮想画面上の表示開始位置の設定
            2:画面の拡大率の設定
            3:表示領域の大きさ

 ●表示画面上の表示開始位置の設定

   図EXL121R-034

  ･画面枠をはみ出して表示開始位置を設定することはできません。
  ･表示領域が画面枠をはみ出した場合、はみ出した部分は無視され、
   画面枠端に設定します。

 ●仮想画面上の表示開始位置の設定

   図EXL121R-035

  ･仮想画面をはみ出して表示開始位置を設定することはできません。
  ･仮想画面上の表示画面領域が仮想画面を水平方向にはみ出した場合、
   はみ出した部分は無視され、仮想画面端に設定します。

 ●画面の拡大

   図EXL121R-036

  ･最大倍率は垂直、水平方向ともに16倍です。
  ･n×m倍に拡大すると表示画面上の表示領域に対して仮想画面上の表示領域は
   1/n×1/m倍になります。

 ●表示領域の大きさ

   図EXL121R-037

  ･表示画面上の表示領域が画面枠をはみ出した場合、はみ出した部分は無視され画面
   枠端に設定します。
  ･仮想画面上の表示領域が仮想画面をはみ出した場合、はみ出した部分は無視され仮
   想画面端に設定します。したがって表示画面上の表示領域が小さくなります。
  ･拡大による影響は仮想画面上の表示領域に影響します。

-----------------------------------------------------------------------------
.FGS_fillRaster
ドットデータの書き込み3
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_fillRaster(char *fgs  work, int x, int y, int size, int data);
char    *fgs_work;        /*  作業域のアドレス              */
int     x,y;              /*  描画開始位置(ｘ, ｙ座標)      */
int     size;             /*  データサイズ(ピクセル数)      */
int     data;             /*  書き込むデータ                */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

ret = FGS_fillRaster(fgs_work, 100, 100, 20, 0x00ff00ff);

- 内容 -
指定された座標から指定されたピクセル分指定されたデータをx軸正方向に書き込みま
す。書き込むデータは256色モードでは下位8ビット、32768色モードでは下位16ビット
のみ有効になります。なおデータサイズの最大値は1024です。右端よりはみ出す指定
を行った場合、その行の右端まで書き込みを行います。

-----------------------------------------------------------------------------
.FGS_getActivePage 
使用可能画面の取得
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_getActivePage(void);

- 戻り値 -
使用可能画面を以下の形式で返します。

                    31          2  1  0
                  ┌──〜〜─┬─┬─┬─┐
                  │          │  │  │  │
                  └──〜〜─┴┬┴┬┴┬┘
    0:ＴＯＷＮＳ画面表示不可  ─┘  │  │
    1:ＴＯＷＮＳ画面表示可能        │  │
     0:ページ1表示不可───────┘  │
     1:ページ1表示可能                  │
     0:ページ0表示不可─────────┘
     1:ページ0表示可能

- 例 -
#include <fgs.h>
int     ret;

ret = FGS_getActivePage();

- 内容 -
現在画面モードにおける使用可能な画面･ページを取得します。

-----------------------------------------------------------------------------
.FGS_getBlock
ドットデータの読み込み1
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_getBlock(char *fgs_work, int mode, char *para);
char    *fgs_work;        /*  作業域のアドレス              */
int     mode;             /*  ピクセルあたりのビット数
                                  0:24ビット/ピクセル
                                  1:32ビット/ピクセル       */
char    *para;            /*  パラメータのアドレス          */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
char    para[64]; 
int     mode; 
int     ret;

mode = 1; 
ret = FGS_getBlock(fgs_work, mode, para);

- 内容 -
指定した矩形域内のドットデータを読み込みデータ格納領域に転送します。
指定された矩形が仮想画面をはみ出した場合は、そのはみ出した部分に0が読み込まれ
ます。なお、1677万色ページでは、その読み込んだデータを1ピクセルあたり24ビット
か32ビットにする指定を行う必要があります。

    ┌─┬───────────┐
   0│Ｄ│データ格納領域アドレス│
    ├─┼───────────┤
   4│Ｗ│データ格納領域セレクタ│
    ├─┼───────────┤
   6│SW│第1点Ｘ座標           │
    ├─┼───────────┤
   8│SW│第1点Ｙ座標           │
    ├─┼───────────┤
   A│SW│第2点Ｘ座標           │
    ├─┼───────────┤
   C│SW│第2点Ｙ座標           │
    └─┴───────────┘
      ▲パラメータの形式

    ┌─┬───────────┐
    │BA│ 8/16/24/32 bit pixel │
    〜  〜      データ列        〜
    └─┴───────────┘
      ▲データ格納領域のデータ格納形式

データ領域の大きさ(必要なバイト数)は以下の式に基づいて求めます。
  ･256色モード時               (横の大きさ)×(縦の大きさ)
  ･32768色モード時             (横の大きさ)×2×(縦の大きさ)
  ･1677万色モード時  (mode=0)  (横の大きさ)×3×(縦の大きさ)
  ･1677万色モード時  (mode=1)  (横の大きさ)×4×(縦の大きさ)

-----------------------------------------------------------------------------
.FGS_getDisplayPage
表示ページの読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_getDisplayPage(int *Priority, int *Display);
int     *Priority;     /*   優先度の高いページ番号       */ 
int     *Display ;     /*   表示ページ                   */ 

- 戻り値 -
表示ページと優先順位を以下の形式で返します。

                31          10  9   8           1   0 
              ┌──〜〜─┬─┬─┬─┬──┬─┬─┐
              │          │  │  │  │……│  │  │
              └──〜〜─┴┬┴┬┴┬┴──┴┬┴┬┘
  0:ＴＯＷＮＳ画面非表示  ─┘  │  │        │  └─優先度の高いページ番号
  1:ＴＯＷＮＳ画面表示          │  │        └───0:ＴＯＷＮＳ画面が前
   0:ページ1非表示───────┘  │                1:フルカラー画面が前
   1:ページ1表示                    │
   0:ページ0非表示─────────┘
   1:ページ0表示

- 例 -
#include <fgs.h>
        …
int     priority; 
int     display;
int     ret;
ret = FGS_getDisplayPage(&priority, &display);

- 内容 -
現在の表示ページと優先順位を読み取ります。
変数のポインタがNULLの場合、変数に対して値を返しません。

                  31  30              3  2  1  0
                ┌─┬─┬──〜──┬─┬─┬─┬─┐
  表示ページ    │ 0│ 0│          │ 0│  │  │  │
                └─┴─┴──〜──┴─┴┬┴┬┴┬┘
                                          │  │  ページ0
                              ＴＯＷＮＳ画面  ページ1
  
                  31  30              3  2  1  0
                ┌─┬─┬──〜──┬─┬─┬─┬─┐
  プライオリティ│ 0│ 0│          │ 0│ 0│  │  │
                └─┴─┴──〜──┴─┴─┴┬┴┬┘
                                              │  前面のページ
                                              0:ＴＯＷＮＳ画面が前
                                              1:フルカラー画面が前

-----------------------------------------------------------------------------
.FGS_getDisplayStart 
表示開始位置の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_getDisplayStart(int page, int mode, int x, int y);
int     page;               /*  ページ番号                     */ 
int     mode;               /*  モード                         */ 
int     *x;                 /*  横方向パラメータ               */ 
int     *y;                 /*  縦方向パラメータ               */ 

- 戻り値 -
画面の表示開始位置を以下の形式で返します。

      31                  15                  0 
      ┌─────────┬─────────┐
      │                  │                  │
      └──────┬──┴───┬─────┘
  縦方向パラメータ─┘            │
  横方向パラメータ────────┘

- 例 -
#include <fgs.h>
        …
int     page; 
int     mode; 
int     ret;
int     x,y;
page = 0; 
mode = 1; 

ret = FGS_getDisplayStart(page, mode, &x, &y);

- 内容 -
画面の表示開始位置を読み取ります。パラメータの詳細はFGS_displayStart関数を
参照してください。変数のポインタがNULLの場合、変数に対して値を返しません。
また、モード3の値は設定値ではなく実際の表示領域の大きさが返ってきます。
これはクリップなどで設定値と実際の表示領域の大きさが一致しないためです。

-----------------------------------------------------------------------------
.FGS_getInformation
ハードウェア情報の取得
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_getInformation(char *para, int sel);
char    *para;              /*  情報取得用領域                 */ 
int     sel;                /*  情報取得領域のセレクタ値       */ 

- 戻り値 -
 0 :正常終了
-1 :デバイスドライバが常駐していない

- 例 -
#include <fgs.h>
        …
char    para[128];
int     ret;

ret = FGS_getInformation(para, getds());

- 内容 -
ハードウェア･NSDD情報を取得します。

      ┌──┬───────────────┐
     0│ DW │ＶＲＡＭのセレクタ            │
      ├──┼───────────────┤
     4│ DW │ページ0のオフセット           │
      ├──┼───────────────┤
     8│ DW │ページ1のオフセット           │
      ├──┼───────────────┤
     C│ Ｗ │ＶＲＡＭサイズ(水平方向)      │
      ├──┼───────────────┤
     E│ Ｗ │ＶＲＡＭサイズ(垂直方向)      │
      ├──┼───────────────┤
    10│ Ｗ │ＶＲＡＭ実装サイズ(水平方向)  │
      ├──┼───────────────┤
    12│ Ｗ │ＶＲＡＭ実装サイズ(垂直方向)  │
      ├──┼───────────────┤
    14│ Ｗ │ＶＲＡＭ表示サイズ(水平方向)  │
      ├──┼───────────────┤
    16│ Ｗ │ＶＲＡＭ表示サイズ(垂直方向)  │
      ├──┼───────────────┤
    18│ DW │機能情報                      │
      └──┴───────────────┘
  
            31                     3   2   1   0
          ┌──────────┬─┬─┬─┬─┐
  機能情報│      不定          │ 1│ 1│ 1│ 1│
          └──────────┴─┴─┴─┴─┘
                                  1:機能あり  0:機能なし

表示開始位置の設定で機能の有無を示します。ビット位置はモードに対応します。
たとえば、ビット0はモード0の機能があることを示します。

-----------------------------------------------------------------------------
.FGS_getPack 
パック状態の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_getPack(void);

- 戻り値 -
 0 :1ピクセルあたり3バイト
 1 :1ピクセルあたり4バイト
-1 :誤った画面モードでこの関数を使用した

- 例 -
#include <fgs.h>
int     ret;

ret = FGS_getPack();

- 内容 -
画面モード4のとき、現在の1ピクセルあたりのバイト数を取得します。

-----------------------------------------------------------------------------
.FGS_getPalette
パレットの読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_getPalette(char *pal);
char    *pal;                /* パレットの内容               */ 

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    pal[4+8*256]; 
int     ret;

ret = FGS_getPalette(pal);

- 内容 -
現在のパレット状態を読み取ります。

パレット状態のデータ形式

 ･256色モード
    ┌─┬──────────────┐
   0│Ｄ│256(パレット数)             │
    ├─┼──────────────┤┐
   4│Ｄ│色識別番号(通し番号)        ││
    ├─┼──────────────┤│
   8│Ｂ│青の階調  (0〜 255)         ││
    ├─┼──────────────┤│
   9│Ｂ│赤の階調  (0〜 255)         │├※
    ├─┼──────────────┤│
   A│Ｂ│緑の階調  (0〜 255)         ││
    ├─┼──────────────┤│
   B│Ｂ│  0                         ││
    ├─┼──────────────┤┘
    〜  〜      ※の繰り返し          〜
    └─┴──────────────┘

 ･1677万色モード(画面モード3のみ)
    ┌─┬──────────────┐
   0│Ｄ│256(パレット数)             │
    ├─┼──────────────┤┐
   4│Ｄ│色識別番号(通し番号)        ││
    ├─┼──────────────┤│
   8│Ｂ│赤の階調    (0〜 255)       ││
    ├─┼──────────────┤│
   9│Ｂ│緑の階調    (0〜 255)       │├※
    ├─┼──────────────┤│
   A│Ｂ│青の階調    (0〜 255)       ││
    ├─┼──────────────┤│
   B│Ｂ│  0                         ││
    ├─┼──────────────┤┘
    〜  〜      ※の繰り返し          〜
    └─┴──────────────┘

-----------------------------------------------------------------------------
.FGS_getResolution 
仮想画面の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int    FGS_getResolution(int *Page0, int *Page1);
int     *Page0;          /*   ページ0の画面モード */ 
int     *Page1;          /*   ページ1の画面モード */ 

- 戻り値 -
現在の画面モードを以下の形式で返します。

  31      15               7               0
  ┌─〜─┬───────┬───────┐
  │      │              │              │
  └─〜─┴───┬───┴───┬───┘
                  │              └────Page0 の画面モード
                  └────────────Page1 の画面モード

- 例 -
#include <fgs.h>
        …
int     ret;
int     page0, page1; 

ret =  FGS_getResolution(&page0, &page1);

- 内容 -
現在の画面モードを読み取ります。
変数のポインタがNULLの場合は変数に対して値を返しません。

-----------------------------------------------------------------------------
.FGS_getResolutionPage 
仮想画面の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_getResolutionPage(int Page, char *para);
int     Page;            /*   取得するページ       */ 
char   *para;            /*   取得バッファアドレス */ 

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
int     ret;
int     page; 
char    para[32]; 
ret = FGS_getResolutionPage(page, para);

- 内容 -
現在の画面情報を読み取ります。

 ･バッファ内のデータ形式
    ┌─┬──────────────────┐
   0│Ｄ│仮想画面の横方向解像度(ドット数)    │
    ├─┼──────────────────┤
   4│Ｄ│仮想画面の縦方向解像度(ドット数)    │
    ├─┼──────────────────┤
   8│Ｄ│表示画面の横方向解像度(ドット数)    │
    ├─┼──────────────────┤
   C│Ｄ│表示画面の縦方向解像度(ドット数)    │
    ├─┼──────────────────┤
  10│Ｄ│1ピクセル当たりのビット数           │
    ├─┼──────────────────┤
  14│Ｄ│1ラインのバイト数                   │
    ├─┼──────────────────┤
  18│Ｄ│ＶＲＡＭ先頭オフセット              │
    ├─┼──────────────────┤
  1C│Ｗ│ＶＲＡＭセレクタ                    │
    ├─┼──────────────────┤
  1E│Ｗ│  リザーブ                          │
    └─┴──────────────────┘

-----------------------------------------------------------------------------
.FGS_getWritePage
書き込みページの読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int      FGS_getWritePage(char *fgs_work, unsigned short fgs_seg);
char     *fgs_work            /*  FGS作業域アドレス         */ 
unsigned short fgs_seg;       /*  FGS作業域のセグメント     */ 

- 戻り値 -
書き込みページ

- 例 -
#include <fgs.h>
        …
char           fgs_work[1536];
int            page,hpage;
unsigned short fgsseg;
fgsseg = getds();             /*  セグメントを得ます         */ 

                  /*  ワークに設定した書き込みページを得ます */ 
page =  FGS_getWritePage(fgs_work, fgsseg);

- 内容 -
指定されたワーク中の書き込みページを読み取ります。書き込みページはハードウェ
アの状態にまったく依存せず、ワーク内の設定値のみ参照して動作します。

-----------------------------------------------------------------------------
.FGS_init
初期化
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_init(char *fgs_work, int size);
char    *fgs_work;        /*  作業域のアドレス               */ 
int     size;             /*  作業域の大きさ                 */ 

- 戻り値 -
 0 :正常終了
-1 :デバイスドライバが常駐していない
-2 :フルカラーカードが存在しない

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

ret = FGS_init(fgs_work, 1536);

- 内容 -
FGSオープンレベルが1インクリメントされ、FGSオープンレベルが0から1に変化した時
のみ次の初期化処理をおこないます。
作業域を以下の内容に初期化し、画面(全ページ)を色識別番号0で塗りつぶします。
画面モード3と同じ設定になります。作業域の大きさは、1536byte固定です。
    解像度                  :640×480×1600万色×1画面
    表示画面上の表示開始位置:(0、0)
    仮想画面上の表示開始位置:(0、0)
    画面拡大率              :1倍
    表示領域の大きさ        :640×480
    書き込みページ          :ページ0
    表示ページ              :ページ0
    パレットレジスタ        :パレット番号nに対してRGB=nnn 

-----------------------------------------------------------------------------
.FGS_init2 
初期化
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_init2(char *fgs_work, int size);
char    *fgs_work;        /*  作業域のアドレス               */ 
int     size;             /*  作業域の大きさ                 */ 

- 戻り値 -
 0 :正常終了
-1 :デバイスドライバが常駐していない
-2 :ハードウェアが存在しない

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

ret = FGS_init2(fgs_work, 1536);

- 内容 -
FGSオープンレベルが1インクリメントされ、FGSオープンレベルが0から1に変化した時
のみ次の初期化処理をおこないます。
作業域を以下の内容に初期化し、画面(全ページ)を色識別番号0で塗りつぶします。
作業域の大きさは、1536バイト固定です。
    解像度                  :640×480×1677万色×1画面
    表示画面上の表示開始位置:(0,0)
    仮想画面上の表示開始位置:(0,0)
    画面拡大率              :1倍
    表示領域の大きさ        :640×480
    書き込みページ          :ページ0 
    表示ページ              :ページ0 
    パレットレジスタ        :パレット番号nに対してRGB=nnn 
    (フルカラーカードのみ)

なお、フルカラーカードが装着されている場合は画面モード3に、本体フルカラーのみ
の場合には画面モード4に設定します。

-----------------------------------------------------------------------------
.FGS_openCheck 
動作状態の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_openCheck(void);

- 戻り値 -
 0 :正常終了(使用可能)
-1 :デバイスドライバが常駐していない
-2 :フルカラーカードが存在しない

- 例 -
#include <fgs.h>
        …
int     ret;

ret = FGS_openCheck();

- 内容 -
フルカラーカードが使用可能かどうかを調べます。

-----------------------------------------------------------------------------
.FGS_openCheck2
動作状態の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_openCheck2(void); 

- 戻り値 -
 0 :正常終了(使用可能)
-1 :デバイスドライバが常駐していない
-2 :本体フルカラーが存在しない

- 例 -
#include <fgs.h>
int     ret;

ret = FGS_openCheck2(); 

- 内容 -
本体フルカラーが使用可能かどうか調べます。

-----------------------------------------------------------------------------
.FGS_palette 
パレットレジスタの設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_palette(char *fgs_work, int vsync, char *para); 
char    *fgs_work;        /*  作業域のアドレス              */
int     vsync;            /*  0:vsyncを待たずに設定
                              1:vsyncを待って設定           */
char    *para;            /*  パラメータのアドレス          */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
char    para[64]; 
int     ret;

DWORD(para + 0) = 1;
DWORD(para + 4) = 7;
BYTE(para + 8) = 128; 
BYTE(para + 9) = 128; 
BYTE(para + 10) = 128;
BYTE(para + 11) = 0;
ret = FGS_palette(fgs_work, 1, para); 

- 内容 -
色識別番号に対応する色(三原色:赤、緑、青の階調)を設定します。画面モード1、3に
対して有効です。VSYNCを待って設定すると非表示期間中にパレット設定が行われるた
め画面のちらつきをなくすことができます。

パラメータの形式

 ･256色モード
    ┌─┬──────────────┐
   0│Ｄ│設定するパレットの総数      │
    ├─┼──────────────┤┐
   4│Ｄ│色識別番号(通し番号)        ││
    ├─┼──────────────┤│
   8│Ｂ│青の階調  (0〜 255)         ││
    ├─┼──────────────┤│
   9│Ｂ│赤の階調  (0〜 255)         │├※
    ├─┼──────────────┤│
   A│Ｂ│緑の階調  (0〜 255)         ││
    ├─┼──────────────┤│
   B│Ｂ│  0                         ││
    ├─┼──────────────┤┘
    〜  〜      ※の繰り返し          〜
    └─┴──────────────┘

 ･1677万色モード
    ┌─┬──────────────┐
   0│Ｄ│設定するパレットの総数      │
    ├─┼──────────────┤┐
   4│Ｄ│色識別番号(通し番号)        ││
    ├─┼──────────────┤│
   8│Ｂ│赤の階調  (0〜 255)         ││
    ├─┼──────────────┤│
   9│Ｂ│緑の階調  (0〜 255)         │├※
    ├─┼──────────────┤│
   A│Ｂ│青の階調  (0〜 255)         ││
    ├─┼──────────────┤│
   B│Ｂ│  0                         ││
    ├─┼──────────────┤┘
    〜  〜      ※の繰り返し          〜
    └─┴──────────────┘

-----------------------------------------------------------------------------
.FGS_partGetBlock
ドットデータの読み込み2
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_partGetBlock(char *fgs_work, int mode, char *para);
char    *fgs_work;        /*  作業域のアドレス              */
int     mode;             /*  ピクセルあたりのビット数
                                  0:24ビット/ピクセル
                                  1:32ビット/ピクセル       */
char    *para;            /*  パラメータのアドレス          */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
char    para[64]; 
int     mode; 
int     ret;

mode = 1; 
ret = FGS_partGetBlock(fgs_work, mode, para);

- 内容 -
指定した矩形域内のドットデータを読み込みデータ格納領域の一部に転送します。
指定された矩形が仮想画面をはみ出した場合は、そのはみ出した部分に0が読み込まれ
ます。なお、1677万色ページでは、その読み込んだデータを1ピクセルあたり24ビット
か32ビットにする指定を行う必要があります。

    ┌─┬───────────┐
   0│Ｄ│データ格納領域アドレス│
    ├─┼───────────┤
   4│Ｗ│データ格納領域セレクタ│
    ├─┼───────────┤
   6│SW│第1点Ｘ座標           │
    ├─┼───────────┤
   8│SW│第1点Ｙ座標           │
    ├─┼───────────┤
   A│SW│第2点Ｘ座標           │
    ├─┼───────────┤
   C│SW│第2点Ｙ座標           │
    ├─┼───────────┤
   E│SW│データ領域横方向サイズ│
    ├─┼───────────┤
  10│SW│データ領域縦方向サイズ│
    ├─┼───────────┤
  12│SW│読込矩形相対位置(Ｘ)  │
    ├─┼───────────┤
  14│SW│読込矩形相対位置(Ｙ)  │
    └─┴───────────┘
      ▲パラメータの形式

    ┌─┬───────────┐
    │BA│ 8/16/24/32 bit pixel │
    〜  〜      データ列        〜
    └─┴───────────┘
      ▲データ格納領域のデータ格納形式

データ領域の大きさ(必要なバイト数)は以下の式に基づいて求めます。
  ･256色モード時               (横の大きさ)×(縦の大きさ)
  ･32768色モード時             (横の大きさ)×2×(縦の大きさ)
  ･1677万色モード時  (mode=0)  (横の大きさ)×3×(縦の大きさ)
  ･1677万色モード時  (mode=1)  (横の大きさ)×4×(縦の大きさ)

読み込み位置は以下の関係になっています。

図EXL121R-038

-----------------------------------------------------------------------------
.FGS_partPutBlock
ドットデータの書き込み2
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_partPutBlock(char *fgs_work, int mode, char *para);
char    *fgs_work;        /*  作業域のアドレス              */
int     mode;             /*  ピクセルあたりのビット数
                                  0:24ビット/ピクセル
                                  1:32ビット/ピクセル       */
char    *para;            /*  パラメータのアドレス          */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
char    para[64]; 
int     mode; 
int     ret;

mode = 1; 
ret = FGS_partPutBlock(fgs_work, mode, para);

- 内容 -
指定した矩形域内のドットデータに書き込みデータ格納領域の一部を転送します。
なお、1677万色ページでは、その読み込んだデータを1ピクセルあたり24ビットか32
ビットにする指定を行う必要があります。

    ┌─┬───────────┐
   0│Ｄ│データ格納領域アドレス│
    ├─┼───────────┤
   4│Ｗ│データ格納領域セレクタ│
    ├─┼───────────┤
   6│SW│第1点Ｘ座標           │
    ├─┼───────────┤
   8│SW│第1点Ｙ座標           │
    ├─┼───────────┤
   A│SW│第2点Ｘ座標           │
    ├─┼───────────┤
   C│SW│第2点Ｙ座標           │
    ├─┼───────────┤
   E│SW│データ領域横方向サイズ│
    ├─┼───────────┤
  10│SW│データ領域縦方向サイズ│
    ├─┼───────────┤
  12│SW│書込矩形相対位置(Ｘ)  │
    ├─┼───────────┤
  14│SW│書込矩形相対位置(Ｙ)  │
    └─┴───────────┘
      ▲パラメータの形式

    ┌─┬───────────┐
    │BA│ 8/16/24/32 bit pixel │
    〜  〜      データ列        〜
    └─┴───────────┘
      ▲データ格納領域のデータ格納形式

データ領域の大きさ(必要なバイト数)は以下の式に基づいて求めます。
  ･256色モード時               (横の大きさ)×(縦の大きさ)
  ･32768色モード時             (横の大きさ)×2×(縦の大きさ)
  ･1677万色モード時  (mode=0)  (横の大きさ)×3×(縦の大きさ)
  ･1677万色モード時  (mode=1)  (横の大きさ)×4×(縦の大きさ)

書き込み位置は以下の関係になっています。

図EXL121R-039

-----------------------------------------------------------------------------
.FGS_putBlock
ドットデータの書き込み1
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_putBlock(char *fgs_work, int mode, char *para);
char    *fgs_work;      /*  作業域のアドレス                */
int     mode;           /*  ピクセルあたりのビット数
                                0:24ビット/ピクセル
                                1:32ビット/ピクセル         */
char    *para;          /*  パラメータのアドレス            */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
char    para[64]; 
int     mode; 
int     ret;

mode = 1; 
ret = FGS_putBlock(fgs_work, mode, para);

- 内容 -
指定された矩形域内にデータ格納領域のドットデータを書き込みます。なお、1677万
色ページでは、書き込むデータが1ピクセルあたり24ビットか32ビットであるか指定す
る必要があります。

    ┌─┬───────────┐
   0│Ｄ│データ格納領域アドレス│
    ├─┼───────────┤
   4│Ｗ│データ格納領域セレクタ│
    ├─┼───────────┤
   6│SW│第1点Ｘ座標           │
    ├─┼───────────┤
   8│SW│第1点Ｙ座標           │
    ├─┼───────────┤
   A│SW│第2点Ｘ座標           │
    ├─┼───────────┤
   C│SW│第2点Ｙ座標           │
    └─┴───────────┘
      ▲パラメータの形式

    ┌─┬───────────┐
    │BA│ 8/16/24/32 bit pixel │
    〜  〜      データ列        〜
    └─┴───────────┘
      ▲データ格納領域のデータ格納形式

データ領域の大きさ(必要なバイト数)は以下の式に基づいて求めます。
  ･256色モード時               (横の大きさ)×(縦の大きさ)
  ･32768色モード時             (横の大きさ)×2×(縦の大きさ)
  ･1677万色モード時  (mode=0)  (横の大きさ)×3×(縦の大きさ)
  ･1677万色モード時  (mode=1)  (横の大きさ)×4×(縦の大きさ)

-----------------------------------------------------------------------------
.FGS_putRaster 
ドットデータの書き込み4
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_putRaster(char *fgs_work, int x, int y, int size, char *data);
char    *fgs_work;        /*  作業域のアドレス              */
int     x,y;              /*  描画開始位置(ｘ、ｙ座標)      */
int     size;             /*  データサイズ(×4バイト)       */
char   *data;             /*  書き込みデータの領域          */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
char    data[128];
int     ret;

ret = FGS_fillRaster(fgs_work, 100, 100, 20, data);

- 内容 -
指定された座標から指定されたサイズ分指定されたデータをx軸正方向に書き込みま
す。書き込みデータの転送量は画面モードにかかわりなくデータサイズ×4バイト分
です。なおデータサイズの最大値は1024です。
右端よりはみ出す指定を行った場合、その行の右端まで書き込みます。

-----------------------------------------------------------------------------
.FGS_resolution
仮想画面の設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_resolution(char *fgs_work, int page, int mode);
char    *fgs_work;        /*  作業域のアドレス                        */
int     page;             /*  ページ  0or1                            */
int     mode;             /*  番号(bit6="1"ではcrtc操作をしません)    */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;

ret = FGS_resolution(fgs_work, 0, 1);

- 内容 -
仮想画面モードを設定します。作業域の初期化をします。ハードウェアで設定可能な
解像度のうち、使用したい解像度の設定を行います。仮想画面、表示画面とも消去さ
れません。256色、1677万色画面はページ0に、32768色画面はページ1に固定です。
また、256色画面と32768色画面は必ず重ね合わせされます。
したがって、指定できるページと画面番号の組み合わせは以下のようになります。
なお、下表の1と2は同じ設定となります。

┌──┬───────────┬───────┬────────────┐
│番号│    画  面  番  号    │  ペ  ー  ジ  │        備    考        │
├──┼───────────┼───────┼────────────┤
│  1 │  1(256色)            │      0       │32768色画面も有効       │
├──┼───────────┼───────┼────────────┤
│  2 │  2(32768色)          │      1       │256色画面も有効         │
├──┼───────────┼───────┼────────────┤
│  3 │  3(1677万色)         │      0       │                        │
├──┼───────────┼───────┼────────────┤
│  4 │  4(1677万色)         │      0       │本体フルカラー専用      │
└──┴───────────┴───────┴────────────┘

画面構成

  図EXL121R-040
  図EXL121R-041

なお、設定する初期値は以下のとおりです。
  表示画面上の表示開始位置      :(0, 0)
  仮想画面上の表示開始位置      :(0, 0)
  画面拡大率                    :1倍
  表示領域の大きさ              :640×480
  書き込みページ                :ページ0
  表示ページ                    :ページ0
  パレットレジスタ              :256色モードはEGBの初期値と同じ
  1677万色モードは初期化時と同じ
  (フルカラーカードのみ)

-----------------------------------------------------------------------------
.FGS_setPack 
パック状態の設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_setPack(int mode);
int     mode;               /*  1ピクセルあたりのバイト数  */
                            /*    0:  1ピクセル3バイト     */
                            /*    1:  1ピクセル4バイト     */

- 戻り値 -
 0 :正常終了
-1 :誤った画面モードでこの関数を使用した

- 例 -
#include <fgs.h>
int     ret;
int     mode; 

ret = FGS_setPack(mode);

- 内容 -
画面モード4のとき、現在の1ピクセルあたりのバイト数を設定します。
初期値は1ピクセル4バイトです。

-----------------------------------------------------------------------------
.FGS_setys 
重ね合わせ信号の設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_setys(void);

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
int     ret;
ret = FGS_setys();

- 内容 -
重ね合わせ信号の設定をします。EGBで画面モード切り換えを行ったあとに呼び出して
ください。フルカラーカード使用時にのみ有効です。

-----------------------------------------------------------------------------
.FGS_viewport
ビューポートの設定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_viewport(char *fgs_work, char para);
char    *fgs_work;          /*  作業域のアドレス            */
char    para;               /*  パラメータのアドレス        */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
char    para[64]; 
int     ret;
ret = FGS_viewport(fgs_work, para);

- 内容 -
ビューポートを設定します。仮想画面について設定されます。
座標値が仮想画面を越えた場合、仮想画面の大きさにビューポートが設定されます。
パラメータのフォーマットは以下のとおりです。

パラメータの形式
    ┌─┬───────────┐
   0│SW│第1点Ｘ座標           │
    ├─┼───────────┤
   2│SW│第1点Ｙ座標           │
    ├─┼───────────┤
   4│SW│第2点Ｘ座標           │
    ├─┼───────────┤
   6│SW│第2点Ｙ座標           │
    └─┴───────────┘

-----------------------------------------------------------------------------
.FGS_writePage 
書き込みページの指定
-----------------------------------------------------------------------------

- 定義 -
#include <fgs.h>
int     FGS_writePage(char *fgs_work, int npage); 
char    *fgs_work;          /*  作業域のアドレス            */
int     npage;              /*  書き込みページのページ番号  */

- 戻り値 -
0 :正常終了

- 例 -
#include <fgs.h>
        …
char    fgs_work[1536]; 
int     ret;
ret = FGS_writePage(fgs_work, 0); 

- 内容 -
書き込みページを指定します。表示ページが0で書き込みページが1の場合、AAAという
パターンを書き込むと、パターンはページ1にのみ書き込まれます。
表示されているのはページ0のみのため、画面には表示されません。

  ┌─────────┐
  │┌───────┐│    ┌───────┐
  ││              ││    │ＡＡＡ        │
  ││              ││    │              │
  ││      ページ0 ││    │      ページ1 │
  │└───────┘│    └───────┘
  └─────────┘
    ディスプレイ                書き込みページ

4.3 サンプルプログラム

┌────────────────────────────────────┐
│  フルカラーライブラリ  サンプルプログラム                              │
│  ■  機能  ■                                                          │
│    サンプル  1  フルカラー画像をセルに区切り、セル交換を行います。     │
│    サンプル  2  ビデオ機能をフルカラー画面にビデオキャプチャします。   │
└────────────────────────────────────┘
/*
 *
 *      フルカラーライブラリ サンプルプログラム  1
 *        このサンプルプログラムは、フルカラー(1ピクセル3バイト)
 *      最大640×480ピクセルのTIFFファイル(非圧縮、パレットな
 *      し)を読み込んで10×10の区画(セル)に区切り、そのセルを
 *      入れ換えていくものです  他のデータを扱う際はデータ読み取り部
 *      分を変更してください  またデータサイズによってはメモリが
 *      2ＭＢでは動作しない場合があります
 *        またマウスのボタンを押すと元の画像に戻して終了します
 *
 *        実行時には表示するTIFFファイル名を第一パラメータに設定して
 *      ください
 *
 *      例)  run386 sample1.exp sample.tif
 *
 */ 

#include "fgs.h"
#include "egb.h"
#include "mos.h"
#include <msdos.cf>
#include <stdio.h>
#include <stdlib.h>
#include "tifflib.h"

#define BUFFSIZE 12800              /* ヘッダ読み込み用バッファサイズ    */
#define XSIZE 10                    /* 横方向の分割数                    */
#define YSIZE 10                    /* 縦方向の分割数                    */

    char EGB_work[1536];            /* EGBワークエリア                   */
    char FGS_work[1536];            /* FGSワークエリア                   */
    char para[64];                  /* FGS関数用パラメタエリア */
    char savearea[2][XSIZE * YSIZE * 4];
                                    /* 退避領域                          */

    char mwork[4096];               /* マウス用ワークエリア              */

void main(argc,argv )
int          argc  ;
char        *argv[]  ;
{
    FILE    *fd;                    /* ファイルディスクリプタ              */
    int     xsel[640 / XSIZE][480 / YSIZE],ysel[640 / XSIZE][480 / YSIZE];
                                /* 現在(x,y)の位置にあるセルの元の座標     */
    int     xpos[640 / XSIZE][480 / YSIZE],ypos[640 / XSIZE][480 / YSIZE];
                                /* 最初(x,y)の位置にあったセルの現在の座標 */
    int     i,j;                /* ループ変数                              */
    int     x,y,xp,yp,xb,yb;    /* 座標用変数                              */
    int     xw,yw;              /* スワップ用ワーク                        */
    int     btn,mx,my;          /* マウス用変数                            */
    int     comp,fill;          /* TIFFローダ用変数                        */
    long    strip,clut;         /* TIFFローダ用変数                        */
    char    *buf;               /* データバッファ用ポインタ                */
    char    *Pattern_File;      /* ファイル名用ポインタ                    */

    if (argc >= 2)                  /* ファイル名が設定されているか？      */
        Pattern_File = argv[1]  ;
    else                            /* ファイル名がなければ終了            */
        exit(-1);

    fd = fopen(Pattern_File,"rb"); /* ファイルをバイナリ/読み込みでオープン*/
    if (fd == NULL)                 /* ファイルがなければ終了              */
        exit(-1);

    buf = malloc(BUFFSIZE);         /* バッファを取得します                */
    if (buf == NULL)                /* バッファが取れなければ終了          */
        goto file_close;

    EGB_init(EGB_work,1536);        /* EGBの初期化                         */
    FGS_init(FGS_work,1536);        /* FGSの初期化                         */
    MOS_start(mwork,4096);          /* マウスの初期化                      */

    fread(buf,BUFFSIZE,1,fd);      /* バッファサイズ分データを読み込みます */
        /* ヘッダの解析 */

    if (TIFF_getHead(buf,BUFFSIZE) < 0)
        goto quit;                  /* ヘッダがなければ終了                */

    if (TIFF_checkMode(&x,&y,&comp,&fill,&strip,&clut) != 24)
        goto quit;                  /* フルカラーデータ以外なら終了        */

    if ((comp != 1) || (clut != 0))
        goto quit;                  /* 非圧縮、パレットなし以外なら終了    */

    fseek(fd,strip,SEE  SET);       /* 画像データの先頭に移動します        */

    free(buf);
    buf = malloc(x * y * 3);        /* データバッファを取得します          */

    if (buf == NULL)                /* バッファが取れなければ終了          */
        goto quit;

    for (i = 0; i < y; i++)             /* データが終わるまで              */
        fread(buf + i * x * 3,x * 3,1,fd);  /* 一行分データを読み込みます  */

        /* FGS_putBlock用パラメタの設定 */ 
    DWORD(para + 0) = (unsigned int)buf;
    WORD(para +  4) = getds();
    WORD(para +  6) = 0;
    WORD(para +  8) = 0;
    WORD(para + 10) = x - 1;
    WORD(para + 12) = y - 1;

    FGS_putBlock(FGS_work,0,para);  /* ドットデータを書き込みます          */

        /* 各セル情報の初期設定                                            */
    for (i = 0; i < 640 / XSIZE; i++)
        for (j = 0; j < 480 / YSIZE; j++){
            xsel[i][j] = i;
            ysel[i][j] = j;
            xpos[i][j] = i;
            ypos[i][j] = j;
        }

    savesel(0,0);                   /* (0,0)を起点としているためセルを退避 */

    xb = 0; yb = 0; x = 0; y = 0; btn = 0;

    while ((btn & 3) == 0){         /* マウスのボタンが押されるまで        */
        do {
            xp = rand() % 3 - 1;   /* コピーするセルの相対位置を決定します */
            yp = rand() % 3 - 1;
            x = xb + xp;            /* 前の座標から次の座標を計算します    */
            y = yb + yp;
            if ((x < 0) || (y < 0)  /* 画面外に出てしまったらもう一度      */
             || (x > 640 / XSIZE - 1) || (y > 480 / YSIZE - 1)){
                xp = 0;yp = 0;
            }
        } while ((xp == 0) && (yp == 0));  /* 元と同じ位置なら繰り返します */

        copysel(x,y,xb,yb);                 /* copy (x,y)-->(xb,yb)        */
            /* セル情報の入れ換え */
        xpos[xsel[x][y]][ysel[x][y]] = xb;
        ypos[xsel[x][y]][ysel[x][y]] = yb;
        xpos[xsel[xb][yb]][ysel[xb][yb]] = x;
        ypos[xsel[xb][yb]][ysel[xb][yb]] = y;
        xw = xsel[xb][yb];
        yw = ysel[xb][yb];
        xsel[xb][yb] = xsel[x][y];
        ysel[xb][yb] = ysel[x][y];
        xsel[x][y] = xw;

        ysel[x][y] = yw;

        xb = x; yb = y;

        MOS_rdpos(&btn,&mx,&my);        /* マウスボタンの読み取り        */

    }

    loadsel(xpos[0][0],ypos[0][0]);

    /* セル情報を元に画面を元に戻します */ 
    for (i = 0; i < 640 / XSIZE; i++)
        for (j = 0; j < 480 / YSIZE; j++)
            if ((xpos[i][j] != i) || (ypos[i][j] !=j )){
                savesel(i,j);
                x = i; y = j;
                do {
                    xb = x;
                    yb = y;
                    x = xpos[xb][yb];
                    y = ypos[xb][yb];

                    copysel(x,y,xb,yb);

                    xpos[xb][yb] = xb;
                    ypos[xb][yb] = yb;

                } while((x != i) || (y != j));

                loadsel(xb,yb);

            }

    free(buf);                  /* メモリを開放        */
quit:
    MOS_end();                  /* マウスの終了処理    */
file_close:
    fclose(fd);                 /* ファイルのクローズ  */
}

/*                                                     */ 
/*   (xs,ys)の矩形を(xd,yd)の矩形にコピーする関数      */
/*                                                     */ 

int copysel(xs,ys,xd,yd)
int xs,ys,xd,yd;
{

    /* printf(" copy (%d,%d)->(%d,%d)\n",xs,ys,xd,yd); */

        /* FGS_getBlock用パラメタの設定 */ 
        DWORD(para) = (unsigned int)savearea;
        WORD(para +  4) = getds();
        WORD(para +  6) = XSIZE * xs;
        WORD(para +  8) = YSIZE * ys;

        WORD(para + 10) = XSIZE * (xs + 1) - 1;
        WORD(para + 12) = YSIZE * (ys + 1) - 1;

        FGS_getBlock(FGS_work,1,para);

        /* FGS_putBlock用パラメタの設定                */
        WORD(para +  6) = XSIZE * xd;
        WORD(para +  8) = YSIZE * yd;
        WORD(para + 10) = XSIZE * (xd + 1) - 1;
        WORD(para + 12) = YSIZE * (yd + 1) - 1;

        FGS_putBlock(FGS_work,1,para);

return 0;

}

/*                                                    */
/*   (x,y)の矩形に退避されているセルを復元する関数    */
/*                                                    */

int loadsel(x,y)

int x,y;
{

    /* printf(" load (%d,%d)\n",x,y);                 */

        /* FGS_putBlock用パラメタの設定               */ 
    DWORD(para) = (unsigned int)(&savearea[1][0]);
    WORD(para +  4) = getds();
    WORD(para +  6) = XSIZE * x;
    WORD(para +  8) = YSIZE * y;
    WORD(para + 10) = XSIZE * (x + 1) - 1;
    WORD(para + 12) = YSIZE * (y + 1) - 1;

    FGS_putBlock(FGS_work,1,para);

return 0;
}
/*                                                    */
/*   (x,y)の矩形を退避領域に退避する関数              */
/*                                                    */

int savesel(x,y)

int x,y;
{
    /* printf(" save (%d,%d)\n",x,y);                 */

        /* FGS_getBlock用パラメタの設定               */ 
    DWORD(para) = (unsigned int)(&savearea[1][0]);
    WORD(para +  4) = getds();
    WORD(para +  6) = XSIZE * x;
    WORD(para +  8) = YSIZE * y;

    WORD(para + 10) = XSIZE * (x + 1) - 1;
    WORD(para + 12) = YSIZE * (y + 1) - 1;

    FGS_getBlock(FGS_work,1,para);

return 0;
}

/*
 *
 *      フルカラーライブラリ サンプルプログラム  2
 *        このサンプルプログラムはフルカラー画面にビデオキャプチャす
 *      るもので、フルカラービデオキャプチャカードが必要です  ビデオ
 *      画像を全画面に表示し、左ボタンでその位置を変更し右ボタンで拡
 *      大率を変更することができます  終了はマウスの両ボタンを押しま
 *      す
 *
 */ 

#include "fgs.h"
#include "egb.h"
#include "mos.h"

    void    count();                /* タイマ関数                         */

    char    EGB_work[1536];         /* EGBワークエリア                    */
    char    FGS_work[1536];         /* FGSワークエリア                    */
    char    mwork[4096];            /* マウス用ワークエリア               */
    int     time;                   /* タイマ用変数                       */

    int     btn,mx=0,my=0;          /* マウス用変数                       */
    int     x1=0,y1=0,x2=640,y2=480,xb,yb;  /* 座標計算用変数             */
    int     val=128;                /* 画質調整用ダミー変数               */

void main()
{
    int     i;                      /* ループ変数                         */

    EGB_init(EGB_work,1536);        /* EGBの初期化                        */
    FGS_init(FGS_work,1536);        /* FGSの初期化                        */
    MOS_start(mwork,4096);          /* マウスの初期化                     */
    MOS_disp(1);                    /* マウスカーソルを表示               */
    MOS_setEvent(count);            /* タイマカウンタの登録               */

    time = 0;

    FGS_digitizeMode(FGS_work,0);       /* 取り込みモードを奇数フレーム   */
        /* 縦に2倍拡大して縦横のサイズを合わせます                        */
    FGS_displayStart(FGS_work,2,1,2);
        /* 画質の調整をＲＯＭの値を使用して行います                       */

    for (i = 0; i <= 4; i++)
        FGS_digitizeQuality(FGS_work,i,&val,1);

    FGS_digitize(FGS_work,1);           /* 取り込み開始                   */

    btn = 0;
    while((btn & 3) != 3) {             /* 両ボタンを押したら終了         */
        MOS_rdpos(&btn,&mx,&my);        /* マウス状態の読み取り           */
        MOS_motion(&xb,&yb);            /* マウス状態の読み取り           */
        if ((btn & 3) == 1) {
            x1 += xb;                   /* マウス移動量を計算             */
            y1 += yb;
                /* 範囲チェック                                           */
            if (x1 < 0) x1 = 0;
            if (x1 > 639) x1 = 639;
            if (y1 < 0) y1 = 0;
            if (y1 > 479) y1 = 479;

            if (time >= 2) {  /* マウスのタイマを使って約40mS待ちます     */
                time = 0;     /* すると一画面分のディジタイズが行われます */
                    /* キャプチャした画像の表示位置を変更 */
                FGS_digitizeStart(FGS_work,x1,y1/2);
            }
        } else if ((btn & 3) == 2) {
            x2 += xb;                   /* マウス移動量を計算             */
            y2 += yb;
                /* 範囲チェック */
            if (x2 < 0) x2 = 0;
            if (x2 > 639) x2 = 639;
            if (y2 < 0) y2 = 0;
            if (y2 > 479) y2 = 479;

            if (time >= 2) {  /* マウスのタイマを使って約40mS待ちます     */
                time = 0;     /* すると一画面分のディジタイズが行われます */
                  /* キャプチャした画像の拡大率を変更                     */
                FGS_digitizeZoom(FGS_work,x2 * 256 / 639,y2 * 256 / 479);
            }
        }
    }

    MOS_end();
}

/*

    マウス割り込み毎に変数をカウントアップします

*/

void    count()
{
    time++;
}

*****************************************************************************
第16章  タブレットライブラリ
*****************************************************************************

1 タブレットライブラリについて

1.1 概要

  タブレットドライバは、タブレットをマウスの代わりに利用するためのドライバソ
フトウェアです。  このドライバを組み込むことにより、マウスで操作するアプリケ
ーションをそのままタブレットで操作することができます。ただし、マウス固有の機
能である
    ｢パルス数/画素比の設定｣
    ｢加速度検出の設定｣
はタブレットに対しては無効となります。それ以外の機能は、すべてマウスと同様に
利用できます。

  タブレットを利用することにより、直接特定の座標へ移動できる｢直接座標移動機能
｣が利用でき、省スペースな操作環境が得られます。また、タブレット固有の機能であ
る｢筆圧検出機能｣により、従来のマウスでは実現しづらい自然な描画処理を可能とし
ます。

  また、タブレットとマウスを同時に利用できる｢マウス/タブレット同時使用機能｣や
、接続されている入力装置を自動的に判別して動作する｢自動判別機能｣を内蔵してい
ます。

1.2 注意事項

  タブレットドライバはFM TOWNSの全画面モードに対応するため、画面モードに対応
した読み取り開始位置に設定します。
  ｢AH=00H 動作開始:MOS_start関数｣と｢AH=0EH 書き込みページの指定:MOS_writePage
関数｣が呼ばれた際、以下のように読み取り開始位置と読み取りドット数/画素比の初
期化を行います。

  タブレットドット数X＝画面ドット数X
  タブレットドット数Y＝画面ドット数Y
  読み取り開始位置X＝(1280−画面ドット数X)÷2
  読み取り開始位置Y＝(960−画面ドット数Y)÷2

- 例 -
              │                      │  ﾀﾌﾞﾚｯﾄﾄﾞｯﾄ数X
   (0,0)  ─→┼───────────┼←───────────────
    ┌────┼───────────┼────┐
    │        │                      │  ↓    │
    ├────┼───────────┼─┼─  │
    │        │(読み取り開始位置)  　│  │    │
    │        │                      │  │    │
    │        │                      │  │    │
    │        │                      │  │    │
    │        └───────────┴─┼─  │
    │                                    ↑    │
    └──────────────────┼──┘(1279,959)
                                          │ﾀﾌﾞﾚｯﾄﾄﾞｯﾄ数Y
                                          │
  
              │                      │  1024
          ─→┼───────────┼←───────────────
    ┌────┼───────────┼────┐
    │        │                      │  ↓    │
    ├────┼───────────┼─┼─  │
    │        │(128,224) 　          │  │    │
    │        │                      │  │    │
    │        │                      │  │    │
    │        │                      │  │    │
    │        └───────────┴─┼─  │
    │                                    ↑    │
    └──────────────────┼──┘
                                          │512 
                                          │
      仮想画面(X,Y)＝(1024,512)の場合

2 タブレットライブラリ

2.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│TAB_rdpos                 │タブレット座標の読み取り                  │
├─────────────┼─────────────────────┤
│TAB_checkDriver           │ドライバ接続状態の読み取り                │
├─────────────┼─────────────────────┤
│TAB_setPress              │筆圧の設定                                │
├─────────────┼─────────────────────┤
│TAB_getPress              │筆圧の読み取り                            │
├─────────────┼─────────────────────┤
│TAB_setRdstart            │読み取り開始位置の設定                    │
├─────────────┼─────────────────────┤
│TAB_getRdstart            │読み取り開始位置の読み取り                │
├─────────────┼─────────────────────┤
│TAB_setPulse              │読み取りドット数/画素比の設定           　│
├─────────────┼─────────────────────┤
│TAB_getPulse              │読み取りドット数/画素比の読み取り       　│
├─────────────┼─────────────────────┤
│TAB_rdposDirect           │タブレット座標の直接読み取り              │
├─────────────┼─────────────────────┤
│TAB_connectStatus         │タブレットドライバのポート接続状態の取得  │
└─────────────┴─────────────────────┘

2.2 各関数の解説

-----------------------------------------------------------------------------
.TAB_checkDriver 
ドライバ接続状態の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <tablet.h> 
int      TAB_checkDriver(void);

- 戻り値 -
 0 :インテリジェントマウスドライバを接続
 1 :タブレットドライバを接続
-1 :TBIOSが機能未サポート

- 例 -
#include <tablet.h> 
        …
if (TAB_checkDriver() == -1){
    printf("OSのバージョンが違います  処理を終了します\n"); 
    exit(-1); 
    }

- 内容 -
現在のマウスBIOSに接続されているドライバのIDを返します。
この機能を利用することにより、ドライバの接続状態を判別できます。

-----------------------------------------------------------------------------
.TAB_connectStatus 
タブレットドライバのポート接続状態の取得
-----------------------------------------------------------------------------

- 定義 -
#include <tablet.h> 
int      TAB_connectStatus(void);

- 戻り値 -
0 :接続状態

- 例 -
#include <tablet.h> 
        …
int   ret;
ret = TAB_connectStatus();
if (ret & 0x01)
    printf("ポート1＝マウス    を接続しています\n");
if (ret & 0x02)
    printf("ポート1＝タブレットを接続しています\n");
if (ret & 0x10000)
    printf("ポート2＝マウス    を接続しています\n");
if (ret & 0x20000)
    printf("ポート2＝タブレットを接続しています\n");

- 内容 -
タブレットドライバのポート接続状態を返します。
接続状態はint型で以下のように返され、接続されている場合はビットが立ち、
接続されていない場合はビットが消えます。

        31〜19  18  17  16  15〜3    2   1   0
      ┌───┬─┬─┬─┬───┬─┬─┬─┐
  ret │      │  │  │  │      │  │  │  │
      └───┴┬┴┬┴┬┴───┴─┴┬┴┬┘
                │  │  │          │  │  │
                │  │  │          │  │  └─ポート1  マウス接続状態
                │  │  │          │  └───ポート1  タブレット接続状態
                │  │  │          └─────ポート1  パッド接続状態
                │  │  └───────────ポート2  マウス接続状態
                │  └─────────────ポート2  タブレット接続状態
                └───────────────ポート2  パッド接続状態

-----------------------------------------------------------------------------
.TAB_getPress
筆圧の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <tablet.h> 
int      TAB_getPress(int *press); 
int     *press;             /*  ボタンの状態              */

- 戻り値 -
 0 :正常終了
-1 :エラー

- 例 -
#include <tablet.h> 
        …
int press;
int ret;
ret = TAB_getPress(&press); 

- 内容 -
現在設定されている筆圧を読み取ります。

-----------------------------------------------------------------------------
.TAB_getPulse
読み取りドット数/画素比の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <tablet.h> 
int      TAB_getPulse(short *para);
short    para[4];           /*  パラメータ                    */

- 戻り値 -
 0 :正常終了
-1 :エラー

- 例 -
#include <tablet.h> 
        …
short para[4];
int ret;
ret = TAB_getPulse(para); 

- 内容 -
タブレットの読み取りドット数/画素比を読み取ります。

  ┌───┬─────────────┐
  │  SW  │  画面のドット数Ｘ        │
  ├───┼─────────────┤
  │  SW  │  画面のドット数Ｙ        │
  ├───┼─────────────┤
  │  SW  │  タブレットのドット数Ｘ  │
  ├───┼─────────────┤
  │  SW  │  タブレットのドット数Ｙ  │
  └───┴─────────────┘
     ▲パラメータの形式

-----------------------------------------------------------------------------
.TAB_getRdstart
読み取り開始位置の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <tablet.h> 
int      TAB_getRdstart(int *beginX, int *beginY); 
int      beginX;            /*  読み取り開始点Ｘ      */
int      beginY;            /*  読み取り開始点Ｙ      */

- 戻り値 -
 0 :正常終了
-1 :エラー

- 例 -
#include <tablet.h> 
        …
int beginX; 
int beginY; 
int ret;
ret = TAB_getRdstart(&beginX,&beginY);

- 内容 -
タブレットの座標読み取り開始点を読み取ります。

-----------------------------------------------------------------------------
.TAB_rdpos 
タブレット座標の読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <tablet.h> 
int      TAB_rdpos(int *tr, int *x, int *y, int *press); 
int      *tr;               /*  ボタンの状態              */
int      *x;                /*  マウスカーソルの水平位置  */
int      *y;                /*  マウスカーソルの垂直位置  */
int      *press;            /*  タブレットペンの筆圧      */

- 戻り値 -
0 :正常終了

- 例 -
#include <tablet.h> 
        …
int   tr,x,y,press; 
do{
    TAB_rdpos(&tr,&x,&y,&press);
  }while(tr != 0x03);

- 内容 -
現在、マウスカーソルが指している画面座標と、タブレットのボタン状態、タブレッ
トペンの筆圧を読み取ります。通常タブレットのボタン状態は、タブレットペンの筆
圧が一定以上加わることにより左ボタンが押されたことが検出でき、タブレットペン
のサイドスイッチを押すことにより右ボタンが押されたことが検出できます。
タブレットペンの筆圧は、1が最小で126が最大となります。
タブレットペンの筆圧の強弱の設定は、TAB_setPress関数で設定できます。

-----------------------------------------------------------------------------
.TAB_rdposDirect 
タブレット座標の直接読み取り
-----------------------------------------------------------------------------

- 定義 -
#include <tablet.h> 
int      TAB_rdposDirect(int *Dtr, int *Dx, int *Dy, int *Dpress); 
int      *Dtr;              /*  ボタンの状態              */
int      *Dx;               /*  マウスカーソルの水平位置  */
int      *Dy;               /*  マウスカーソルの垂直位置  */
int      *Dpress;           /*  タブレットペンの筆圧      */

- 戻り値 -
0 :正常終了

- 例 -
#include <tablet.h> 
        …
int   Dtr,Dx,Dy,Dpress; 
do{
    TAB_rdposDirect(&Dtr,&Dx,&Dy,&Dpress);
    }while(Dtr != 0x03); 

- 内容 -
タブレットのハードウェアが返す座標と、ボタン状態と筆圧を読み取ります。
この関数は画面に対応していない座標を返します。タブレットの座標読み取り解像度
は最大1280×960ドットとなっています。筆圧の値が127のときは、タブレットペンが
タブレットの座標を読み取れる範囲外にあることを示します。この状態で返した座標
は無効とします。通常タブレットのボタン状態は、タブレットペンの筆圧が一定以上
加わることにより左ボタンが押されたことが検出でき、タブレットペンのサイドスイ
ッチを押すことにより右ボタンが押されたことが検出できます。
タブレットペンの筆圧は、1が最小で126が最大となります。
タブレットペンの筆圧の強弱の設定は、TAB_setPress関数で設定できます。

-----------------------------------------------------------------------------
.TAB_setPress
筆圧の設定
-----------------------------------------------------------------------------

- 定義 -
#include <tablet.h> 
int      TAB_setPress(int press);
int      press;             /*  ボタンの状態              */

- 戻り値 -
 0 :正常終了
-1 :エラー

- 例 -
#include <tablet.h> 
        …
int press = 64; 
int ret;
ret = TAB_setPress(press);

- 内容 -
通常タブレットのボタン状態は、タブレットペンの筆圧が一定以上加わることにより
左ボタンが押されたことが検出できますが、この関数で筆圧を設定できます。
設定値は1〜126までの範囲で設定できます。

-----------------------------------------------------------------------------
.TAB_setPulse
読み取りドット数/画素比の設定
-----------------------------------------------------------------------------

- 定義 -
#include <tablet.h> 
int      TAB_setPulse(short *para);
short    para[4];           /*  パラメータ                    */

- 戻り値 -
 0 :正常終了
-1 :エラー

- 例 -
#include <tablet.h> 
        …
short para[4];
int ret;
para[0] = 640;              /*  画面のドット数Ｘ              */
para[1] = 480;              /*  画面のドット数Ｙ              */
para[2] = 1280;             /*  タブレットのドット数Ｘ        */
para[3] = 960;              /*  タブレットのドット数Ｙ        */
ret = TAB_setPulse(para); 

  ┌───┬──────────────┐
  │  SW  │  画面のドット数Ｘ          │
  ├───┼──────────────┤
  │  SW  │  画面のドット数Ｙ          │
  ├───┼──────────────┤
  │  SW  │  タブレットのドット数Ｘ    │
  ├───┼──────────────┤
  │  SW  │  タブレットのドット数Ｙ    │
  └───┴──────────────┘
     ▲パラメータの形式

- 内容 -
タブレットの読み取りドット数/画素比を設定します。
この関数で、タブレットのドット数/画面のドット数の調整を行います。
タブレットの座標読み取り解像度は最大1280×960ドットとなっています。
画面ドット数を640×480、タブレットドット数を1280×960と設定した場合、タブレッ
トの座標が2ドット移動したとき、1ドット画面のマウスカーソルが移動します。

      │                  │    タブレットのドット数Ｘ
    →┼─────────┼←──────────
    ┌┼─────────┼──┐  ↓
    │├─────────┼──┼─┼─
    ││                  │    │  │
    ││                  │    │  │
    ││                  │    │  │
    │└─────────┴──┼─┼─
    ├─────────────┤  ↑タブレットのドット数Ｙ
    └─────────────┘  │
    
    
        │                  │    画面のドット数Ｘ
    ─→┼─────────┼←──────────
    ┌─┼─────────┼─┐  ↓
    ├─┼─────────┼─┼─┼─
    │  │                  │  │  │
    │  │                  │  │  │
    │  │                  │  │  │
    ├─┴─────────┴─┼─┼─
    └┬┬┬┬┬┬┬┬┬┬┬┬┬┘  ↑画面のドット数Ｙ
      └┴┴┴┴┴┴┴┴┴┴┴┘    │

-----------------------------------------------------------------------------
.TAB_setRdstart
読み取り開始位置の設定
-----------------------------------------------------------------------------

- 定義 -
#include <tablet.h> 
int      TAB_setRdstart(int beginX, int beginY); 
int      beginX;            /*  読み取り開始点Ｘ  (0〜1279)     */
int      beginY;            /*  読み取り開始点Ｙ  (0〜959)      */

- 戻り値 -
 0 :正常終了
-1 :エラー

- 例 -
#include <tablet.h> 
        …
int beginX = 320; 
int beginY = 224; 
int ret;
ret = TAB_setRdstart(beginX,beginY);

- 内容 -
タブレットの座標読み取り開始点を設定します。
この関数で、画面上の(X,Y)=(0,0)の座標とタブレットの座標との調整を行います。
タブレットの座標読み取り解像度は最大1280×960ドットとなっています。

    ┌─────────────┐    ┌─────────────┐
    │┌┬────────┐    │    ├─Ｘ(0,0) ──────┼─┤
    │├Ｘ                │    │    │  │                  │  │
    ││読み取り開始点    │    │    │  │                  │  │
    ││                  │    │    │  │                  │  │
    │└─────────┘    │    ├─┴─────────┴─┤
    ├─────────────┤    └┬┬┬┬┬┬┬┬┬┬┬┬┬┘
    └─────────────┘      └┴┴┴┴┴┴┴┴┴┴┴┘  

2.3 サンプルプログラム

┌────────────────────────────────────┐
│  タブレットライブラリ  サンプルプログラム                              │
│  ■  機能  ■                                                          │
│    ペン描画を行います。                                                │
└────────────────────────────────────┘
/*
    現在表示されているＴｏｗｎｓＯＳの画面に対してペン描画を行います

    compile usage:  run386 hcd386p tabpen
    link usage:     run386 386linkp tabpen -lib hce t_os tbios tablet -tc
*/
#include <stdlib.h>
#include <egb.h>
#include <mos.h>
#include <sidework.h>
#include <tablet.h>

#define  MIN_PRESS   10

char *egb_work;
char *mos_work;

void line();

void main()
{
    int sdw_flag;
    int page[2];
    int org_wpage,pri,dispMode,writePage;
    int min_h,max_h,min_v,max_v;
    int tr,x,y,p,ox,oy;
    int col,oc;

    char pw[258];
    if ( (egb_work = malloc(EgbWorkSize)) == 0 )  /*  EGB作業領域確保  */
        exit(-1);
    if ( (mos_work = malloc(MosWorkSize)) == 0 )  /*  ＭＯＳ作業領域確保  */
        exit(-1);

    sdw_flag = sdk_isAtWork();                    /*  起動環境の取得      */
    if ( sdw_flag )                               /*  私はSIDEWORK？      */
        sdk_start(0);                             /*  SIDEWORK start      */

    EGB_getResolution( &page[0],&page[1] );       /*  仮想画面の取得      */
    org_wpage = EGB_getWritePage( 0,0 );          /*  書き込みページ取得  */

    EGB_getDisplayPage( &pri,&dispMode );         /*  表示ページ取得      */

    dispMode &= 0x03;                             /*  書き込みページ計算  */
    pri      &= 0xff;
    switch( dispMode ) {
        case 0 :
            exit(-1);
        case 1:
        case 2:
            writePage = dispMode - 1;
            break;
        case 3:
            writePage = org-wpage;
        }

    EGB_resolution( egb_work, 0 , page[0] | 0x40 ); /*  仮想画面の設定     */
    EGB_resolution( egb_work, 1 , page[1] | 0x40 ); /*  仮想画面の設定     */
    EGB_writePage( egb-work, writePage );          /*  書き込みページ指定  */
    EGB_pen( egb_work,0 );                         /*  ペンの設定          */
    EGB_penSize( egb_work,4 );                     /*  ペンの太さの設定    */
    EGB_colorIGRB( egb_work,0,0xffffffff );        /*  描画色の設定1       */
    EGB_paintMode( egb_work,2 );                   /*  面塗りモードの設定  */

    MOS_start( mos_work,MosWorkSize );             /*  マウス動作開始      */
    MOS_writePage( writePage );                    /*  書き込みページ指定  */
    if ( sdw_flag ){                               /*  私はSIDEWORK？      */
        MOS_getHorizon( &min_h,&max_h );           /*  水平移動範囲の取得  */
        MOS_getVertical( &min_v,&max_v );          /*  垂直移動範囲の取得  */
        MOS_horizon( min_h,max_h );                /*  水平移動範囲の指定  */
        MOS_vertical( min_v,max_v );               /*  垂直移動範囲の指定  */
        }
    MOS_typeRom( 83,0,0,pw );                      /*  ｼｽﾃﾑｱｲｺﾝ形状の設定  */
    MOS_disp( 1 );                                 /*  マウス表示          */

    oc = -1 ;
    x = y = 0;

    for(;;) {
        ox = x;
        oy = y;
        TAB_rdpos( &tr,&x,&y,&p );                 /*  タブレット状態読取  */
        tr &= 0x03;
        EGB_penSize( egb_work,p/4 );               /*  ペンの太さの設定    */
        if( tr == 3 )                              /*  終了チェック        */
            break;
        switch( tr ) {
            case 1:                                /*  ペン描画処理        */
                if ( p > MIN_PRESS ) {             /*  一定筆圧以上？      */
                    line( x,y,x,y );
                    do{
                        TAB_rdpos( &tr,&x,&y,&p );   /* タブレット状態読取 */
                        EGB_penSize( egb-work,p/4 ); /* ペンの太さの設定   */
                        if( ox != x || oy != y ) { /*  座標移動あり？      */
                            line( ox,oy,x,y );

                            ox = x;
                            oy = y;
                            }
                        } while( tr & 0x01 );       /*  ペン描画終了？     */
                    }
                break;
            case 2:                                 /*  サイドスイッチ処理 */
                EGB_point( egb-work,0,x,y,&col );   /*  ポイント識別       */
                if( col != oc ) {                   /*  前の色と違う？     */
                    EGB_color( egb_work,0,col );    /*  描画色の設定       */
                    MOS_color( 0,col );             /*  表示色の設定       */
                    oc = col;
                    }
                break;
            default:
                break;
            }
        }

    EGB_writePage( egb_work,org_wpage );          /*  書き込みページ復元  */
    MOS_disp( 0 );                                /*  マウス消去          */
    MOS_end();                                    /*  マウス動作終了      */
    if ( sdw_flag )                               /*  私はSIDEWORK？      */
        sdk_terminate( egb_work,mos-work,NULL );  /*  SIDEWORK terminate  */
    free( mos_work );                             /*  メモリ開放          */
    free( egb_work );
}

void line( int sx,int sy,int ex,int ey )
{
    char para[10];
    WORD( para+0 ) = 2;
    WORD( para+2 ) = sx;
    WORD( para+4 ) = sy;
    WORD( para+6 ) = ex;
    WORD( para+8 ) = ey;
    MOS_disp( 0 );                                  /*  マウス消去        */
    EGB_connect( egb-work,para );                   /*  連続線分          */
    MOS_disp( 1 );                                  /*  マウス表示        */
}

*****************************************************************************
第17章  ビデオ出力ライブラリ
*****************************************************************************

1 ビデオ出力ライブラリについて

1.1 概要

  VideoTownsBIOS(以降VTBIOSと略)は、Townsシステムソフトウェア V2.1のEGBを使用
して設定した中解像度モードの画面をビデオ出力するドライバソフトウェアです。
  このドライバを組み込むことにより、ビデオ出力できない画面モードのビデオ出力
が可能となり、プロジェクタなどの大画面モニタに出力できます。ただしビデオ出力
の画面にした際に、FM TOWNSの解像度がビデオ出力時のモニタの垂直方向表示ドット
数より大きくなり、画面の上下が見えなくなることがあります。
  これにより、メニューバーが隠れてしまうのを解消するため、ドライバ常駐時に垂
直表示位置を調整できる｢垂直表示位置調整機能｣を内蔵しています。また、ビデオ出
力ライブラリを利用することにより、アプリケーションからのビデオ出力のON/OFFが
可能となります。通常、VTBIOSを常駐した場合、全画面モードをビデオ出力モードに
切り換えますが、切り換えを行わない常駐も可能です。このモードで常駐させ、アプ
リケーションの必要なときだけビデオ出力モードに切り換えることができます。

1.2 注意事項

  VTBIOSでは可能な限りEGBの表示機能を再現していますが、ハードウェア的な制約か
ら以下のような制限があります。

 1)ハードウェアを直接操作しているソフトはビデオ出力されません。
   EGBを使用して画面を設定しているアプリケーションのみビデオ出力されます。

 2)画面の拡大で水平方向の拡大率は8倍までは動作しますが、それ以上は動作できま
   せん(8倍以上拡大されません)。
   そのため8倍以上の倍率を設定したあとにEGB_getDisplayStart関数で画面拡大率を
   取得した場合に表示状態と取得情報とが食い違いますが、動作の非互換を防ぐため
   に8倍以上の設定値の際にエラーを返す処理は行っていません。

 3)画面の拡大で垂直方向に奇数倍での拡大を行うと画面が乱れます。

 4)画面モードが640×819モードのビデオ出力は、FM TOWNSモデル1/モデル2のみハー
   ドウェアがVTBIOSの設定値に追従できないため、表示が乱れます。

 5)｢/T｣オプションを引数付きで設定する場合、必ず偶数の値を設定(例/T0040)してく
   ださい。奇数の値を設定した場合、画面が乱れます。

 6)高解像度モードの画面はビデオ出力されません。
   画面モード1〜18までの中解像度モード時のみビデオ出力されます。

2 ビデオ出力ライブラリ

2.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│VTBIOS_getStatus          │ビデオ出力起動状態の取得                  │
├─────────────┼─────────────────────┤
│VTBIOS_videoON            │ビデオ出力ON                              │
├─────────────┼─────────────────────┤
│VTBIOS_videoOFF           │ビデオ出力OFF                             │
└─────────────┴─────────────────────┘

2.2 各関数の解説

-----------------------------------------------------------------------------
.VTBIOS_getStatus 
ビデオ出力起動状態の取得
-----------------------------------------------------------------------------

- 定義 -
#include <vtbios.h> 
int     VTBIOS_getStatus(void);

- 戻り値 -
 0 :通常出力モード
 1 :ビデオ出力モード
-1 :VTBIOSが組み込まれていない

- 例 -
#include <vtbios.h> 
        …
if (VTBIOS_getStatus() == -1)
    printf("VTBIOSが組み込まれていません\n"); 

- 内容 -
現在のVTBIOSの起動状態を取得します。

-----------------------------------------------------------------------------
.VTBIOS_videoOFF
ビデオ出力OFF
-----------------------------------------------------------------------------

- 定義 -
#include <vtbios.h> 
int      VTBIOS_videoOFF(void); 

- 戻り値 -
 0 :正常終了
-1 :VTBIOSが組み込まれていない

- 例 -
#include <vtbios.h> 
        …
VTBIOS_videoOFF(); 
set_disp();               /*  画面の再設定  */

- 内容 -
VTBIOSの動作モードを通常出力モードにします。

-----------------------------------------------------------------------------
.VTBIOS_videoON 
ビデオ出力ON
-----------------------------------------------------------------------------

- 定義 -
#include <vtbios.h> 
int      VTBIOS_videoON(void);

- 戻り値 -
 0 :正常終了
-1 :VTBIOSが組み込まれていない

- 例 -
#include <vtbios.h> 
        …
VTBIOS_videoON();
set_disp();               /*  画面の再設定  */

- 内容 -
VTBIOSの動作モードをビデオ出力モードにします。


2.3 サンプルプログラム

┌────────────────────────────────────┐
│  ビデオ出力ライブラリ  サンプルプログラム                              │
│  ■  機能  ■                                                          │
│    画面をビデオ出力モードに切り換えます。                              │
└────────────────────────────────────┘
/*
    現在表示されているＴｏｗｎｓＯＳの画面をビデオ出力モードに切り換えます

    compile usage:  run386 hcd386p vtbsmp
    link usage:   run386 386linkp vtbsmp -lib hce tbios vtbios -twocase -pack
*/

#include <stdlib.h>
#include <egb.h>
#include <mos.h>
#include <vtbios.h>

char egb_work[EgbWorkSize];
char mos_work[MosWorkSize];
char pal_0[4+8*256];
char pal_1[4+8*16];

int dsx0[2],dsy0[2],dsx1[2],dsy1[2],dsx2[2],dsy2[2],dsx3[2],dsy3[2];

void read_palette();
void set_disp();

void main()
{
    int page0,page1,wpage,pri,disp;
    int tr,x,y;
    int i;

    if ( VTBIOS_getStatus() == -1 )        /*  ビデオ出力起動状態の取得   */
    exit( -1 );                            /*  ＶＴＢIＯＳが非常駐？      */

    wpage = EGB_getWritePage( 0,0 );
    for ( i=0 ; i<2 ; i++ ) {
        EGB_getDisplayStart( i,0,&dsx0[i],&dsy0[i] );
        EGB_getDisplayStart( i,1,&dsx1[i],&dsy1[i] );
        EGB_getDisplayStart( i,2,&dsx2[i],&dsy2[i] );
        EGB_getDisplayStart( i,3,&dsx3[i],&dsy3[i] );
        }
    EGB_getResolution( &page0,&page1 );
    EGB_resolution( egb_work,0,0x40+page0 );

    EGB_resolution( egb_work,1,0x40+page1 );
    EGB_writePage( egb_work,0x40+wpage );
    EGB_getDisplayPage( &pri,&disp );

    MOS_start( mos_work,MosWorkSize );

    /*  メインループ  */
    do {
        MOS_rdpos( &tr,&x,&y );
        switch( tr & 0x03 ){
            case 0x01:
                /*  ビデオ出力ON  */
                read_palette( page0,page1 );
                VTBIOS_videoON();
                set_disp( page0,page1,wpage,pri,disp );
                break;
            case 0x02:
                /*  ビデオ出力OFF  */
                read_palette( page0,page1 );
                VTBIOS_videoOFF();
                set_disp( page0,page1,wpage,pri,disp );
                break;
            default:
                break;
            }
        } while( tr != 0x03 );

    MOS_end();
}

void read_palette( int page0,int page1 )
{
    if ( (page0 <= 4) || ((page0 >= 12) && (page0 <= 14)) )
        EGB_getPalette( 0,pal_0 );
    if (page1 <= 4)
        EGB_getPalette( 1,pal_1 );
    EGB_displayPage( egb_work,0,0 );
}

void set_disp( int page0,int page1,int wpage,int pri,int disp )
{
    int i;

    EGB_resolution( egb_work,0,page0 );
    EGB_resolution( egb_work,1,page1 );
    for ( i=0 ; i<2 ; i++ ) {
        EGB_writePage( egb_work,i );
        EGB_displayStart( egb_work,3,0,0 );
        EGB_displayStart( egb_work,2,1,1 );
        EGB_displayStart( egb_work,2,dsx2[i],dsy2[i] );
        EGB_displayStart( egb_work,0,dsx0[i],dsy0[i] );
        EGB_displayStart( egb_work,1,dsx1[i],dsy1[i] );
        EGB_displayStart( egb_work,3,dsx3[i],dsy3[i] );
        }

    if ( (page0 <= 4) || ((page0 >= 12) && (page0 <= 14)) ) {
        EGB_writePage( egb_work,0 );
        EGB_palette( egb_work,0,pal_0 );
        }
    if ( page1 <= 4 ) {
        EGB_writePage( egb_work,1 );
        EGB_palette( egb_work,0,pal_1 );
        }
    EGB_writePage( egb_work,wpage );
    EGB_displayPage( egb_work,pri,disp );
}

*****************************************************************************
第18章  アイコンライブラリ
*****************************************************************************

1 アイコンライブラリについて

1.1 概要

  本ライブラリは、TOWNS.ICNや任意のファイルに登録されているアイコンパターンを
使用可能にするライブラリです。GUIライブラリと併用した場合、GUIライブラリのア
イコン部品でもアイコンパターンを使用することができます。

1.2 注意事項

  本ライブラリは、GUIライブラリを使用するプログラムと使用しないプログラム両方
に対応しています。GUIライブラリを使用しないプログラムで本ライブラリを使用する
場合は、コンパイル時に以下のスイッチを付加してください。
┌────────────────────────────────────┐
│-define NON_GUI_APL                                                     │
└────────────────────────────────────┘

2 アイコンライブラリ

2.1 関数一覧

┌─────────────┬─────────────────────┐
│        関  数  名        │              機          能              │
├─────────────┼─────────────────────┤
│ICON_SetIcnName           │アイコンファイル名の設定                  │
├─────────────┼─────────────────────┤
│ICON_SetMinCode           │最小アイコン番号の設定                    │
├─────────────┼─────────────────────┤
│ICON_open                 │アイコンライブラリの初期化                │
├─────────────┼─────────────────────┤
│ICON_Func                 │アイコンパターンの取得(非GUI)             │
├─────────────┼─────────────────────┤
│ICON_GUIFunc              │アイコンパターンの取得(GUI併用)           │
├─────────────┼─────────────────────┤
│ICON_close                │アイコンライブラリの終了                  │
├─────────────┼─────────────────────┤
│ICON_CheckFirstIcnID      │最初のアイコン番号の取得                  │
├─────────────┼─────────────────────┤
│ICON_CheckNextIcnID       │次のアイコン番号の取得                    │
├─────────────┼─────────────────────┤
│ICON_GetIcnEntry          │アイコン登録数の取得                      │
└─────────────┴─────────────────────┘

2.2 各関数の解説

-----------------------------------------------------------------------------
.ICON_CheckFirstIcnID 
最初のアイコン番号の取得
-----------------------------------------------------------------------------

- 定義 -
#include <icon2.h>
int   ICON_CheckFirstIcnID(void);

- 戻り値 -
最初のアイコン番号

- 内容 -
アイコンファイルに登録されている、一番最初のアイコン番号を取得します。

-----------------------------------------------------------------------------
.ICON_CheckNextIcnID
次のアイコン番号の取得
-----------------------------------------------------------------------------

- 定義 -
#include <icon2.h>
int   ICON_CheckNextIcnID(int shape);
int   shape;  /*  前に検索したアイコン番号 */ 

- 戻り値 -
次のアイコン番号

- 内容 -
次に登録されている、アイコン番号を取得します。shapeには、ICON_CheckFirstIcnID
関数または、ICON_CheckNextIcnID関数で取得した直前のアイコン番号を指定してくだ
さい。

-----------------------------------------------------------------------------
.ICON_close 
アイコンライブラリの終了
-----------------------------------------------------------------------------

- 定義 -
#include <icon2.h>
int   ICON_close(void);

- 戻り値 -
0 :正常終了

- 内容 -
アイコン表示機能を終了させます。

-----------------------------------------------------------------------------
.ICON_Func
アイコンパターンの取得(非GUI)
-----------------------------------------------------------------------------

- 定義 -
#include <icon2.h>
int ICON_Func(ICONDATA *IconData, int shape);
ICONDATA *IconData;   /*  取得したアイコンパターンの情報を
                                          格納する構造体へのポインタ */ 
int shape;            /*  アイコン番号                               */ 

- 戻り値 -
0     :正常終了
0以外 :異常終了

- 内容 -
アイコン表示機能を終了させます。
ライブラリを使用しないプログラム用のアイコンパターンの取得関数です。
取得データは、ICONDATA構造体に以下の形式でアイコン情報が格納されます。

  struct _ICONDATA
  {
    unsigned short  atr ;   /*  リザーブ(参照不可)                      */
    unsigned short  pixel ; /*  取得アイコンの種類                      */
                            /*  COLOR_MON   :  単色パターン             */
                            /*  COLOR_16    :  16色パターン             */
    unsigned char   *data ; /*  アイコンパターンが格納されているポインタ*/
                            /*                  (オフセット)            */
    short   ds ;            /*  アイコンパターンが格納されているポインタ*/
                            /*                  (セグメント)            */
    short   lupx ;          /*  アイコンパターンの矩形位置(左上ｘ座標)  */
    short   lupy ;          /*  アイコンパターンの矩形位置(左上ｙ座標)  */
    short   rdwx ;          /*  アイコンパターンの矩形位置(右下ｘ座標)  */
    short   rdwy ;          /*  アイコンパターンの矩形位置(右下ｙ座標)  */
  }; 

- 注意 -
パターンの取得を連続して行った場合、直前に取得したパターンデータはメモリ上か
ら消滅します。パターンデータをメモリ上に保存しておきたい場合は、一度別のメモ
リ領域に複写してから次のパターン取得を行ってください。
GUIライブラリを使用するプログラムは後述のICON_GUIFunc関数を使用してください。

-----------------------------------------------------------------------------
.ICON_GetIcnEntry 
アイコン登録数の取得
-----------------------------------------------------------------------------

- 定義 -
#include <icon2.h>
int   ICON_GetIcnEntry(void);

- 戻り値 -
アイコン登録数

- 内容 -
アイコンファイルに登録されているアイコンの総数を取得します。

-----------------------------------------------------------------------------
.ICON_GUIFunc 
アイコンパターンの取得(GUI併用)
-----------------------------------------------------------------------------

- 定義 -
#include <icon2.h>
int   ICON_GUIFunc(ICONDATA *IconData, int shape); 
ICONDATA *IconData;   /*  取得したアイコンパターンの情報を
                                          格納する構造体へのポインタ */ 
int shape;            /*  アイコン番号                               */ 

- 戻り値 -
0     :正常終了
0以外 :異常終了

- 内容 -
GUIライブラリに登録する、アイコンパターンの取得関数です。
MMI_SetGetIcnDataFunc関数を使用して本関数を登録することで、指定したファイル内
のアイコンを使用することができるようになります。

- 注意 -
本関数を使用する場合、拡張ライブラリIIが必要です(GUIライブイラリを使用しない
プログラムの場合は、前述のICON_Func関数を使用してください)。
本関数の登録はICON_open関数およびMMI_open関数実行後に行ってください。

-----------------------------------------------------------------------------
.ICON_open
アイコンライブラリの初期化
-----------------------------------------------------------------------------

- 定義 -
#include <icon2.h>
int   ICON_open(char *buf, size_t bufsize, int flag);
char *buf;         /* アイコンライブラリで使用する作業領域のポインタ */ 
size_t bufsize;    /* アイコンライブラリで使用する作業領域のサイズ   */ 
int flag;          /* アイコンパターン読込み時のカラーコード0の指定
                        0: 透明色(カラーコード0)として扱いません
                        1: 黒(カラーコード8)として扱いません         */ 

- 戻り値 -
0     :正常終了
0以外 :異常終了

- 内容 -
アイコンのパターンを扱うことができるようになります。

- 注意 -
作業領域はアイコンライブラリを終了するまでは絶対解放しないでください。
作業領域は、サイズを大きく指定すれば処理が高速化されますが、常にその領域が
確保されるため、フリーメモリが減少します。
また、作業領域サイズは、5KB未満は指定できません。

-----------------------------------------------------------------------------
.ICON_SetIcnName
アイコンファイル名の設定
-----------------------------------------------------------------------------

- 定義 -
#include <icon2.h>
int     ICON_SetIcnName(char *path);
char    *path;              /*  アイコンのパス名               */

- 戻り値 -
0 :正常終了

- 内容 -
読み込みをおこなうアイコンのパス名を指定します。
この関数で設定をおこなわなかった場合は、環境変更ICNで指定されたパスの
TOWNS.ICNファイルが自動的に設定されます。

-----------------------------------------------------------------------------
.ICON_SetMinCode
小アイコン番号の設定
-----------------------------------------------------------------------------

- 定義 -
#include <icon2.h>
int     ICON_GetIcnEntry(void);

- 戻り値 -
アイコン登録数

- 内容 -
本ライブラリで読み込むアイコン番号の最小値を指定します。
この関数で設定をおこなわなかった場合は、1024番が自動的に設定されます。


2.3 サンプルプログラム

┌────────────────────────────────────┐
│  アイコンライブラリサンプルプログラム                                  │
│  ■  機能  ■                                                          │
│    システムのTOWNS.ICN からアイコンパターンを読み込み、グラフィック    │
│    画面に表示します。                                                  │
└────────────────────────────────────┘
#include <stdio.h>
#include <stdlib.h>
#include <egb.h>
#include <mos.h>
#include <icon2.h>

#define ICON_BUFFSIZE 5120

#define FALSE (0)
#define TRUE  (!FALSE)

ICONDATA IconData;

void main()
{
    char  *egbwork;
    char  *moswork;
    char  para[64];
    char  *ptr;
    int   count;
    int   shape;
    int   x=0;
    int   y=0;
    int   i;
    int   button,mosx,mosy;

    /** EGBの初期化 **/
    egbwork = (char*)malloc(1536);
    EGB_init(egbwork,1536);
    /** マウスの初期化 **/
    moswork = (char*)malloc(4096);
    MOS_start(moswork,4096);

    /** アイコンライブラリの初期化 */
    ptr = (char*)malloc(ICON_BUFFSIZE);
    ICON_open(ptr,ICON_BUFFSIZE,TRUE);

    /** 登録数の取得 **/
    count = ICON_GetIcnEntry();

    /** 最初のアイコンコードの取得 **/

    shape = ICON_CheckFirstIcnID();
    for( i=0; i<count; i++ ){
        /** アイコンパターンの読み込み **/
        ICON_Func(&IconData,shape);

        /** グラフィック画面に表示します **/
        DWORD(para)=(unsigned int)IconData.data;
        WORD(para+4)=IconData.ds;
        WORD(para+6)=x;
        WORD(para+8)=y;
        WORD(para+10)=x+IconData.rdwx;
        WORD(para+12)=y+IconData.rdwy;
        if(IconData.pixel==COLOR_MON)
            EGB_putBlockColor(egbwork,0,para);
        else if(IconData.pixel==COLOR_16)
            EGB_putBlock(egbwork,0,para);

        /** 次の表示座標を計算 **/
        x+=32;
        if(x>=640)
        {  x=0;
            y+=32;
            if(y>=480)
                y=0;
        }

        /** 次のアイコンコードの取得 **/
        shape = ICON_CheckNextIcnID(shape);
    }
    do{
        MOS_rdpos(&button,&mosx,&mosy);
    }while(button==0);

    /** アイコンライブラリの終了 **/
    ICON_close();

    /** マウスの終了 **/
    MOS_end();
}

*****************************************************************************
第19章  FMC関数ダイナミックリンクライブラリ
*****************************************************************************

1 FMC関数ダイナミックリンクライブラリについて

1.1 概要

  本ライブラリは、forRBIOS(Native modeからReal mode BIOSを使用可能にするイン
タフェース)を使用して動作するライブラリです。また、このライブラリは、Cライブ
ラリ V2.1 リファレンスのFMC関数ライブラリの機能をダイナミックリンクライブラリ
として提供しています。ダイナミックリンクライブラリをアプリケーションで利用す
る方法については｢第9章  ダイナミックリンクサポートライブラリ｣を参照してくださ
い。本ライブラリは、以下の機能をサポートしています。

 (1)forRBIOS インタフェース
    アプリケーション作成時に本ライブラリ以外でforRBIOS本体に処理を要求したい
    場合に、本ライブラリを使用することによりforRBIOS本体に処理等を要求するフ
    ァンクションを発行することができます。

 (2)キーボードインタフェース
    キーボードには、その配列により、JIS配列キーボードと親指シフトキーボードの
    2種類があり、キーボードインタフェースは、これらキーボードからのデータの読
    み込みをサポートしています。

 (3)コンソール(文字ディスプレイ)インタフェース
    コンソール(文字ディスプレイ)インタフェースは、文字ディスプレイに対する英
    数カナ、グラフィック文字や漢字を、アトリビュート(ブリンク、リバース、カラ
    ー等)とともに表示したり、読み取ったりする機能をサポートします。

 (4)補助記憶装置インタフェース
    補助記憶装置インタフェースは、補助記憶装置に対して、設定(モード、シーク等
    )、読み込み、書き込みを行う機能をサポートします。

 (5)プリンタインタフェース
    プリンタインタフェースは、標準実装のプリンタインタフェースの機能をサポー
    トしています。

 (6)時計サポートインタフェース
   ･カレンダ時計インタフェース
    システムのカレンダ時計へ日付･時刻の設定と、その日付･時刻の読み取りを行い
    ます。
   ･タイマ管理インタフェース
    タイマ管理インタフェースは、指定された周期で指定アドレスへ割り込みを上げ
    るための機能をサポートしています。

   ･時計管理インタフェース
    時計管理インタフェースは、指定した時刻から、指定した周期で指定アドレスへ
    割り込みを上げるための機能をサポートしています。

 (7)RS-232C インタフェース
    RS-232Cは、本来モデムとデータ端末装置との接続に関する規格として決められた
    ものですが、現在はモデムに限らず近距離用(1〜数m程度)の低速度インタフェー
    スとしての機能をサポートしています。

 (8)ブサーインタフェース
    ブザーインタフェースは、本体に内蔵されているブザーのON/OFFの制御を行う機
    能をサポートしています。

1.2 使用上の注意

  本ライブラリは、forRBIOS(Native modeからReal mode BIOSを使用可能にするイン
タフェース)を使用して動作するライブラリです。forRBIOSが常駐していない場合は、
完全な動作をしません。forRBIOSが常駐していない場合は、次のバッチファイルを実
行してforRBIOSを常駐させてください。

  \HCOPY\COCO  *1 
  \HCOPY\COCO_MEM  *1 
  \RUN386 \HCOPY\ADDDRV \HCOPY\FORRBIOS.NSD  *1 

  *1)本バッチファイルでは、TOWNS-OS V2.1 systemパスを指定しています。
     また、forRBIOSはTOWNS OS V2.1よりサポートされています。

1.3 リンク時の注意点

  FMC関数ダイナミックリンクライブラリを使用するアプリケーションは、本関数の
DLL用リソースライブラリ(FMCFRB.SDL)をリンクする必要があります。
  リンク時のスイッチに以下のスイッチを追加してください。

    -lib FMCFRB.SDL 

  さらに、これまでダイナミックリンクに対応していないFMC関数ライブラリを使用し
ていた場合には、リンク時のスイッチから下記のスイッチを削除してください。

    -lib FMCFRB 

2 FMC関数ダイナミックリンクライブラリ

  FMC関数の構造体、関数一覧、サンプルプログラムについては、High C(R)Compiler
V1.7添付の｢Cライブラリ V2.1 リファレンス｣を参照してください。
  また、ダイナミックリンク機能に対応した本ライブラリを使用するためには、ダイ
ナミックリンクサポートライブラリを使用し、ダイナミックリンク機能の初期化等の
処理を行う必要があります。詳しくは、｢第9章  ダイナミックリンクサポートライブ
ラリ 2.ダイナミックリンクを利用した開発｣をご覧ください。

*****************************************************************************
第20章  CD-ROM関数ダイナミックリンクライブラリ
*****************************************************************************

1 CD-ROM関数ダイナッミックリンクライブラリについて

1.1 概要

  CD-ROM関数ダイナミックリンクライブラリは、forRBIOS(Native modeからReal mode
BIOSを使用可能にするインタフェース)を使用して、CD-ROMに対して設定(モード)、読
み込み、演奏等を行う機能をサポートするライブラリです。また、このライブラリは
、Cライブラリ V2.1 リファレンスのCD-ROM関数ライブラリの機能をダイナミックリン
クライブラリとして提供します。ダイナミックリンクライブラリをアプリケーション
で利用する方法については｢第9章  ダイナミックリンクサポートライブラリ｣を参照し
てください。

1.2 使用上の注意

  本ダイナミックリンクライブラリは、forRBIOS(Native modeからReal mode BIOSを
使用可能にするインタフェース)を使用して動作するライブラリです。forRBIOSが常駐
していない場合は、完全な動作をしません。forRBIOSが常駐していない場合は、次の
バッチファイルを実行してforRBIOSを常駐させてください。

  \HCOPY\COCO  *1 
  \HCOPY\COCO_MEM  *1 
  \RUN386 \HCOPY\ADDDRV \HCOPY\FORRBIOS.NSD  *1 

  *1)本バッチファイルでは、TOWNS-OS V2.1 systemパスを指定しています。
     また、forRBIOSはTOWNS OS V2.1よりサポートされています。

1.3 リンク時の注意事項

  CD-ROM関数ダイナミックライブラリを使用するアプリケーションは、本関数のDLL用
リソースライブラリ(CDRFRB.SDL)をリンクする必要があります。
  リンク時のスイッチに以下のスイッチを追加してください  。

    -lib CDRFRB.SDL 

  さらに、これまでダイナミックリンクに対応していないCD-ROM関数ライブラリを使
用していた場合には、リンク時のスイッチから下記のスイッチを削除してください。

    -lib CDRFRB 

2 CD-ROM関数ダイナミックリンクライブラリ

  CD-ROM関数ダイナミックリンクライブラリの構造体、関数一覧、サンプルプログラ
ムについては、High C(R)Compiler V1.7添付の｢Cライブラリ V2.1 リファレンス｣を参
照してください。
  また、ダイナミックリンク機能に対応した本ライブラリを使用するためには、ダイ
ナミックリンクサポートライブラリを使用し、ダイナミックリンク機能の初期化等の
処理を行う必要があります。詳しくは、｢第9章  ダイナミックリンクサポートライブ
ラリ 2.ダイナミックリンクを利用した開発｣をご覧ください。

*****************************************************************************
付録  Towns標準TIFFライブラリ
*****************************************************************************

1 標準TIFFの方針

  FM TOWNSでは、画像データの標準形式として、Aldus社が提唱しているTIFF形式を
採用しています。FM TOWNS内でのアプリケーション間の画像データ交換は、基本的に
このTIFF形式を用いることとします。

  TIFF Revision 5の規格に沿ってTowns標準TIFFを制定し、FM TOWNSのアプリケーシ
ョンは、その形式でTIFFデータを作成します。TIFFを読むFM TOWNSのアプリケーショ
ンはTIFFの仕様にのっとりつつ、最低限Towns標準TIFFを読めるようにします。Towns
標準以外のTIFFをサポートするかどうかは、各アプリケーションに任せます。
  ただし、ここで定めた一部の形式については、FM TOWNS固有の解釈のもとに使用し
ているものがあります。具体的には、16色と32K色のデータですが、これはFM TOWNS内
での運用にとどめ、他機種との交換形式としては用いないでください。

2 Towns標準TIFFフォーマット

2.1 ヘッダ

  ファイルの先頭の8バイトは、常に以下に示すようになっています。
    バイト 0-1      フォーマット    "II"                    Hex:4949
    バイト 2-3      バージョン      42                      Hex:2A00
    バイト 4-7      オフセット      IFDの位置
                                    (ファイル先頭からのバイトオフセット)

  フォーマットの項は、以下のワード/ロングワードデータのバイトオーダを指定する
もので、IIはいわゆるインテル形式(低位バイトが先にくる)を表します。一方でMMが
あり、これはモトローラ形式ですが、Towns標準TIFFでは作成しません。アプリケーシ
ョンが、この形式を読めるよう努力することは自由です。(FM TOWNS拡張ライブラリI
のTIFFライブラリでは、モトローラ形式の読み込みもサポートしています。)

2.2 IFD(イメージファイルディレクトリ)

  ここには、画像データの様々な属性を定義したタグがあり、TIFFのローダは始めに
この部分を読んで、画像の情報を得ることになります。
IFDの構造は次のとおりです。

   オフセット   長さ      内容
       00         2      エントリ数(entry)
       02        12      最初のフィールドエントリ
       14        12      2番目のフィールドエントリ
            ･
            ･
    12*entry+2    4       0 ( IFDの終わり )

2.3 IFDのフィールドエントリの詳細

  各エントリの12バイトの内容は次のようになっています。

  オフセット   長さ      内容
     00         2     フィールドのタグ
     02         2     フィールドのタイプ
     04         4     フィールドの長さ (単位はタイプによる)
     08         4     値または値へのオフセット

  ●タグ
    IFD内のエントリは、タグの昇順に並んでいる必要があります。

  ●タイプ
    1 : BYTE      8ビット符号なし整数
    2 : ASCII     ASCII文字列 NULLターミネート
    3 : SHORT     2バイト符号なし整数
    4 : LONG      4バイト符号なし整数
    5 : RATIONAL  8バイト分数
                  最初のLONGデータが分子、後が分母

  ●長さ(カウント)
    長さは、タイプを単位とする数で表します。LONGの長さ2は8バイトです。
    ASCIIタイプの場合、最後のNULLキャラクタを含む文字数になります。長さが1よ
    り大きいタグデータは、長さの個数分のデータが連続して格納されます。

  ●値またはオフセット
    値の大きさ(1つのサイズ*長さ)が4バイト以内の場合、この部分に直接値がはいり
    ます。4バイトに満たない場合は、左詰め(低位のバイトから充填)で格納します。
    値が4バイトを越える場合は、値が格納されている部分へのファイル先頭からのオ
    フセット(ロングワード)になります。

2.4 タグ

  Towns標準TIFFでは、以下のタグを使うこととします。これは標準要件であり、これ
以上タグを追加したり、拡張することはできますが、すべてのアプリケーションでサ
ポートされる保証はありません。

──────────────────────────────────────
tag  name               type   size    value 
──────────────────────────────────────
 FE  New Subfile Type   Long     1    0 (固定) 
100  Image Width        Short    1    横ドット数
101  Image Length       Short    1    縦ドット数
102  Bits Per Sample    Short   1/3   1/4/8/16/8,8,8  ビット/ピクセル
103  Compression        Short    1    1:非圧縮、5:LZW圧縮
106  Photo.Interp.      Short    1    0:2値、2:フルカラー､1:カラー､3:パレット
10A  Fill Order         Short    1    2:16色モード、1:else
111  Strip Offset       Long     1    画像データへのオフセット
115  Samples Per Pixel  Short    1    3:フルカラー、1: else 
116  Rows Per Strip     Long     1    = Image Length
117  Strips ByteCount   Long     1    画像データのバイト数
119  Max Sample Value   Short   1/3   1/15/255/32767/255､255､255
11A  X Resolution       Rat.     1    アプリケーション固有
11B  Y Resolution       Rat.     1    アプリケーション固有
11C  Planer Config.     Short    1    1 (固定)
──────────────────────────────────────
140  Color Map          Short  48/768  パレット(CLUT)データ
──────────────────────────────────────

  ●Resolutionタグ
    Resolutionのタグは画像の解像度を表すもので、単位はdpi(dot per inch)です。
    この解釈はアプリケーションにまかせるものとします。標準的なFM TOWNSの画像
    の場合は、以下の値を使用します。これは31.4KHzのハイスキャンモードで、画像
    を14インチモニタに表示した場合に相当します。
      高解像度(640×460dotなど)    :  75   (75 / 1)
      低解像度(320×240dotなど)    :  37.5 (75 / 2)

  ●Color Mapタグ
    このタグはオプションです。このタグが存在する場合、画像データは、TIFFファ
    イルに含まれるCLUT情報にハードウェアパレットが設定されているものと解釈さ
    れます。16色/256色データでは、このタグは必須です。

2.5 CLUTフォーマット

  一般にパレットとかCLUTと呼ぶカラーテーブル情報を、TIFFではカラーマップと呼
びます。その内容は、R(赤)の第0エントリから順に最大エントリまで並び、次にG(緑)
のエントリが同じ順に続きます。そして最後にB(青)のエントリが並びます。

  各エントリは16ビットで、0が最小、0xFFFFが最大となります。FM TOWNSのハードウ
ェアでは、R､G､Bまた4ビットまたは8ビットなので、これを16ビットに拡張して格納し
ます。拡張は次のようにして行います。

  各エントリの有効ビットを、16ビットになるまでくりかえし充填します。
  たとえば、有効8ビットの0x3Aを16ビットに拡張すると、0x3A3Aとなります。

  またカラーマップを読む場合は、各エントリの上位ビット側から、画面モードに応
じた有効ビット数を抽出して使用してください。

- 例 -
16色の場合

  ＣＬＵＴ
         Ｒ(赤)         Ｇ(緑)         Ｂ(青)
    0 1 2 ***** 15 0 1 2 ***** 15 0 1 2 ***** 15

  1エントリ
    ハードCLUT          TIFFのカラーマップ
    b3 b2 b1 b0  →  b3 b2 b1 b0 b3 b2 b1 b0 b3 b2 b1 b0 b3 b2 b1 b0

2.6 画像データ本体

  各モードでのデータ形式は、基本的にFM TOWNSのVRAMの内容に従った"パックドピク
セル"方式です。

  ●16色モード
    1ピクセル4ビットで、横に並ぶ2ピクセルが1バイトにパッキングされます。この
    とき、左側のピクセルが低位ニブル(4bit)になります。この仕様は、TIFFの推奨
    である｢上位ビットから充填される(Fill Order=1)｣から外れることになりますが
    、FM TOWNSではこの形式で扱うこととします。
    1ラインのデータはバイト単位で、ImageWidthが奇数の場合は、ラインの最後の上
    位ニブルはパディングデータとなります。

  ●256、32K色モード
    それぞれピクセルあたり1または2バイトで、左上から右下へのデータが連続して
    います。32K色モードでのbit15(スーパーインポーズビット)は保存して、すなわ
    ちVRAMの内容そのままでファイルにストア、またはファイルへセーブできます。
    ただし、アプリケーションでスーパーインポーズビットが立っていては困る場合
    は、読み込みの際にマスクしてVRAMに書いてください。スーパーインポーズビッ
    トの解釈と使いかたは、アプリケーションにまかせるものとします。

  ●フルカラー
    ピクセルあたり3バイトのデータで、左上から右下へ連続して格納されています。
    1ピクセルのデータは、R､G､Bそれぞれ1バイトがこの順序で格納されます。

3 タグの組み合わせ

  今後、ソフトが本形式をサポートする際の誤解や混乱を少なくするため、作成する
タグの値については限定すべきと考えます。TIFF形式では、選択可能な値を持つタグ
が複数存在し、その組み合わせが多岐に渡る可能性があります。

[値の選択が可能なタグ]
  ･ Bits Per Sample             1 / 4 / 8 / 16 / 8､8､8
  ･ Compression                 1 / 5
  ･ Photometric Interpretation  0 / 1 / 2 / 3 
  ･ Samples per Pixel           1 / 3
  ･ Fill Order                  1 / 2 
  ･ Max Sample Value            1 / 15/ 255 / 32767 / 255､255､255

  そこで、選択が可能なこれらのタグの値について以下のように限定します。
  ただしアプリケーションで、たとえばSoftwareのような情報タグを新規に追加する
ことは自由です。

  ●二値イメージ
    タグの数                     15 
    BitsPerSample                 1 
    Compression                   1(非圧縮) または 5(LZW圧縮)
    Photometric Interpretation    0 (black on white)
    Samples per Pixel             1 
    Fill Order                    1 
    Max Sample Value              1 
  
  ●16色イメージ
    タグの数                     16 
    BitsPerSample                 4 
    Compression                   1(非圧縮) または 5(LZW圧縮)
    Photometric Interpretation    3 (パレットイメージ)
    Samples per Pixel             1 
    Fill Order                    2 
    Max Sample Value              15
    Color Map                 short x 48のCLUTデータ
  
  ●256色イメージ
    タグの数                     16 
    Bits Per Sample               8 
    Compression                   1(非圧縮) または 5(LZW圧縮)
    Photometric Interpretation    3 (パレットイメージ)
    Samples per Pixel             1 
    Fill Order                    1 
    Max Sample Value            255 
    Color Map                  short x 768のCLUTデータ
  
  ●32768色イメージ(パレット未使用)
    タグの数                      15
    Bits Per Sample               16
    Compression                    1(非圧縮) または 5(LZW圧縮)
    Photometric Interpretation     1
    Samples per Pixel              1
    Fill Order                     1
    Max Sample Value           32767
  
  ●フルカラーイメージ
    タグの数                      15
    Bits Per Sample                8､8､8
    Compression                    1(非圧縮) または 5(LZW圧縮)
    Photometric Interpretation     2(RGBイメージ)
    Samples per Pixel              3
    Fill Order                     1
    Max Sample Value             255､255､255
  
4 TIFFデータの作成

  TIFFのヘッダの作成については、上記のタグをみたしていればよいのですが、従来
データとの互換を高めるために、ヘッダや画像データの位置について、次のように作
成します。

  ●パレット無しデータ
    0000--0007      TIFFヘッダ
    0008--00C1      イメージファイルディレクトリ
    00C2--01EF      空き(または追加タグデータ)
    01F0--01FF      解像度タグのデータ
    0200--          画像本体
  
  ●16色パレット付きデータ
    0000--0007      TIFFヘッダ
    0008--00CD      イメージファイルディレクトリ
    00CE--00FF      空き(または追加タグデータ)
    0100--015F      パレットデータ(16*2*3バイト)
    0160--01EF      空き
    01F0--01FF      解像度タグのデータ
    0200--          画像本体
  
  ●256色パレット付きデータ
    0000--0007     TIFFヘッダ
    0008--00CD     イメージファイルディレクトリ
    00CE--01EF     空き(または追加タグデータ) 
    01F0--01FF     解像度タグのデータ
    0200--07FF     パレットデータ(256*2*3バイト)
    0800--         画像本体

   "空き"の部分は、パディングデータとして無視されます。

5 TIFFローダ/セーバの条件

  ●ローダの最低条件
    ･バイトオーダ、エディション番号のチェック
      頭の4バイトが49492A00

    ･IFDのオフセットチェック

    ･IFDエントリの数だけ、タグをチェック
     タグのチェックの際は、タグの種類や順序によらない解釈をしてください。
     すなわち、タグのデータが固定位置にあるものとしてはなりません。

    ･TOWNS標準形式であることの確認
     Subfile Type = 1 or New Subfile Type = 0
     Planer Config. = 1
     Subfile Typeのチェックは旧来データとの互換のため。
     この条件を満たさないものは、Towns標準TIFFではないとみなします。

    ･拡張機能のチェック
     Compression : 圧縮形式
     Photo. Interp., Color Map :  パレット
     圧縮をサポートしない場合は、Compressionが1以外だと読めないとして扱ってく
     ださい。Photo.Interp.=3でパレットが存在する場合、そのパレットを読み込ま
     ないと画像が保証されません。

    ･必要な画像情報の取り出し
     Bits Per Pixel, Samples Per Pixel : 色数
     Image Width, Image Length : 画像サイズ
     Strip Offset : 画像データ本体へのオフセット

   以上のチェックをして、サポートしていない、または不適当な内容の場合は、エラ
 ーとして処理し、アプリケーションで読めない旨の対応をしてください。

  ●セーバの最低条件
    2節の標準形式のヘッダを作成してください。
    その際、3節、4節の条件を満たすようにしてください。
    CLUTや圧縮のサポートは、2節、3節の記載に従った上で任意とします。
    ヘッダの具体例は、｢7 Towns標準TIFFヘッダ例｣を参照してください。

6 VS1.1版からV2.1版の変更点

  V2.1では以下の2点について変更されています。

 (1)16/256色での｢パレットなしTIFF｣を仕様から削除し、16/256色データに関しては
    、必ずパレットデータ(CLUT)を付ける。
    これは、従来の｢パレットなし16/256色TIFF｣は、TIFFの規約上はグレイスケール
    データとして認識されてしまうためです。
    アプリケーションは、パレットなしTIFFを読む場合には、T-BIOSの初期設定パレ
    ットのCLUTが付いているものと解釈します。

 (2)あらたにフルカラー(24bit)データを追加する。

7 Towns標準TIFFヘッダ例

  各モードごとのTIFFヘッダの例を示します。TIFFを作成するアプリケーションは、
以下の形式に従ってTIFFヘッダを作成すれば、仕様を満たすことができます。
  offset 0004 以降、tagやtype､ length､ value/offsetのすべてのワード/ロングワ
ードデータは、ヘッダのフォーマット"II"が示すとおり、インテルバイトオーダで格
納されることに注意してください。()内のデータはパディング用であり、0を格納しま
す。

  ●2色モード圧縮なし (640*480dot)

    offset
    0000  49 49 2A 00 
    0004  00000008    IFDオフセット
    
    0008  000F        タグの数(15)
    
          tag   type    length      value/offset
    000A  00FE  0004   00000001    00000000       (fixed)
    0016  0100  0003   00000001    0280 (0000)    横640ドット
    0022  0101  0003   00000001    01E0 (0000)    縦480ドット
    002E  0102  0003   00000001    0001 (0000)    1ビット/ピクセル
    003A  0103  0003   00000001    0001 (0000)    圧縮なし
    0046  0106  0003   00000001    0000 (0000)    2値イメージ
    0052  010A  0003   00000001    0001 (0000)
    005E  0111  0004   00000001    00000200       画像データオフセット
    006A  0115  0003   00000001    0001 (0000)
    0076  0116  0004   00000001    000001E0       =Image Length
    0082  0117  0004   00000001    00009600       =640/8*480
    008E  0119  0003   00000001    0001 (0000)
    009A  011A  0005   00000001    000001F0       (オフセット)
    00A6  011B  0005   00000001    000001F8       (オフセット)
    00B2  011C  0003   00000001    0001 (0000)    (fixed)
    00BE  00000000
    
    00C2〜01EF   padding
    
    01F0  0000004B 00000001   横解像度 75/1
    01F8  0000004B 00000001   縦解像度 75/1
    
    0200〜97FF  画像データ本体
  
  ●16色モード圧縮なし(640*480dot)
  
    offset
    0000  49 49 2A 00 
    0004  00000008    IFDオフセット
    
    0008  000F        タグの数(16)
    
          tag   type    length       value/offset
    000A  00FE  0004   00000001    00000000       (fixed)
    0016  0100  0003   00000001    0280 (0000)    横640ドット
    0022  0101  0003   00000001    01E0 (0000)    縦480ドット
    002E  0102  0003   00000001    0004 (0000)    4ビット/ピクセル
    003A  0103  0003   00000001    0001 (0000)    圧縮なし
    0046  0106  0003   00000001    0003 (0000)    CLUTイメージ
    0052  010A  0003   00000001    0002 (0000)    16色のみ例外
    005E  0111  0004   00000001    00000200       画像データオフセット
    006A  0115  0003   00000001    0001 (0000)
    0076  0116  0004   00000001    000001E0       =Image Length
    0082  0117  0004   00000001    00025800       =640/2*480
    008E  0119  0003   00000001    000F (0000)
    009A  011A  0005   00000001    000001F0       (オフセット)
    00A6  011B  0005   00000001    000001F8       (オフセット)
    00B2  011C  0003   00000001    0001 (0000)    (fixed)
    00BE  0140  0003   00000030    00000100       CLUTへのオフセット
    00CA  00000000
    
    00C2〜00FF   padding
    
    0100〜015F  CLUT
    
      0100〜011F  REDパレット  (word*16バイト)
      0120〜013F  GREENパレット(word*16バイト)
      0140〜015F  BLUEパレット (word*16バイト)
    
    0160〜01EF   padding
    
    01F0  0000004B 00000001   横解像度 75/1
    01F8  0000004B 00000001   縦解像度 75/1
    
    0200〜259FF  画像データ本体
  
  ●256色モード圧縮付き(640*480dot)
  
    offset
    0000  49 49 2A 00 
    0004  00000008    IFDオフセット
    
    0008  0010        タグの数(16)
    
          tag   type    length       value/offset
    000A  00FE  0004   00000001    00000000       (fixed)
    0016  0100  0003   00000001    0280 (0000)    横640ドット
    0022  0101  0003   00000001    01E0 (0000)    縦480ドット
    002E  0102  0003   00000001    0008 (0000)    8ビット/ピクセル
    003A  0103  0003   00000001    0005 (0000)    LZW圧縮
    0046  0106  0003   00000001    0003 (0000)    CLUTイメージ
    0052  010A  0003   00000001    0001 (0000)
    005E  0111  0004   00000001    00000800       画像データオフセット
    006A  0115  0003   00000001    0001 (0000)
    0076  0116  0004   00000001    000001E0       =Image Length
    0082  0117  0004   00000001    000XXXXXX       圧縮されたサイズ
    008E  0119  0003   00000001    00FF (0000)
    009A  011A  0005   00000001    000001F0       (オフセット)
    00A6  011B  0005   00000001    000001F8       (オフセット)
    00B2  011C  0003   00000001    0001 (0000)    (fixed)
    00BE  0140  0003   00000300    00000200       CLUTへのオフセット
    00CA  00000000
    
    00CE〜01EF   padding
    
    01F0  0000004B 00000001   横解像度 75/1
    01F8  0000004B 00000001   縦解像度 75/1
    
    0200〜07FF  CLUT
    
      0200〜03FF  REDパレット  (word*256バイト)
      0400〜05FF  GREENパレット(word*256バイト)
      0600〜07FF  BLUEパレット (word*256バイト)
    
    0800〜XXXXX  画像データ本体
  
  ●32768色データ圧縮なし(320*240dot)
  
    offset
    0000  49 49 2A 00 
    0004  00000008    IFDオフセット
    
    0008  000F        タグの数(15)
    
          tag   type    length       value/offset
    000A  00FE  0004   00000001    00000000       (fixed)
    0016  0100  0003   00000001    0140 (0000)    横320ドット
    0022  0101  0003   00000001    00F0 (0000)    縦240ドット
    002E  0102  0003   00000001    0010 (0000)    16ビット/ピクセル
    003A  0103  0003   00000001    0001 (0000)    圧縮なし
    0046  0106  0003   00000001    0001 (0000)    パレットなし
    0052  010A  0003   00000001    0001 (0000)
    005E  0111  0004   00000001    00000200       画像データオフセット
    006A  0115  0003   00000001    0001 (0000)
    0076  0116  0004   00000001    000000F0       =Image Length
    0082  0117  0004   00000001    00025800       =320*240*2
    008E  0119  0003   00000001    7FFF (0000)
    009A  011A  0005   00000001    000001F0       (オフセット)
    00A6  011B  0005   00000001    000001F8       (オフセット)
    00B2  011C  0003   00000001    0001 (0000)    (fixed)
    00BE  00000000
    
    00C2〜01EF   padding
    
    01F0  0000004B 00000002   横解像度 75/2
    01F8  0000004B 00000002   縦解像度 75/2
    
    0200〜259FF  画像データ本体
  
  ●フルカラー(24bit)圧縮なし(640x480dot)
  
    offset
    0000  49 49 2A 00 
    0004  00000008    IFDオフセット
    
    0008  000F        タグの数(15)
    
          tag   type    length       value/offset
    000A  00FE  0004   00000001    00000000       (fixed)
    0016  0100  0003   00000001    0280 (0000)    横640ドット
    0022  0101  0003   00000001    01E0 (0000)    縦480ドット
    002E  0102  0003   00000003    000001E4       (オフセット) 
    003A  0103  0003   00000001    0001 (0000)    非圧縮
    0046  0106  0003   00000001    0002 (0000)    RGBイメージ
    0052  010A  0003   00000001    0001 (0000)
    005E  0111  0004   00000001    00000200       画像データオフセット
    006A  0115  0003   00000001    0003 (0000)    RGBイメージ
    0076  0116  0004   00000001    000001E0       =Image Length
    0082  0117  0004   00000001    000E1000       =640*480*3
    008E  0119  0003   00000003    000001EA       (オフセット)
    009A  011A  0005   00000001    000001F0       (オフセット)
    00A6  011B  0005   00000001    000001F8       (オフセット)
    00B2  011C  0003   00000001    0001 (0000)    (fixed)
    00BE  00000000
    
    00C2〜01E3   padding
    
    01E4〜01E9   0008 0008 0008    RGB各8ビット/ピクセル
    01EA〜01EF   00FF 00FF 00FF    RGB各0〜255
    
    01F0  0000004B 00000001   横解像度 75/1
    01F8  0000004B 00000001   縦解像度 75/1
    
    0200〜0E2FFF  画像データ本体

